// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/team10/app/ent/abilitypatientrights"
	"github.com/team10/app/ent/bill"
	"github.com/team10/app/ent/department"
	"github.com/team10/app/ent/doctorinfo"
	"github.com/team10/app/ent/educationlevel"
	"github.com/team10/app/ent/financier"
	"github.com/team10/app/ent/gender"
	"github.com/team10/app/ent/historytaking"
	"github.com/team10/app/ent/insurance"
	"github.com/team10/app/ent/medicalrecordstaff"
	"github.com/team10/app/ent/nurse"
	"github.com/team10/app/ent/officeroom"
	"github.com/team10/app/ent/patientrecord"
	"github.com/team10/app/ent/patientrights"
	"github.com/team10/app/ent/patientrightstype"
	"github.com/team10/app/ent/paytype"
	"github.com/team10/app/ent/prename"
	"github.com/team10/app/ent/symptomseverity"
	"github.com/team10/app/ent/treatment"
	"github.com/team10/app/ent/typetreatment"
	"github.com/team10/app/ent/unpaybill"
	"github.com/team10/app/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAbilitypatientrights = "Abilitypatientrights"
	TypeBill                 = "Bill"
	TypeDepartment           = "Department"
	TypeDoctorinfo           = "Doctorinfo"
	TypeEducationlevel       = "Educationlevel"
	TypeFinancier            = "Financier"
	TypeGender               = "Gender"
	TypeHistorytaking        = "Historytaking"
	TypeInsurance            = "Insurance"
	TypeMedicalrecordstaff   = "Medicalrecordstaff"
	TypeNurse                = "Nurse"
	TypeOfficeroom           = "Officeroom"
	TypePatientrecord        = "Patientrecord"
	TypePatientrights        = "Patientrights"
	TypePatientrightstype    = "Patientrightstype"
	TypePaytype              = "Paytype"
	TypePrename              = "Prename"
	TypeSymptomseverity      = "Symptomseverity"
	TypeTreatment            = "Treatment"
	TypeTypetreatment        = "Typetreatment"
	TypeUnpaybill            = "Unpaybill"
	TypeUser                 = "User"
)

// AbilitypatientrightsMutation represents an operation that mutate the AbilitypatientrightsSlice
// nodes in the graph.
type AbilitypatientrightsMutation struct {
	config
	op                                            Op
	typ                                           string
	id                                            *int
	_Operative                                    *string
	_MedicalSupplies                              *string
	_Examine                                      *string
	clearedFields                                 map[string]struct{}
	_AbilitypatientrightsPatientrightstype        map[int]struct{}
	removed_AbilitypatientrightsPatientrightstype map[int]struct{}
	done                                          bool
	oldValue                                      func(context.Context) (*Abilitypatientrights, error)
}

var _ ent.Mutation = (*AbilitypatientrightsMutation)(nil)

// abilitypatientrightsOption allows to manage the mutation configuration using functional options.
type abilitypatientrightsOption func(*AbilitypatientrightsMutation)

// newAbilitypatientrightsMutation creates new mutation for $n.Name.
func newAbilitypatientrightsMutation(c config, op Op, opts ...abilitypatientrightsOption) *AbilitypatientrightsMutation {
	m := &AbilitypatientrightsMutation{
		config:        c,
		op:            op,
		typ:           TypeAbilitypatientrights,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAbilitypatientrightsID sets the id field of the mutation.
func withAbilitypatientrightsID(id int) abilitypatientrightsOption {
	return func(m *AbilitypatientrightsMutation) {
		var (
			err   error
			once  sync.Once
			value *Abilitypatientrights
		)
		m.oldValue = func(ctx context.Context) (*Abilitypatientrights, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Abilitypatientrights.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAbilitypatientrights sets the old Abilitypatientrights of the mutation.
func withAbilitypatientrights(node *Abilitypatientrights) abilitypatientrightsOption {
	return func(m *AbilitypatientrightsMutation) {
		m.oldValue = func(context.Context) (*Abilitypatientrights, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AbilitypatientrightsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AbilitypatientrightsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AbilitypatientrightsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOperative sets the Operative field.
func (m *AbilitypatientrightsMutation) SetOperative(s string) {
	m._Operative = &s
}

// Operative returns the Operative value in the mutation.
func (m *AbilitypatientrightsMutation) Operative() (r string, exists bool) {
	v := m._Operative
	if v == nil {
		return
	}
	return *v, true
}

// OldOperative returns the old Operative value of the Abilitypatientrights.
// If the Abilitypatientrights object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbilitypatientrightsMutation) OldOperative(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOperative is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOperative requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperative: %w", err)
	}
	return oldValue.Operative, nil
}

// ResetOperative reset all changes of the "Operative" field.
func (m *AbilitypatientrightsMutation) ResetOperative() {
	m._Operative = nil
}

// SetMedicalSupplies sets the MedicalSupplies field.
func (m *AbilitypatientrightsMutation) SetMedicalSupplies(s string) {
	m._MedicalSupplies = &s
}

// MedicalSupplies returns the MedicalSupplies value in the mutation.
func (m *AbilitypatientrightsMutation) MedicalSupplies() (r string, exists bool) {
	v := m._MedicalSupplies
	if v == nil {
		return
	}
	return *v, true
}

// OldMedicalSupplies returns the old MedicalSupplies value of the Abilitypatientrights.
// If the Abilitypatientrights object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbilitypatientrightsMutation) OldMedicalSupplies(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMedicalSupplies is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMedicalSupplies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedicalSupplies: %w", err)
	}
	return oldValue.MedicalSupplies, nil
}

// ResetMedicalSupplies reset all changes of the "MedicalSupplies" field.
func (m *AbilitypatientrightsMutation) ResetMedicalSupplies() {
	m._MedicalSupplies = nil
}

// SetExamine sets the Examine field.
func (m *AbilitypatientrightsMutation) SetExamine(s string) {
	m._Examine = &s
}

// Examine returns the Examine value in the mutation.
func (m *AbilitypatientrightsMutation) Examine() (r string, exists bool) {
	v := m._Examine
	if v == nil {
		return
	}
	return *v, true
}

// OldExamine returns the old Examine value of the Abilitypatientrights.
// If the Abilitypatientrights object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbilitypatientrightsMutation) OldExamine(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamine is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamine: %w", err)
	}
	return oldValue.Examine, nil
}

// ResetExamine reset all changes of the "Examine" field.
func (m *AbilitypatientrightsMutation) ResetExamine() {
	m._Examine = nil
}

// AddAbilitypatientrightsPatientrightstypeIDs adds the AbilitypatientrightsPatientrightstype edge to Patientrightstype by ids.
func (m *AbilitypatientrightsMutation) AddAbilitypatientrightsPatientrightstypeIDs(ids ...int) {
	if m._AbilitypatientrightsPatientrightstype == nil {
		m._AbilitypatientrightsPatientrightstype = make(map[int]struct{})
	}
	for i := range ids {
		m._AbilitypatientrightsPatientrightstype[ids[i]] = struct{}{}
	}
}

// RemoveAbilitypatientrightsPatientrightstypeIDs removes the AbilitypatientrightsPatientrightstype edge to Patientrightstype by ids.
func (m *AbilitypatientrightsMutation) RemoveAbilitypatientrightsPatientrightstypeIDs(ids ...int) {
	if m.removed_AbilitypatientrightsPatientrightstype == nil {
		m.removed_AbilitypatientrightsPatientrightstype = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_AbilitypatientrightsPatientrightstype[ids[i]] = struct{}{}
	}
}

// RemovedAbilitypatientrightsPatientrightstype returns the removed ids of AbilitypatientrightsPatientrightstype.
func (m *AbilitypatientrightsMutation) RemovedAbilitypatientrightsPatientrightstypeIDs() (ids []int) {
	for id := range m.removed_AbilitypatientrightsPatientrightstype {
		ids = append(ids, id)
	}
	return
}

// AbilitypatientrightsPatientrightstypeIDs returns the AbilitypatientrightsPatientrightstype ids in the mutation.
func (m *AbilitypatientrightsMutation) AbilitypatientrightsPatientrightstypeIDs() (ids []int) {
	for id := range m._AbilitypatientrightsPatientrightstype {
		ids = append(ids, id)
	}
	return
}

// ResetAbilitypatientrightsPatientrightstype reset all changes of the "AbilitypatientrightsPatientrightstype" edge.
func (m *AbilitypatientrightsMutation) ResetAbilitypatientrightsPatientrightstype() {
	m._AbilitypatientrightsPatientrightstype = nil
	m.removed_AbilitypatientrightsPatientrightstype = nil
}

// Op returns the operation name.
func (m *AbilitypatientrightsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Abilitypatientrights).
func (m *AbilitypatientrightsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AbilitypatientrightsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._Operative != nil {
		fields = append(fields, abilitypatientrights.FieldOperative)
	}
	if m._MedicalSupplies != nil {
		fields = append(fields, abilitypatientrights.FieldMedicalSupplies)
	}
	if m._Examine != nil {
		fields = append(fields, abilitypatientrights.FieldExamine)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AbilitypatientrightsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case abilitypatientrights.FieldOperative:
		return m.Operative()
	case abilitypatientrights.FieldMedicalSupplies:
		return m.MedicalSupplies()
	case abilitypatientrights.FieldExamine:
		return m.Examine()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AbilitypatientrightsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case abilitypatientrights.FieldOperative:
		return m.OldOperative(ctx)
	case abilitypatientrights.FieldMedicalSupplies:
		return m.OldMedicalSupplies(ctx)
	case abilitypatientrights.FieldExamine:
		return m.OldExamine(ctx)
	}
	return nil, fmt.Errorf("unknown Abilitypatientrights field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AbilitypatientrightsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case abilitypatientrights.FieldOperative:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperative(v)
		return nil
	case abilitypatientrights.FieldMedicalSupplies:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedicalSupplies(v)
		return nil
	case abilitypatientrights.FieldExamine:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamine(v)
		return nil
	}
	return fmt.Errorf("unknown Abilitypatientrights field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AbilitypatientrightsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AbilitypatientrightsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AbilitypatientrightsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Abilitypatientrights numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AbilitypatientrightsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AbilitypatientrightsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AbilitypatientrightsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Abilitypatientrights nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AbilitypatientrightsMutation) ResetField(name string) error {
	switch name {
	case abilitypatientrights.FieldOperative:
		m.ResetOperative()
		return nil
	case abilitypatientrights.FieldMedicalSupplies:
		m.ResetMedicalSupplies()
		return nil
	case abilitypatientrights.FieldExamine:
		m.ResetExamine()
		return nil
	}
	return fmt.Errorf("unknown Abilitypatientrights field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AbilitypatientrightsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._AbilitypatientrightsPatientrightstype != nil {
		edges = append(edges, abilitypatientrights.EdgeAbilitypatientrightsPatientrightstype)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AbilitypatientrightsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case abilitypatientrights.EdgeAbilitypatientrightsPatientrightstype:
		ids := make([]ent.Value, 0, len(m._AbilitypatientrightsPatientrightstype))
		for id := range m._AbilitypatientrightsPatientrightstype {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AbilitypatientrightsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_AbilitypatientrightsPatientrightstype != nil {
		edges = append(edges, abilitypatientrights.EdgeAbilitypatientrightsPatientrightstype)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AbilitypatientrightsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case abilitypatientrights.EdgeAbilitypatientrightsPatientrightstype:
		ids := make([]ent.Value, 0, len(m.removed_AbilitypatientrightsPatientrightstype))
		for id := range m.removed_AbilitypatientrightsPatientrightstype {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AbilitypatientrightsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AbilitypatientrightsMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AbilitypatientrightsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Abilitypatientrights unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AbilitypatientrightsMutation) ResetEdge(name string) error {
	switch name {
	case abilitypatientrights.EdgeAbilitypatientrightsPatientrightstype:
		m.ResetAbilitypatientrightsPatientrightstype()
		return nil
	}
	return fmt.Errorf("unknown Abilitypatientrights edge %s", name)
}

// BillMutation represents an operation that mutate the Bills
// nodes in the graph.
type BillMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_Amount          *string
	_Date            *time.Time
	clearedFields    map[string]struct{}
	paytype          *int
	clearedpaytype   bool
	officer          *int
	clearedofficer   bool
	treatment        *int
	clearedtreatment bool
	done             bool
	oldValue         func(context.Context) (*Bill, error)
}

var _ ent.Mutation = (*BillMutation)(nil)

// billOption allows to manage the mutation configuration using functional options.
type billOption func(*BillMutation)

// newBillMutation creates new mutation for $n.Name.
func newBillMutation(c config, op Op, opts ...billOption) *BillMutation {
	m := &BillMutation{
		config:        c,
		op:            op,
		typ:           TypeBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillID sets the id field of the mutation.
func withBillID(id int) billOption {
	return func(m *BillMutation) {
		var (
			err   error
			once  sync.Once
			value *Bill
		)
		m.oldValue = func(ctx context.Context) (*Bill, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBill sets the old Bill of the mutation.
func withBill(node *Bill) billOption {
	return func(m *BillMutation) {
		m.oldValue = func(context.Context) (*Bill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAmount sets the Amount field.
func (m *BillMutation) SetAmount(s string) {
	m._Amount = &s
}

// Amount returns the Amount value in the mutation.
func (m *BillMutation) Amount() (r string, exists bool) {
	v := m._Amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old Amount value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount reset all changes of the "Amount" field.
func (m *BillMutation) ResetAmount() {
	m._Amount = nil
}

// SetDate sets the Date field.
func (m *BillMutation) SetDate(t time.Time) {
	m._Date = &t
}

// Date returns the Date value in the mutation.
func (m *BillMutation) Date() (r time.Time, exists bool) {
	v := m._Date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old Date value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate reset all changes of the "Date" field.
func (m *BillMutation) ResetDate() {
	m._Date = nil
}

// SetPaytypeID sets the paytype edge to Paytype by id.
func (m *BillMutation) SetPaytypeID(id int) {
	m.paytype = &id
}

// ClearPaytype clears the paytype edge to Paytype.
func (m *BillMutation) ClearPaytype() {
	m.clearedpaytype = true
}

// PaytypeCleared returns if the edge paytype was cleared.
func (m *BillMutation) PaytypeCleared() bool {
	return m.clearedpaytype
}

// PaytypeID returns the paytype id in the mutation.
func (m *BillMutation) PaytypeID() (id int, exists bool) {
	if m.paytype != nil {
		return *m.paytype, true
	}
	return
}

// PaytypeIDs returns the paytype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PaytypeID instead. It exists only for internal usage by the builders.
func (m *BillMutation) PaytypeIDs() (ids []int) {
	if id := m.paytype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPaytype reset all changes of the "paytype" edge.
func (m *BillMutation) ResetPaytype() {
	m.paytype = nil
	m.clearedpaytype = false
}

// SetOfficerID sets the officer edge to Financier by id.
func (m *BillMutation) SetOfficerID(id int) {
	m.officer = &id
}

// ClearOfficer clears the officer edge to Financier.
func (m *BillMutation) ClearOfficer() {
	m.clearedofficer = true
}

// OfficerCleared returns if the edge officer was cleared.
func (m *BillMutation) OfficerCleared() bool {
	return m.clearedofficer
}

// OfficerID returns the officer id in the mutation.
func (m *BillMutation) OfficerID() (id int, exists bool) {
	if m.officer != nil {
		return *m.officer, true
	}
	return
}

// OfficerIDs returns the officer ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OfficerID instead. It exists only for internal usage by the builders.
func (m *BillMutation) OfficerIDs() (ids []int) {
	if id := m.officer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOfficer reset all changes of the "officer" edge.
func (m *BillMutation) ResetOfficer() {
	m.officer = nil
	m.clearedofficer = false
}

// SetTreatmentID sets the treatment edge to Unpaybill by id.
func (m *BillMutation) SetTreatmentID(id int) {
	m.treatment = &id
}

// ClearTreatment clears the treatment edge to Unpaybill.
func (m *BillMutation) ClearTreatment() {
	m.clearedtreatment = true
}

// TreatmentCleared returns if the edge treatment was cleared.
func (m *BillMutation) TreatmentCleared() bool {
	return m.clearedtreatment
}

// TreatmentID returns the treatment id in the mutation.
func (m *BillMutation) TreatmentID() (id int, exists bool) {
	if m.treatment != nil {
		return *m.treatment, true
	}
	return
}

// TreatmentIDs returns the treatment ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TreatmentID instead. It exists only for internal usage by the builders.
func (m *BillMutation) TreatmentIDs() (ids []int) {
	if id := m.treatment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTreatment reset all changes of the "treatment" edge.
func (m *BillMutation) ResetTreatment() {
	m.treatment = nil
	m.clearedtreatment = false
}

// Op returns the operation name.
func (m *BillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bill).
func (m *BillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BillMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Amount != nil {
		fields = append(fields, bill.FieldAmount)
	}
	if m._Date != nil {
		fields = append(fields, bill.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldAmount:
		return m.Amount()
	case bill.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bill.FieldAmount:
		return m.OldAmount(ctx)
	case bill.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown Bill field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bill.FieldAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case bill.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bill nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BillMutation) ResetField(name string) error {
	switch name {
	case bill.FieldAmount:
		m.ResetAmount()
		return nil
	case bill.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BillMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.paytype != nil {
		edges = append(edges, bill.EdgePaytype)
	}
	if m.officer != nil {
		edges = append(edges, bill.EdgeOfficer)
	}
	if m.treatment != nil {
		edges = append(edges, bill.EdgeTreatment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bill.EdgePaytype:
		if id := m.paytype; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeOfficer:
		if id := m.officer; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeTreatment:
		if id := m.treatment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpaytype {
		edges = append(edges, bill.EdgePaytype)
	}
	if m.clearedofficer {
		edges = append(edges, bill.EdgeOfficer)
	}
	if m.clearedtreatment {
		edges = append(edges, bill.EdgeTreatment)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BillMutation) EdgeCleared(name string) bool {
	switch name {
	case bill.EdgePaytype:
		return m.clearedpaytype
	case bill.EdgeOfficer:
		return m.clearedofficer
	case bill.EdgeTreatment:
		return m.clearedtreatment
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BillMutation) ClearEdge(name string) error {
	switch name {
	case bill.EdgePaytype:
		m.ClearPaytype()
		return nil
	case bill.EdgeOfficer:
		m.ClearOfficer()
		return nil
	case bill.EdgeTreatment:
		m.ClearTreatment()
		return nil
	}
	return fmt.Errorf("unknown Bill unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BillMutation) ResetEdge(name string) error {
	switch name {
	case bill.EdgePaytype:
		m.ResetPaytype()
		return nil
	case bill.EdgeOfficer:
		m.ResetOfficer()
		return nil
	case bill.EdgeTreatment:
		m.ResetTreatment()
		return nil
	}
	return fmt.Errorf("unknown Bill edge %s", name)
}

// DepartmentMutation represents an operation that mutate the Departments
// nodes in the graph.
type DepartmentMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	department                   *string
	clearedFields                map[string]struct{}
	department2doctorinfo        map[int]struct{}
	removeddepartment2doctorinfo map[int]struct{}
	historytaking                map[int]struct{}
	removedhistorytaking         map[int]struct{}
	done                         bool
	oldValue                     func(context.Context) (*Department, error)
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows to manage the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for $n.Name.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the id field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDepartment sets the department field.
func (m *DepartmentMutation) SetDepartment(s string) {
	m.department = &s
}

// Department returns the department value in the mutation.
func (m *DepartmentMutation) Department() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartment returns the old department value of the Department.
// If the Department object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepartmentMutation) OldDepartment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDepartment is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartment: %w", err)
	}
	return oldValue.Department, nil
}

// ResetDepartment reset all changes of the "department" field.
func (m *DepartmentMutation) ResetDepartment() {
	m.department = nil
}

// AddDepartment2doctorinfoIDs adds the department2doctorinfo edge to Doctorinfo by ids.
func (m *DepartmentMutation) AddDepartment2doctorinfoIDs(ids ...int) {
	if m.department2doctorinfo == nil {
		m.department2doctorinfo = make(map[int]struct{})
	}
	for i := range ids {
		m.department2doctorinfo[ids[i]] = struct{}{}
	}
}

// RemoveDepartment2doctorinfoIDs removes the department2doctorinfo edge to Doctorinfo by ids.
func (m *DepartmentMutation) RemoveDepartment2doctorinfoIDs(ids ...int) {
	if m.removeddepartment2doctorinfo == nil {
		m.removeddepartment2doctorinfo = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddepartment2doctorinfo[ids[i]] = struct{}{}
	}
}

// RemovedDepartment2doctorinfo returns the removed ids of department2doctorinfo.
func (m *DepartmentMutation) RemovedDepartment2doctorinfoIDs() (ids []int) {
	for id := range m.removeddepartment2doctorinfo {
		ids = append(ids, id)
	}
	return
}

// Department2doctorinfoIDs returns the department2doctorinfo ids in the mutation.
func (m *DepartmentMutation) Department2doctorinfoIDs() (ids []int) {
	for id := range m.department2doctorinfo {
		ids = append(ids, id)
	}
	return
}

// ResetDepartment2doctorinfo reset all changes of the "department2doctorinfo" edge.
func (m *DepartmentMutation) ResetDepartment2doctorinfo() {
	m.department2doctorinfo = nil
	m.removeddepartment2doctorinfo = nil
}

// AddHistorytakingIDs adds the historytaking edge to Historytaking by ids.
func (m *DepartmentMutation) AddHistorytakingIDs(ids ...int) {
	if m.historytaking == nil {
		m.historytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.historytaking[ids[i]] = struct{}{}
	}
}

// RemoveHistorytakingIDs removes the historytaking edge to Historytaking by ids.
func (m *DepartmentMutation) RemoveHistorytakingIDs(ids ...int) {
	if m.removedhistorytaking == nil {
		m.removedhistorytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhistorytaking[ids[i]] = struct{}{}
	}
}

// RemovedHistorytaking returns the removed ids of historytaking.
func (m *DepartmentMutation) RemovedHistorytakingIDs() (ids []int) {
	for id := range m.removedhistorytaking {
		ids = append(ids, id)
	}
	return
}

// HistorytakingIDs returns the historytaking ids in the mutation.
func (m *DepartmentMutation) HistorytakingIDs() (ids []int) {
	for id := range m.historytaking {
		ids = append(ids, id)
	}
	return
}

// ResetHistorytaking reset all changes of the "historytaking" edge.
func (m *DepartmentMutation) ResetHistorytaking() {
	m.historytaking = nil
	m.removedhistorytaking = nil
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.department != nil {
		fields = append(fields, department.FieldDepartment)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldDepartment:
		return m.Department()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldDepartment:
		return m.OldDepartment(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartment(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.department2doctorinfo != nil {
		edges = append(edges, department.EdgeDepartment2doctorinfo)
	}
	if m.historytaking != nil {
		edges = append(edges, department.EdgeHistorytaking)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeDepartment2doctorinfo:
		ids := make([]ent.Value, 0, len(m.department2doctorinfo))
		for id := range m.department2doctorinfo {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeHistorytaking:
		ids := make([]ent.Value, 0, len(m.historytaking))
		for id := range m.historytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddepartment2doctorinfo != nil {
		edges = append(edges, department.EdgeDepartment2doctorinfo)
	}
	if m.removedhistorytaking != nil {
		edges = append(edges, department.EdgeHistorytaking)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeDepartment2doctorinfo:
		ids := make([]ent.Value, 0, len(m.removeddepartment2doctorinfo))
		for id := range m.removeddepartment2doctorinfo {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeHistorytaking:
		ids := make([]ent.Value, 0, len(m.removedhistorytaking))
		for id := range m.removedhistorytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeDepartment2doctorinfo:
		m.ResetDepartment2doctorinfo()
		return nil
	case department.EdgeHistorytaking:
		m.ResetHistorytaking()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DoctorinfoMutation represents an operation that mutate the Doctorinfos
// nodes in the graph.
type DoctorinfoMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	doctorname            *string
	doctorsurname         *string
	telephonenumber       *string
	licensenumber         *string
	clearedFields         map[string]struct{}
	department            *int
	cleareddepartment     bool
	educationlevel        *int
	clearededucationlevel bool
	officeroom            *int
	clearedofficeroom     bool
	prename               *int
	clearedprename        bool
	user                  *int
	cleareduser           bool
	treatment             map[int]struct{}
	removedtreatment      map[int]struct{}
	done                  bool
	oldValue              func(context.Context) (*Doctorinfo, error)
}

var _ ent.Mutation = (*DoctorinfoMutation)(nil)

// doctorinfoOption allows to manage the mutation configuration using functional options.
type doctorinfoOption func(*DoctorinfoMutation)

// newDoctorinfoMutation creates new mutation for $n.Name.
func newDoctorinfoMutation(c config, op Op, opts ...doctorinfoOption) *DoctorinfoMutation {
	m := &DoctorinfoMutation{
		config:        c,
		op:            op,
		typ:           TypeDoctorinfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDoctorinfoID sets the id field of the mutation.
func withDoctorinfoID(id int) doctorinfoOption {
	return func(m *DoctorinfoMutation) {
		var (
			err   error
			once  sync.Once
			value *Doctorinfo
		)
		m.oldValue = func(ctx context.Context) (*Doctorinfo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Doctorinfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDoctorinfo sets the old Doctorinfo of the mutation.
func withDoctorinfo(node *Doctorinfo) doctorinfoOption {
	return func(m *DoctorinfoMutation) {
		m.oldValue = func(context.Context) (*Doctorinfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DoctorinfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DoctorinfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DoctorinfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDoctorname sets the doctorname field.
func (m *DoctorinfoMutation) SetDoctorname(s string) {
	m.doctorname = &s
}

// Doctorname returns the doctorname value in the mutation.
func (m *DoctorinfoMutation) Doctorname() (r string, exists bool) {
	v := m.doctorname
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorname returns the old doctorname value of the Doctorinfo.
// If the Doctorinfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorinfoMutation) OldDoctorname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctorname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctorname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorname: %w", err)
	}
	return oldValue.Doctorname, nil
}

// ResetDoctorname reset all changes of the "doctorname" field.
func (m *DoctorinfoMutation) ResetDoctorname() {
	m.doctorname = nil
}

// SetDoctorsurname sets the doctorsurname field.
func (m *DoctorinfoMutation) SetDoctorsurname(s string) {
	m.doctorsurname = &s
}

// Doctorsurname returns the doctorsurname value in the mutation.
func (m *DoctorinfoMutation) Doctorsurname() (r string, exists bool) {
	v := m.doctorsurname
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorsurname returns the old doctorsurname value of the Doctorinfo.
// If the Doctorinfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorinfoMutation) OldDoctorsurname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctorsurname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctorsurname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorsurname: %w", err)
	}
	return oldValue.Doctorsurname, nil
}

// ResetDoctorsurname reset all changes of the "doctorsurname" field.
func (m *DoctorinfoMutation) ResetDoctorsurname() {
	m.doctorsurname = nil
}

// SetTelephonenumber sets the telephonenumber field.
func (m *DoctorinfoMutation) SetTelephonenumber(s string) {
	m.telephonenumber = &s
}

// Telephonenumber returns the telephonenumber value in the mutation.
func (m *DoctorinfoMutation) Telephonenumber() (r string, exists bool) {
	v := m.telephonenumber
	if v == nil {
		return
	}
	return *v, true
}

// OldTelephonenumber returns the old telephonenumber value of the Doctorinfo.
// If the Doctorinfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorinfoMutation) OldTelephonenumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTelephonenumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTelephonenumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelephonenumber: %w", err)
	}
	return oldValue.Telephonenumber, nil
}

// ResetTelephonenumber reset all changes of the "telephonenumber" field.
func (m *DoctorinfoMutation) ResetTelephonenumber() {
	m.telephonenumber = nil
}

// SetLicensenumber sets the licensenumber field.
func (m *DoctorinfoMutation) SetLicensenumber(s string) {
	m.licensenumber = &s
}

// Licensenumber returns the licensenumber value in the mutation.
func (m *DoctorinfoMutation) Licensenumber() (r string, exists bool) {
	v := m.licensenumber
	if v == nil {
		return
	}
	return *v, true
}

// OldLicensenumber returns the old licensenumber value of the Doctorinfo.
// If the Doctorinfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorinfoMutation) OldLicensenumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLicensenumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLicensenumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicensenumber: %w", err)
	}
	return oldValue.Licensenumber, nil
}

// ResetLicensenumber reset all changes of the "licensenumber" field.
func (m *DoctorinfoMutation) ResetLicensenumber() {
	m.licensenumber = nil
}

// SetDepartmentID sets the department edge to Department by id.
func (m *DoctorinfoMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *DoctorinfoMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *DoctorinfoMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *DoctorinfoMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *DoctorinfoMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *DoctorinfoMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetEducationlevelID sets the educationlevel edge to Educationlevel by id.
func (m *DoctorinfoMutation) SetEducationlevelID(id int) {
	m.educationlevel = &id
}

// ClearEducationlevel clears the educationlevel edge to Educationlevel.
func (m *DoctorinfoMutation) ClearEducationlevel() {
	m.clearededucationlevel = true
}

// EducationlevelCleared returns if the edge educationlevel was cleared.
func (m *DoctorinfoMutation) EducationlevelCleared() bool {
	return m.clearededucationlevel
}

// EducationlevelID returns the educationlevel id in the mutation.
func (m *DoctorinfoMutation) EducationlevelID() (id int, exists bool) {
	if m.educationlevel != nil {
		return *m.educationlevel, true
	}
	return
}

// EducationlevelIDs returns the educationlevel ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EducationlevelID instead. It exists only for internal usage by the builders.
func (m *DoctorinfoMutation) EducationlevelIDs() (ids []int) {
	if id := m.educationlevel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEducationlevel reset all changes of the "educationlevel" edge.
func (m *DoctorinfoMutation) ResetEducationlevel() {
	m.educationlevel = nil
	m.clearededucationlevel = false
}

// SetOfficeroomID sets the officeroom edge to Officeroom by id.
func (m *DoctorinfoMutation) SetOfficeroomID(id int) {
	m.officeroom = &id
}

// ClearOfficeroom clears the officeroom edge to Officeroom.
func (m *DoctorinfoMutation) ClearOfficeroom() {
	m.clearedofficeroom = true
}

// OfficeroomCleared returns if the edge officeroom was cleared.
func (m *DoctorinfoMutation) OfficeroomCleared() bool {
	return m.clearedofficeroom
}

// OfficeroomID returns the officeroom id in the mutation.
func (m *DoctorinfoMutation) OfficeroomID() (id int, exists bool) {
	if m.officeroom != nil {
		return *m.officeroom, true
	}
	return
}

// OfficeroomIDs returns the officeroom ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OfficeroomID instead. It exists only for internal usage by the builders.
func (m *DoctorinfoMutation) OfficeroomIDs() (ids []int) {
	if id := m.officeroom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOfficeroom reset all changes of the "officeroom" edge.
func (m *DoctorinfoMutation) ResetOfficeroom() {
	m.officeroom = nil
	m.clearedofficeroom = false
}

// SetPrenameID sets the prename edge to Prename by id.
func (m *DoctorinfoMutation) SetPrenameID(id int) {
	m.prename = &id
}

// ClearPrename clears the prename edge to Prename.
func (m *DoctorinfoMutation) ClearPrename() {
	m.clearedprename = true
}

// PrenameCleared returns if the edge prename was cleared.
func (m *DoctorinfoMutation) PrenameCleared() bool {
	return m.clearedprename
}

// PrenameID returns the prename id in the mutation.
func (m *DoctorinfoMutation) PrenameID() (id int, exists bool) {
	if m.prename != nil {
		return *m.prename, true
	}
	return
}

// PrenameIDs returns the prename ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PrenameID instead. It exists only for internal usage by the builders.
func (m *DoctorinfoMutation) PrenameIDs() (ids []int) {
	if id := m.prename; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrename reset all changes of the "prename" edge.
func (m *DoctorinfoMutation) ResetPrename() {
	m.prename = nil
	m.clearedprename = false
}

// SetUserID sets the user edge to User by id.
func (m *DoctorinfoMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *DoctorinfoMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *DoctorinfoMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *DoctorinfoMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DoctorinfoMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *DoctorinfoMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddTreatmentIDs adds the treatment edge to Treatment by ids.
func (m *DoctorinfoMutation) AddTreatmentIDs(ids ...int) {
	if m.treatment == nil {
		m.treatment = make(map[int]struct{})
	}
	for i := range ids {
		m.treatment[ids[i]] = struct{}{}
	}
}

// RemoveTreatmentIDs removes the treatment edge to Treatment by ids.
func (m *DoctorinfoMutation) RemoveTreatmentIDs(ids ...int) {
	if m.removedtreatment == nil {
		m.removedtreatment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtreatment[ids[i]] = struct{}{}
	}
}

// RemovedTreatment returns the removed ids of treatment.
func (m *DoctorinfoMutation) RemovedTreatmentIDs() (ids []int) {
	for id := range m.removedtreatment {
		ids = append(ids, id)
	}
	return
}

// TreatmentIDs returns the treatment ids in the mutation.
func (m *DoctorinfoMutation) TreatmentIDs() (ids []int) {
	for id := range m.treatment {
		ids = append(ids, id)
	}
	return
}

// ResetTreatment reset all changes of the "treatment" edge.
func (m *DoctorinfoMutation) ResetTreatment() {
	m.treatment = nil
	m.removedtreatment = nil
}

// Op returns the operation name.
func (m *DoctorinfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Doctorinfo).
func (m *DoctorinfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DoctorinfoMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.doctorname != nil {
		fields = append(fields, doctorinfo.FieldDoctorname)
	}
	if m.doctorsurname != nil {
		fields = append(fields, doctorinfo.FieldDoctorsurname)
	}
	if m.telephonenumber != nil {
		fields = append(fields, doctorinfo.FieldTelephonenumber)
	}
	if m.licensenumber != nil {
		fields = append(fields, doctorinfo.FieldLicensenumber)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DoctorinfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case doctorinfo.FieldDoctorname:
		return m.Doctorname()
	case doctorinfo.FieldDoctorsurname:
		return m.Doctorsurname()
	case doctorinfo.FieldTelephonenumber:
		return m.Telephonenumber()
	case doctorinfo.FieldLicensenumber:
		return m.Licensenumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DoctorinfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case doctorinfo.FieldDoctorname:
		return m.OldDoctorname(ctx)
	case doctorinfo.FieldDoctorsurname:
		return m.OldDoctorsurname(ctx)
	case doctorinfo.FieldTelephonenumber:
		return m.OldTelephonenumber(ctx)
	case doctorinfo.FieldLicensenumber:
		return m.OldLicensenumber(ctx)
	}
	return nil, fmt.Errorf("unknown Doctorinfo field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DoctorinfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case doctorinfo.FieldDoctorname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorname(v)
		return nil
	case doctorinfo.FieldDoctorsurname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorsurname(v)
		return nil
	case doctorinfo.FieldTelephonenumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelephonenumber(v)
		return nil
	case doctorinfo.FieldLicensenumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicensenumber(v)
		return nil
	}
	return fmt.Errorf("unknown Doctorinfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DoctorinfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DoctorinfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DoctorinfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Doctorinfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DoctorinfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DoctorinfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DoctorinfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Doctorinfo nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DoctorinfoMutation) ResetField(name string) error {
	switch name {
	case doctorinfo.FieldDoctorname:
		m.ResetDoctorname()
		return nil
	case doctorinfo.FieldDoctorsurname:
		m.ResetDoctorsurname()
		return nil
	case doctorinfo.FieldTelephonenumber:
		m.ResetTelephonenumber()
		return nil
	case doctorinfo.FieldLicensenumber:
		m.ResetLicensenumber()
		return nil
	}
	return fmt.Errorf("unknown Doctorinfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DoctorinfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.department != nil {
		edges = append(edges, doctorinfo.EdgeDepartment)
	}
	if m.educationlevel != nil {
		edges = append(edges, doctorinfo.EdgeEducationlevel)
	}
	if m.officeroom != nil {
		edges = append(edges, doctorinfo.EdgeOfficeroom)
	}
	if m.prename != nil {
		edges = append(edges, doctorinfo.EdgePrename)
	}
	if m.user != nil {
		edges = append(edges, doctorinfo.EdgeUser)
	}
	if m.treatment != nil {
		edges = append(edges, doctorinfo.EdgeTreatment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DoctorinfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case doctorinfo.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case doctorinfo.EdgeEducationlevel:
		if id := m.educationlevel; id != nil {
			return []ent.Value{*id}
		}
	case doctorinfo.EdgeOfficeroom:
		if id := m.officeroom; id != nil {
			return []ent.Value{*id}
		}
	case doctorinfo.EdgePrename:
		if id := m.prename; id != nil {
			return []ent.Value{*id}
		}
	case doctorinfo.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case doctorinfo.EdgeTreatment:
		ids := make([]ent.Value, 0, len(m.treatment))
		for id := range m.treatment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DoctorinfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedtreatment != nil {
		edges = append(edges, doctorinfo.EdgeTreatment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DoctorinfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case doctorinfo.EdgeTreatment:
		ids := make([]ent.Value, 0, len(m.removedtreatment))
		for id := range m.removedtreatment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DoctorinfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleareddepartment {
		edges = append(edges, doctorinfo.EdgeDepartment)
	}
	if m.clearededucationlevel {
		edges = append(edges, doctorinfo.EdgeEducationlevel)
	}
	if m.clearedofficeroom {
		edges = append(edges, doctorinfo.EdgeOfficeroom)
	}
	if m.clearedprename {
		edges = append(edges, doctorinfo.EdgePrename)
	}
	if m.cleareduser {
		edges = append(edges, doctorinfo.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DoctorinfoMutation) EdgeCleared(name string) bool {
	switch name {
	case doctorinfo.EdgeDepartment:
		return m.cleareddepartment
	case doctorinfo.EdgeEducationlevel:
		return m.clearededucationlevel
	case doctorinfo.EdgeOfficeroom:
		return m.clearedofficeroom
	case doctorinfo.EdgePrename:
		return m.clearedprename
	case doctorinfo.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DoctorinfoMutation) ClearEdge(name string) error {
	switch name {
	case doctorinfo.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case doctorinfo.EdgeEducationlevel:
		m.ClearEducationlevel()
		return nil
	case doctorinfo.EdgeOfficeroom:
		m.ClearOfficeroom()
		return nil
	case doctorinfo.EdgePrename:
		m.ClearPrename()
		return nil
	case doctorinfo.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Doctorinfo unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DoctorinfoMutation) ResetEdge(name string) error {
	switch name {
	case doctorinfo.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case doctorinfo.EdgeEducationlevel:
		m.ResetEducationlevel()
		return nil
	case doctorinfo.EdgeOfficeroom:
		m.ResetOfficeroom()
		return nil
	case doctorinfo.EdgePrename:
		m.ResetPrename()
		return nil
	case doctorinfo.EdgeUser:
		m.ResetUser()
		return nil
	case doctorinfo.EdgeTreatment:
		m.ResetTreatment()
		return nil
	}
	return fmt.Errorf("unknown Doctorinfo edge %s", name)
}

// EducationlevelMutation represents an operation that mutate the Educationlevels
// nodes in the graph.
type EducationlevelMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	level                            *string
	clearedFields                    map[string]struct{}
	educationlevel2doctorinfo        map[int]struct{}
	removededucationlevel2doctorinfo map[int]struct{}
	done                             bool
	oldValue                         func(context.Context) (*Educationlevel, error)
}

var _ ent.Mutation = (*EducationlevelMutation)(nil)

// educationlevelOption allows to manage the mutation configuration using functional options.
type educationlevelOption func(*EducationlevelMutation)

// newEducationlevelMutation creates new mutation for $n.Name.
func newEducationlevelMutation(c config, op Op, opts ...educationlevelOption) *EducationlevelMutation {
	m := &EducationlevelMutation{
		config:        c,
		op:            op,
		typ:           TypeEducationlevel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEducationlevelID sets the id field of the mutation.
func withEducationlevelID(id int) educationlevelOption {
	return func(m *EducationlevelMutation) {
		var (
			err   error
			once  sync.Once
			value *Educationlevel
		)
		m.oldValue = func(ctx context.Context) (*Educationlevel, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Educationlevel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEducationlevel sets the old Educationlevel of the mutation.
func withEducationlevel(node *Educationlevel) educationlevelOption {
	return func(m *EducationlevelMutation) {
		m.oldValue = func(context.Context) (*Educationlevel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EducationlevelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EducationlevelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EducationlevelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLevel sets the level field.
func (m *EducationlevelMutation) SetLevel(s string) {
	m.level = &s
}

// Level returns the level value in the mutation.
func (m *EducationlevelMutation) Level() (r string, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old level value of the Educationlevel.
// If the Educationlevel object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EducationlevelMutation) OldLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLevel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel reset all changes of the "level" field.
func (m *EducationlevelMutation) ResetLevel() {
	m.level = nil
}

// AddEducationlevel2doctorinfoIDs adds the educationlevel2doctorinfo edge to Doctorinfo by ids.
func (m *EducationlevelMutation) AddEducationlevel2doctorinfoIDs(ids ...int) {
	if m.educationlevel2doctorinfo == nil {
		m.educationlevel2doctorinfo = make(map[int]struct{})
	}
	for i := range ids {
		m.educationlevel2doctorinfo[ids[i]] = struct{}{}
	}
}

// RemoveEducationlevel2doctorinfoIDs removes the educationlevel2doctorinfo edge to Doctorinfo by ids.
func (m *EducationlevelMutation) RemoveEducationlevel2doctorinfoIDs(ids ...int) {
	if m.removededucationlevel2doctorinfo == nil {
		m.removededucationlevel2doctorinfo = make(map[int]struct{})
	}
	for i := range ids {
		m.removededucationlevel2doctorinfo[ids[i]] = struct{}{}
	}
}

// RemovedEducationlevel2doctorinfo returns the removed ids of educationlevel2doctorinfo.
func (m *EducationlevelMutation) RemovedEducationlevel2doctorinfoIDs() (ids []int) {
	for id := range m.removededucationlevel2doctorinfo {
		ids = append(ids, id)
	}
	return
}

// Educationlevel2doctorinfoIDs returns the educationlevel2doctorinfo ids in the mutation.
func (m *EducationlevelMutation) Educationlevel2doctorinfoIDs() (ids []int) {
	for id := range m.educationlevel2doctorinfo {
		ids = append(ids, id)
	}
	return
}

// ResetEducationlevel2doctorinfo reset all changes of the "educationlevel2doctorinfo" edge.
func (m *EducationlevelMutation) ResetEducationlevel2doctorinfo() {
	m.educationlevel2doctorinfo = nil
	m.removededucationlevel2doctorinfo = nil
}

// Op returns the operation name.
func (m *EducationlevelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Educationlevel).
func (m *EducationlevelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EducationlevelMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.level != nil {
		fields = append(fields, educationlevel.FieldLevel)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EducationlevelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case educationlevel.FieldLevel:
		return m.Level()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EducationlevelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case educationlevel.FieldLevel:
		return m.OldLevel(ctx)
	}
	return nil, fmt.Errorf("unknown Educationlevel field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EducationlevelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case educationlevel.FieldLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Educationlevel field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EducationlevelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EducationlevelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EducationlevelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Educationlevel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EducationlevelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EducationlevelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EducationlevelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Educationlevel nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EducationlevelMutation) ResetField(name string) error {
	switch name {
	case educationlevel.FieldLevel:
		m.ResetLevel()
		return nil
	}
	return fmt.Errorf("unknown Educationlevel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EducationlevelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.educationlevel2doctorinfo != nil {
		edges = append(edges, educationlevel.EdgeEducationlevel2doctorinfo)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EducationlevelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case educationlevel.EdgeEducationlevel2doctorinfo:
		ids := make([]ent.Value, 0, len(m.educationlevel2doctorinfo))
		for id := range m.educationlevel2doctorinfo {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EducationlevelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removededucationlevel2doctorinfo != nil {
		edges = append(edges, educationlevel.EdgeEducationlevel2doctorinfo)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EducationlevelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case educationlevel.EdgeEducationlevel2doctorinfo:
		ids := make([]ent.Value, 0, len(m.removededucationlevel2doctorinfo))
		for id := range m.removededucationlevel2doctorinfo {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EducationlevelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EducationlevelMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EducationlevelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Educationlevel unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EducationlevelMutation) ResetEdge(name string) error {
	switch name {
	case educationlevel.EdgeEducationlevel2doctorinfo:
		m.ResetEducationlevel2doctorinfo()
		return nil
	}
	return fmt.Errorf("unknown Educationlevel edge %s", name)
}

// FinancierMutation represents an operation that mutate the Financiers
// nodes in the graph.
type FinancierMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	bills         map[int]struct{}
	removedbills  map[int]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Financier, error)
}

var _ ent.Mutation = (*FinancierMutation)(nil)

// financierOption allows to manage the mutation configuration using functional options.
type financierOption func(*FinancierMutation)

// newFinancierMutation creates new mutation for $n.Name.
func newFinancierMutation(c config, op Op, opts ...financierOption) *FinancierMutation {
	m := &FinancierMutation{
		config:        c,
		op:            op,
		typ:           TypeFinancier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFinancierID sets the id field of the mutation.
func withFinancierID(id int) financierOption {
	return func(m *FinancierMutation) {
		var (
			err   error
			once  sync.Once
			value *Financier
		)
		m.oldValue = func(ctx context.Context) (*Financier, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Financier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFinancier sets the old Financier of the mutation.
func withFinancier(node *Financier) financierOption {
	return func(m *FinancierMutation) {
		m.oldValue = func(context.Context) (*Financier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FinancierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FinancierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FinancierMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *FinancierMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *FinancierMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Financier.
// If the Financier object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FinancierMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *FinancierMutation) ResetName() {
	m.name = nil
}

// AddBillIDs adds the bills edge to Bill by ids.
func (m *FinancierMutation) AddBillIDs(ids ...int) {
	if m.bills == nil {
		m.bills = make(map[int]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// RemoveBillIDs removes the bills edge to Bill by ids.
func (m *FinancierMutation) RemoveBillIDs(ids ...int) {
	if m.removedbills == nil {
		m.removedbills = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed ids of bills.
func (m *FinancierMutation) RemovedBillsIDs() (ids []int) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the bills ids in the mutation.
func (m *FinancierMutation) BillsIDs() (ids []int) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills reset all changes of the "bills" edge.
func (m *FinancierMutation) ResetBills() {
	m.bills = nil
	m.removedbills = nil
}

// SetUserID sets the user edge to User by id.
func (m *FinancierMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *FinancierMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *FinancierMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *FinancierMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *FinancierMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *FinancierMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *FinancierMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Financier).
func (m *FinancierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FinancierMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, financier.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FinancierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case financier.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FinancierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case financier.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Financier field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FinancierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case financier.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Financier field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FinancierMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FinancierMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FinancierMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Financier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FinancierMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FinancierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FinancierMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Financier nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FinancierMutation) ResetField(name string) error {
	switch name {
	case financier.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Financier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FinancierMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.bills != nil {
		edges = append(edges, financier.EdgeBills)
	}
	if m.user != nil {
		edges = append(edges, financier.EdgeUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FinancierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case financier.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	case financier.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FinancierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbills != nil {
		edges = append(edges, financier.EdgeBills)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FinancierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case financier.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FinancierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, financier.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FinancierMutation) EdgeCleared(name string) bool {
	switch name {
	case financier.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FinancierMutation) ClearEdge(name string) error {
	switch name {
	case financier.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Financier unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FinancierMutation) ResetEdge(name string) error {
	switch name {
	case financier.EdgeBills:
		m.ResetBills()
		return nil
	case financier.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Financier edge %s", name)
}

// GenderMutation represents an operation that mutate the Genders
// nodes in the graph.
type GenderMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_Genderstatus        *string
	clearedFields        map[string]struct{}
	patientrecord        map[int]struct{}
	removedpatientrecord map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Gender, error)
}

var _ ent.Mutation = (*GenderMutation)(nil)

// genderOption allows to manage the mutation configuration using functional options.
type genderOption func(*GenderMutation)

// newGenderMutation creates new mutation for $n.Name.
func newGenderMutation(c config, op Op, opts ...genderOption) *GenderMutation {
	m := &GenderMutation{
		config:        c,
		op:            op,
		typ:           TypeGender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenderID sets the id field of the mutation.
func withGenderID(id int) genderOption {
	return func(m *GenderMutation) {
		var (
			err   error
			once  sync.Once
			value *Gender
		)
		m.oldValue = func(ctx context.Context) (*Gender, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGender sets the old Gender of the mutation.
func withGender(node *Gender) genderOption {
	return func(m *GenderMutation) {
		m.oldValue = func(context.Context) (*Gender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *GenderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGenderstatus sets the Genderstatus field.
func (m *GenderMutation) SetGenderstatus(s string) {
	m._Genderstatus = &s
}

// Genderstatus returns the Genderstatus value in the mutation.
func (m *GenderMutation) Genderstatus() (r string, exists bool) {
	v := m._Genderstatus
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderstatus returns the old Genderstatus value of the Gender.
// If the Gender object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *GenderMutation) OldGenderstatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGenderstatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGenderstatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderstatus: %w", err)
	}
	return oldValue.Genderstatus, nil
}

// ResetGenderstatus reset all changes of the "Genderstatus" field.
func (m *GenderMutation) ResetGenderstatus() {
	m._Genderstatus = nil
}

// AddPatientrecordIDs adds the patientrecord edge to Patientrecord by ids.
func (m *GenderMutation) AddPatientrecordIDs(ids ...int) {
	if m.patientrecord == nil {
		m.patientrecord = make(map[int]struct{})
	}
	for i := range ids {
		m.patientrecord[ids[i]] = struct{}{}
	}
}

// RemovePatientrecordIDs removes the patientrecord edge to Patientrecord by ids.
func (m *GenderMutation) RemovePatientrecordIDs(ids ...int) {
	if m.removedpatientrecord == nil {
		m.removedpatientrecord = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpatientrecord[ids[i]] = struct{}{}
	}
}

// RemovedPatientrecord returns the removed ids of patientrecord.
func (m *GenderMutation) RemovedPatientrecordIDs() (ids []int) {
	for id := range m.removedpatientrecord {
		ids = append(ids, id)
	}
	return
}

// PatientrecordIDs returns the patientrecord ids in the mutation.
func (m *GenderMutation) PatientrecordIDs() (ids []int) {
	for id := range m.patientrecord {
		ids = append(ids, id)
	}
	return
}

// ResetPatientrecord reset all changes of the "patientrecord" edge.
func (m *GenderMutation) ResetPatientrecord() {
	m.patientrecord = nil
	m.removedpatientrecord = nil
}

// Op returns the operation name.
func (m *GenderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Gender).
func (m *GenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *GenderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Genderstatus != nil {
		fields = append(fields, gender.FieldGenderstatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *GenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gender.FieldGenderstatus:
		return m.Genderstatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *GenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gender.FieldGenderstatus:
		return m.OldGenderstatus(ctx)
	}
	return nil, fmt.Errorf("unknown Gender field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gender.FieldGenderstatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderstatus(v)
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *GenderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *GenderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *GenderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *GenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Gender nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *GenderMutation) ResetField(name string) error {
	switch name {
	case gender.FieldGenderstatus:
		m.ResetGenderstatus()
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *GenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.patientrecord != nil {
		edges = append(edges, gender.EdgePatientrecord)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *GenderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgePatientrecord:
		ids := make([]ent.Value, 0, len(m.patientrecord))
		for id := range m.patientrecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *GenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpatientrecord != nil {
		edges = append(edges, gender.EdgePatientrecord)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *GenderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgePatientrecord:
		ids := make([]ent.Value, 0, len(m.removedpatientrecord))
		for id := range m.removedpatientrecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *GenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *GenderMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *GenderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *GenderMutation) ResetEdge(name string) error {
	switch name {
	case gender.EdgePatientrecord:
		m.ResetPatientrecord()
		return nil
	}
	return fmt.Errorf("unknown Gender edge %s", name)
}

// HistorytakingMutation represents an operation that mutate the Historytakings
// nodes in the graph.
type HistorytakingMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	hight                  *float32
	addhight               *float32
	weight                 *float32
	addweight              *float32
	temp                   *float32
	addtemp                *float32
	pulse                  *int
	addpulse               *int
	respiration            *int
	addrespiration         *int
	bp                     *int
	addbp                  *int
	oxygen                 *string
	symptom                *string
	datetime               *time.Time
	clearedFields          map[string]struct{}
	nurse                  *int
	clearednurse           bool
	department             *int
	cleareddepartment      bool
	symptomseverity        *int
	clearedsymptomseverity bool
	patientrecord          *int
	clearedpatientrecord   bool
	done                   bool
	oldValue               func(context.Context) (*Historytaking, error)
}

var _ ent.Mutation = (*HistorytakingMutation)(nil)

// historytakingOption allows to manage the mutation configuration using functional options.
type historytakingOption func(*HistorytakingMutation)

// newHistorytakingMutation creates new mutation for $n.Name.
func newHistorytakingMutation(c config, op Op, opts ...historytakingOption) *HistorytakingMutation {
	m := &HistorytakingMutation{
		config:        c,
		op:            op,
		typ:           TypeHistorytaking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHistorytakingID sets the id field of the mutation.
func withHistorytakingID(id int) historytakingOption {
	return func(m *HistorytakingMutation) {
		var (
			err   error
			once  sync.Once
			value *Historytaking
		)
		m.oldValue = func(ctx context.Context) (*Historytaking, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Historytaking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHistorytaking sets the old Historytaking of the mutation.
func withHistorytaking(node *Historytaking) historytakingOption {
	return func(m *HistorytakingMutation) {
		m.oldValue = func(context.Context) (*Historytaking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HistorytakingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HistorytakingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *HistorytakingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHight sets the hight field.
func (m *HistorytakingMutation) SetHight(f float32) {
	m.hight = &f
	m.addhight = nil
}

// Hight returns the hight value in the mutation.
func (m *HistorytakingMutation) Hight() (r float32, exists bool) {
	v := m.hight
	if v == nil {
		return
	}
	return *v, true
}

// OldHight returns the old hight value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldHight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHight: %w", err)
	}
	return oldValue.Hight, nil
}

// AddHight adds f to hight.
func (m *HistorytakingMutation) AddHight(f float32) {
	if m.addhight != nil {
		*m.addhight += f
	} else {
		m.addhight = &f
	}
}

// AddedHight returns the value that was added to the hight field in this mutation.
func (m *HistorytakingMutation) AddedHight() (r float32, exists bool) {
	v := m.addhight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHight reset all changes of the "hight" field.
func (m *HistorytakingMutation) ResetHight() {
	m.hight = nil
	m.addhight = nil
}

// SetWeight sets the weight field.
func (m *HistorytakingMutation) SetWeight(f float32) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the weight value in the mutation.
func (m *HistorytakingMutation) Weight() (r float32, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old weight value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to weight.
func (m *HistorytakingMutation) AddWeight(f float32) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the weight field in this mutation.
func (m *HistorytakingMutation) AddedWeight() (r float32, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight reset all changes of the "weight" field.
func (m *HistorytakingMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetTemp sets the temp field.
func (m *HistorytakingMutation) SetTemp(f float32) {
	m.temp = &f
	m.addtemp = nil
}

// Temp returns the temp value in the mutation.
func (m *HistorytakingMutation) Temp() (r float32, exists bool) {
	v := m.temp
	if v == nil {
		return
	}
	return *v, true
}

// OldTemp returns the old temp value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldTemp(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTemp is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemp: %w", err)
	}
	return oldValue.Temp, nil
}

// AddTemp adds f to temp.
func (m *HistorytakingMutation) AddTemp(f float32) {
	if m.addtemp != nil {
		*m.addtemp += f
	} else {
		m.addtemp = &f
	}
}

// AddedTemp returns the value that was added to the temp field in this mutation.
func (m *HistorytakingMutation) AddedTemp() (r float32, exists bool) {
	v := m.addtemp
	if v == nil {
		return
	}
	return *v, true
}

// ResetTemp reset all changes of the "temp" field.
func (m *HistorytakingMutation) ResetTemp() {
	m.temp = nil
	m.addtemp = nil
}

// SetPulse sets the pulse field.
func (m *HistorytakingMutation) SetPulse(i int) {
	m.pulse = &i
	m.addpulse = nil
}

// Pulse returns the pulse value in the mutation.
func (m *HistorytakingMutation) Pulse() (r int, exists bool) {
	v := m.pulse
	if v == nil {
		return
	}
	return *v, true
}

// OldPulse returns the old pulse value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldPulse(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPulse is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPulse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPulse: %w", err)
	}
	return oldValue.Pulse, nil
}

// AddPulse adds i to pulse.
func (m *HistorytakingMutation) AddPulse(i int) {
	if m.addpulse != nil {
		*m.addpulse += i
	} else {
		m.addpulse = &i
	}
}

// AddedPulse returns the value that was added to the pulse field in this mutation.
func (m *HistorytakingMutation) AddedPulse() (r int, exists bool) {
	v := m.addpulse
	if v == nil {
		return
	}
	return *v, true
}

// ResetPulse reset all changes of the "pulse" field.
func (m *HistorytakingMutation) ResetPulse() {
	m.pulse = nil
	m.addpulse = nil
}

// SetRespiration sets the respiration field.
func (m *HistorytakingMutation) SetRespiration(i int) {
	m.respiration = &i
	m.addrespiration = nil
}

// Respiration returns the respiration value in the mutation.
func (m *HistorytakingMutation) Respiration() (r int, exists bool) {
	v := m.respiration
	if v == nil {
		return
	}
	return *v, true
}

// OldRespiration returns the old respiration value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldRespiration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRespiration is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRespiration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespiration: %w", err)
	}
	return oldValue.Respiration, nil
}

// AddRespiration adds i to respiration.
func (m *HistorytakingMutation) AddRespiration(i int) {
	if m.addrespiration != nil {
		*m.addrespiration += i
	} else {
		m.addrespiration = &i
	}
}

// AddedRespiration returns the value that was added to the respiration field in this mutation.
func (m *HistorytakingMutation) AddedRespiration() (r int, exists bool) {
	v := m.addrespiration
	if v == nil {
		return
	}
	return *v, true
}

// ResetRespiration reset all changes of the "respiration" field.
func (m *HistorytakingMutation) ResetRespiration() {
	m.respiration = nil
	m.addrespiration = nil
}

// SetBp sets the bp field.
func (m *HistorytakingMutation) SetBp(i int) {
	m.bp = &i
	m.addbp = nil
}

// Bp returns the bp value in the mutation.
func (m *HistorytakingMutation) Bp() (r int, exists bool) {
	v := m.bp
	if v == nil {
		return
	}
	return *v, true
}

// OldBp returns the old bp value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldBp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBp is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBp: %w", err)
	}
	return oldValue.Bp, nil
}

// AddBp adds i to bp.
func (m *HistorytakingMutation) AddBp(i int) {
	if m.addbp != nil {
		*m.addbp += i
	} else {
		m.addbp = &i
	}
}

// AddedBp returns the value that was added to the bp field in this mutation.
func (m *HistorytakingMutation) AddedBp() (r int, exists bool) {
	v := m.addbp
	if v == nil {
		return
	}
	return *v, true
}

// ResetBp reset all changes of the "bp" field.
func (m *HistorytakingMutation) ResetBp() {
	m.bp = nil
	m.addbp = nil
}

// SetOxygen sets the oxygen field.
func (m *HistorytakingMutation) SetOxygen(s string) {
	m.oxygen = &s
}

// Oxygen returns the oxygen value in the mutation.
func (m *HistorytakingMutation) Oxygen() (r string, exists bool) {
	v := m.oxygen
	if v == nil {
		return
	}
	return *v, true
}

// OldOxygen returns the old oxygen value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldOxygen(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOxygen is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOxygen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOxygen: %w", err)
	}
	return oldValue.Oxygen, nil
}

// ResetOxygen reset all changes of the "oxygen" field.
func (m *HistorytakingMutation) ResetOxygen() {
	m.oxygen = nil
}

// SetSymptom sets the symptom field.
func (m *HistorytakingMutation) SetSymptom(s string) {
	m.symptom = &s
}

// Symptom returns the symptom value in the mutation.
func (m *HistorytakingMutation) Symptom() (r string, exists bool) {
	v := m.symptom
	if v == nil {
		return
	}
	return *v, true
}

// OldSymptom returns the old symptom value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldSymptom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSymptom is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSymptom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymptom: %w", err)
	}
	return oldValue.Symptom, nil
}

// ResetSymptom reset all changes of the "symptom" field.
func (m *HistorytakingMutation) ResetSymptom() {
	m.symptom = nil
}

// SetDatetime sets the datetime field.
func (m *HistorytakingMutation) SetDatetime(t time.Time) {
	m.datetime = &t
}

// Datetime returns the datetime value in the mutation.
func (m *HistorytakingMutation) Datetime() (r time.Time, exists bool) {
	v := m.datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetime returns the old datetime value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDatetime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetime: %w", err)
	}
	return oldValue.Datetime, nil
}

// ResetDatetime reset all changes of the "datetime" field.
func (m *HistorytakingMutation) ResetDatetime() {
	m.datetime = nil
}

// SetNurseID sets the nurse edge to Nurse by id.
func (m *HistorytakingMutation) SetNurseID(id int) {
	m.nurse = &id
}

// ClearNurse clears the nurse edge to Nurse.
func (m *HistorytakingMutation) ClearNurse() {
	m.clearednurse = true
}

// NurseCleared returns if the edge nurse was cleared.
func (m *HistorytakingMutation) NurseCleared() bool {
	return m.clearednurse
}

// NurseID returns the nurse id in the mutation.
func (m *HistorytakingMutation) NurseID() (id int, exists bool) {
	if m.nurse != nil {
		return *m.nurse, true
	}
	return
}

// NurseIDs returns the nurse ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// NurseID instead. It exists only for internal usage by the builders.
func (m *HistorytakingMutation) NurseIDs() (ids []int) {
	if id := m.nurse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNurse reset all changes of the "nurse" edge.
func (m *HistorytakingMutation) ResetNurse() {
	m.nurse = nil
	m.clearednurse = false
}

// SetDepartmentID sets the department edge to Department by id.
func (m *HistorytakingMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *HistorytakingMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *HistorytakingMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *HistorytakingMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *HistorytakingMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *HistorytakingMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetSymptomseverityID sets the symptomseverity edge to Symptomseverity by id.
func (m *HistorytakingMutation) SetSymptomseverityID(id int) {
	m.symptomseverity = &id
}

// ClearSymptomseverity clears the symptomseverity edge to Symptomseverity.
func (m *HistorytakingMutation) ClearSymptomseverity() {
	m.clearedsymptomseverity = true
}

// SymptomseverityCleared returns if the edge symptomseverity was cleared.
func (m *HistorytakingMutation) SymptomseverityCleared() bool {
	return m.clearedsymptomseverity
}

// SymptomseverityID returns the symptomseverity id in the mutation.
func (m *HistorytakingMutation) SymptomseverityID() (id int, exists bool) {
	if m.symptomseverity != nil {
		return *m.symptomseverity, true
	}
	return
}

// SymptomseverityIDs returns the symptomseverity ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SymptomseverityID instead. It exists only for internal usage by the builders.
func (m *HistorytakingMutation) SymptomseverityIDs() (ids []int) {
	if id := m.symptomseverity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSymptomseverity reset all changes of the "symptomseverity" edge.
func (m *HistorytakingMutation) ResetSymptomseverity() {
	m.symptomseverity = nil
	m.clearedsymptomseverity = false
}

// SetPatientrecordID sets the patientrecord edge to Patientrecord by id.
func (m *HistorytakingMutation) SetPatientrecordID(id int) {
	m.patientrecord = &id
}

// ClearPatientrecord clears the patientrecord edge to Patientrecord.
func (m *HistorytakingMutation) ClearPatientrecord() {
	m.clearedpatientrecord = true
}

// PatientrecordCleared returns if the edge patientrecord was cleared.
func (m *HistorytakingMutation) PatientrecordCleared() bool {
	return m.clearedpatientrecord
}

// PatientrecordID returns the patientrecord id in the mutation.
func (m *HistorytakingMutation) PatientrecordID() (id int, exists bool) {
	if m.patientrecord != nil {
		return *m.patientrecord, true
	}
	return
}

// PatientrecordIDs returns the patientrecord ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PatientrecordID instead. It exists only for internal usage by the builders.
func (m *HistorytakingMutation) PatientrecordIDs() (ids []int) {
	if id := m.patientrecord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatientrecord reset all changes of the "patientrecord" edge.
func (m *HistorytakingMutation) ResetPatientrecord() {
	m.patientrecord = nil
	m.clearedpatientrecord = false
}

// Op returns the operation name.
func (m *HistorytakingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Historytaking).
func (m *HistorytakingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *HistorytakingMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.hight != nil {
		fields = append(fields, historytaking.FieldHight)
	}
	if m.weight != nil {
		fields = append(fields, historytaking.FieldWeight)
	}
	if m.temp != nil {
		fields = append(fields, historytaking.FieldTemp)
	}
	if m.pulse != nil {
		fields = append(fields, historytaking.FieldPulse)
	}
	if m.respiration != nil {
		fields = append(fields, historytaking.FieldRespiration)
	}
	if m.bp != nil {
		fields = append(fields, historytaking.FieldBp)
	}
	if m.oxygen != nil {
		fields = append(fields, historytaking.FieldOxygen)
	}
	if m.symptom != nil {
		fields = append(fields, historytaking.FieldSymptom)
	}
	if m.datetime != nil {
		fields = append(fields, historytaking.FieldDatetime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *HistorytakingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case historytaking.FieldHight:
		return m.Hight()
	case historytaking.FieldWeight:
		return m.Weight()
	case historytaking.FieldTemp:
		return m.Temp()
	case historytaking.FieldPulse:
		return m.Pulse()
	case historytaking.FieldRespiration:
		return m.Respiration()
	case historytaking.FieldBp:
		return m.Bp()
	case historytaking.FieldOxygen:
		return m.Oxygen()
	case historytaking.FieldSymptom:
		return m.Symptom()
	case historytaking.FieldDatetime:
		return m.Datetime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *HistorytakingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case historytaking.FieldHight:
		return m.OldHight(ctx)
	case historytaking.FieldWeight:
		return m.OldWeight(ctx)
	case historytaking.FieldTemp:
		return m.OldTemp(ctx)
	case historytaking.FieldPulse:
		return m.OldPulse(ctx)
	case historytaking.FieldRespiration:
		return m.OldRespiration(ctx)
	case historytaking.FieldBp:
		return m.OldBp(ctx)
	case historytaking.FieldOxygen:
		return m.OldOxygen(ctx)
	case historytaking.FieldSymptom:
		return m.OldSymptom(ctx)
	case historytaking.FieldDatetime:
		return m.OldDatetime(ctx)
	}
	return nil, fmt.Errorf("unknown Historytaking field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HistorytakingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case historytaking.FieldHight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHight(v)
		return nil
	case historytaking.FieldWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case historytaking.FieldTemp:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemp(v)
		return nil
	case historytaking.FieldPulse:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPulse(v)
		return nil
	case historytaking.FieldRespiration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespiration(v)
		return nil
	case historytaking.FieldBp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBp(v)
		return nil
	case historytaking.FieldOxygen:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOxygen(v)
		return nil
	case historytaking.FieldSymptom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymptom(v)
		return nil
	case historytaking.FieldDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetime(v)
		return nil
	}
	return fmt.Errorf("unknown Historytaking field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *HistorytakingMutation) AddedFields() []string {
	var fields []string
	if m.addhight != nil {
		fields = append(fields, historytaking.FieldHight)
	}
	if m.addweight != nil {
		fields = append(fields, historytaking.FieldWeight)
	}
	if m.addtemp != nil {
		fields = append(fields, historytaking.FieldTemp)
	}
	if m.addpulse != nil {
		fields = append(fields, historytaking.FieldPulse)
	}
	if m.addrespiration != nil {
		fields = append(fields, historytaking.FieldRespiration)
	}
	if m.addbp != nil {
		fields = append(fields, historytaking.FieldBp)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *HistorytakingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case historytaking.FieldHight:
		return m.AddedHight()
	case historytaking.FieldWeight:
		return m.AddedWeight()
	case historytaking.FieldTemp:
		return m.AddedTemp()
	case historytaking.FieldPulse:
		return m.AddedPulse()
	case historytaking.FieldRespiration:
		return m.AddedRespiration()
	case historytaking.FieldBp:
		return m.AddedBp()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HistorytakingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case historytaking.FieldHight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHight(v)
		return nil
	case historytaking.FieldWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case historytaking.FieldTemp:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTemp(v)
		return nil
	case historytaking.FieldPulse:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPulse(v)
		return nil
	case historytaking.FieldRespiration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRespiration(v)
		return nil
	case historytaking.FieldBp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBp(v)
		return nil
	}
	return fmt.Errorf("unknown Historytaking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *HistorytakingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *HistorytakingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *HistorytakingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Historytaking nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *HistorytakingMutation) ResetField(name string) error {
	switch name {
	case historytaking.FieldHight:
		m.ResetHight()
		return nil
	case historytaking.FieldWeight:
		m.ResetWeight()
		return nil
	case historytaking.FieldTemp:
		m.ResetTemp()
		return nil
	case historytaking.FieldPulse:
		m.ResetPulse()
		return nil
	case historytaking.FieldRespiration:
		m.ResetRespiration()
		return nil
	case historytaking.FieldBp:
		m.ResetBp()
		return nil
	case historytaking.FieldOxygen:
		m.ResetOxygen()
		return nil
	case historytaking.FieldSymptom:
		m.ResetSymptom()
		return nil
	case historytaking.FieldDatetime:
		m.ResetDatetime()
		return nil
	}
	return fmt.Errorf("unknown Historytaking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *HistorytakingMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.nurse != nil {
		edges = append(edges, historytaking.EdgeNurse)
	}
	if m.department != nil {
		edges = append(edges, historytaking.EdgeDepartment)
	}
	if m.symptomseverity != nil {
		edges = append(edges, historytaking.EdgeSymptomseverity)
	}
	if m.patientrecord != nil {
		edges = append(edges, historytaking.EdgePatientrecord)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *HistorytakingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case historytaking.EdgeNurse:
		if id := m.nurse; id != nil {
			return []ent.Value{*id}
		}
	case historytaking.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case historytaking.EdgeSymptomseverity:
		if id := m.symptomseverity; id != nil {
			return []ent.Value{*id}
		}
	case historytaking.EdgePatientrecord:
		if id := m.patientrecord; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *HistorytakingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *HistorytakingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *HistorytakingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearednurse {
		edges = append(edges, historytaking.EdgeNurse)
	}
	if m.cleareddepartment {
		edges = append(edges, historytaking.EdgeDepartment)
	}
	if m.clearedsymptomseverity {
		edges = append(edges, historytaking.EdgeSymptomseverity)
	}
	if m.clearedpatientrecord {
		edges = append(edges, historytaking.EdgePatientrecord)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *HistorytakingMutation) EdgeCleared(name string) bool {
	switch name {
	case historytaking.EdgeNurse:
		return m.clearednurse
	case historytaking.EdgeDepartment:
		return m.cleareddepartment
	case historytaking.EdgeSymptomseverity:
		return m.clearedsymptomseverity
	case historytaking.EdgePatientrecord:
		return m.clearedpatientrecord
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *HistorytakingMutation) ClearEdge(name string) error {
	switch name {
	case historytaking.EdgeNurse:
		m.ClearNurse()
		return nil
	case historytaking.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case historytaking.EdgeSymptomseverity:
		m.ClearSymptomseverity()
		return nil
	case historytaking.EdgePatientrecord:
		m.ClearPatientrecord()
		return nil
	}
	return fmt.Errorf("unknown Historytaking unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *HistorytakingMutation) ResetEdge(name string) error {
	switch name {
	case historytaking.EdgeNurse:
		m.ResetNurse()
		return nil
	case historytaking.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case historytaking.EdgeSymptomseverity:
		m.ResetSymptomseverity()
		return nil
	case historytaking.EdgePatientrecord:
		m.ResetPatientrecord()
		return nil
	}
	return fmt.Errorf("unknown Historytaking edge %s", name)
}

// InsuranceMutation represents an operation that mutate the Insurances
// nodes in the graph.
type InsuranceMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	_Insurancecompany              *string
	clearedFields                  map[string]struct{}
	_InsurancePatientrights        map[int]struct{}
	removed_InsurancePatientrights map[int]struct{}
	done                           bool
	oldValue                       func(context.Context) (*Insurance, error)
}

var _ ent.Mutation = (*InsuranceMutation)(nil)

// insuranceOption allows to manage the mutation configuration using functional options.
type insuranceOption func(*InsuranceMutation)

// newInsuranceMutation creates new mutation for $n.Name.
func newInsuranceMutation(c config, op Op, opts ...insuranceOption) *InsuranceMutation {
	m := &InsuranceMutation{
		config:        c,
		op:            op,
		typ:           TypeInsurance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInsuranceID sets the id field of the mutation.
func withInsuranceID(id int) insuranceOption {
	return func(m *InsuranceMutation) {
		var (
			err   error
			once  sync.Once
			value *Insurance
		)
		m.oldValue = func(ctx context.Context) (*Insurance, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Insurance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInsurance sets the old Insurance of the mutation.
func withInsurance(node *Insurance) insuranceOption {
	return func(m *InsuranceMutation) {
		m.oldValue = func(context.Context) (*Insurance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InsuranceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InsuranceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InsuranceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetInsurancecompany sets the Insurancecompany field.
func (m *InsuranceMutation) SetInsurancecompany(s string) {
	m._Insurancecompany = &s
}

// Insurancecompany returns the Insurancecompany value in the mutation.
func (m *InsuranceMutation) Insurancecompany() (r string, exists bool) {
	v := m._Insurancecompany
	if v == nil {
		return
	}
	return *v, true
}

// OldInsurancecompany returns the old Insurancecompany value of the Insurance.
// If the Insurance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InsuranceMutation) OldInsurancecompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInsurancecompany is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInsurancecompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInsurancecompany: %w", err)
	}
	return oldValue.Insurancecompany, nil
}

// ResetInsurancecompany reset all changes of the "Insurancecompany" field.
func (m *InsuranceMutation) ResetInsurancecompany() {
	m._Insurancecompany = nil
}

// AddInsurancePatientrightIDs adds the InsurancePatientrights edge to Patientrights by ids.
func (m *InsuranceMutation) AddInsurancePatientrightIDs(ids ...int) {
	if m._InsurancePatientrights == nil {
		m._InsurancePatientrights = make(map[int]struct{})
	}
	for i := range ids {
		m._InsurancePatientrights[ids[i]] = struct{}{}
	}
}

// RemoveInsurancePatientrightIDs removes the InsurancePatientrights edge to Patientrights by ids.
func (m *InsuranceMutation) RemoveInsurancePatientrightIDs(ids ...int) {
	if m.removed_InsurancePatientrights == nil {
		m.removed_InsurancePatientrights = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_InsurancePatientrights[ids[i]] = struct{}{}
	}
}

// RemovedInsurancePatientrights returns the removed ids of InsurancePatientrights.
func (m *InsuranceMutation) RemovedInsurancePatientrightsIDs() (ids []int) {
	for id := range m.removed_InsurancePatientrights {
		ids = append(ids, id)
	}
	return
}

// InsurancePatientrightsIDs returns the InsurancePatientrights ids in the mutation.
func (m *InsuranceMutation) InsurancePatientrightsIDs() (ids []int) {
	for id := range m._InsurancePatientrights {
		ids = append(ids, id)
	}
	return
}

// ResetInsurancePatientrights reset all changes of the "InsurancePatientrights" edge.
func (m *InsuranceMutation) ResetInsurancePatientrights() {
	m._InsurancePatientrights = nil
	m.removed_InsurancePatientrights = nil
}

// Op returns the operation name.
func (m *InsuranceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Insurance).
func (m *InsuranceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InsuranceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Insurancecompany != nil {
		fields = append(fields, insurance.FieldInsurancecompany)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InsuranceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case insurance.FieldInsurancecompany:
		return m.Insurancecompany()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *InsuranceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case insurance.FieldInsurancecompany:
		return m.OldInsurancecompany(ctx)
	}
	return nil, fmt.Errorf("unknown Insurance field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InsuranceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case insurance.FieldInsurancecompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInsurancecompany(v)
		return nil
	}
	return fmt.Errorf("unknown Insurance field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InsuranceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InsuranceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InsuranceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Insurance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InsuranceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InsuranceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InsuranceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Insurance nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InsuranceMutation) ResetField(name string) error {
	switch name {
	case insurance.FieldInsurancecompany:
		m.ResetInsurancecompany()
		return nil
	}
	return fmt.Errorf("unknown Insurance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InsuranceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._InsurancePatientrights != nil {
		edges = append(edges, insurance.EdgeInsurancePatientrights)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InsuranceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case insurance.EdgeInsurancePatientrights:
		ids := make([]ent.Value, 0, len(m._InsurancePatientrights))
		for id := range m._InsurancePatientrights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InsuranceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_InsurancePatientrights != nil {
		edges = append(edges, insurance.EdgeInsurancePatientrights)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InsuranceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case insurance.EdgeInsurancePatientrights:
		ids := make([]ent.Value, 0, len(m.removed_InsurancePatientrights))
		for id := range m.removed_InsurancePatientrights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InsuranceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InsuranceMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InsuranceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Insurance unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InsuranceMutation) ResetEdge(name string) error {
	switch name {
	case insurance.EdgeInsurancePatientrights:
		m.ResetInsurancePatientrights()
		return nil
	}
	return fmt.Errorf("unknown Insurance edge %s", name)
}

// MedicalrecordstaffMutation represents an operation that mutate the Medicalrecordstaffs
// nodes in the graph.
type MedicalrecordstaffMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *int
	_Name                                   *string
	clearedFields                           map[string]struct{}
	patientrecord                           map[int]struct{}
	removedpatientrecord                    map[int]struct{}
	_MedicalrecordstaffPatientrights        map[int]struct{}
	removed_MedicalrecordstaffPatientrights map[int]struct{}
	user                                    *int
	cleareduser                             bool
	done                                    bool
	oldValue                                func(context.Context) (*Medicalrecordstaff, error)
}

var _ ent.Mutation = (*MedicalrecordstaffMutation)(nil)

// medicalrecordstaffOption allows to manage the mutation configuration using functional options.
type medicalrecordstaffOption func(*MedicalrecordstaffMutation)

// newMedicalrecordstaffMutation creates new mutation for $n.Name.
func newMedicalrecordstaffMutation(c config, op Op, opts ...medicalrecordstaffOption) *MedicalrecordstaffMutation {
	m := &MedicalrecordstaffMutation{
		config:        c,
		op:            op,
		typ:           TypeMedicalrecordstaff,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicalrecordstaffID sets the id field of the mutation.
func withMedicalrecordstaffID(id int) medicalrecordstaffOption {
	return func(m *MedicalrecordstaffMutation) {
		var (
			err   error
			once  sync.Once
			value *Medicalrecordstaff
		)
		m.oldValue = func(ctx context.Context) (*Medicalrecordstaff, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Medicalrecordstaff.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedicalrecordstaff sets the old Medicalrecordstaff of the mutation.
func withMedicalrecordstaff(node *Medicalrecordstaff) medicalrecordstaffOption {
	return func(m *MedicalrecordstaffMutation) {
		m.oldValue = func(context.Context) (*Medicalrecordstaff, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicalrecordstaffMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicalrecordstaffMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MedicalrecordstaffMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the Name field.
func (m *MedicalrecordstaffMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the Name value in the mutation.
func (m *MedicalrecordstaffMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old Name value of the Medicalrecordstaff.
// If the Medicalrecordstaff object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicalrecordstaffMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "Name" field.
func (m *MedicalrecordstaffMutation) ResetName() {
	m._Name = nil
}

// AddPatientrecordIDs adds the patientrecord edge to Patientrecord by ids.
func (m *MedicalrecordstaffMutation) AddPatientrecordIDs(ids ...int) {
	if m.patientrecord == nil {
		m.patientrecord = make(map[int]struct{})
	}
	for i := range ids {
		m.patientrecord[ids[i]] = struct{}{}
	}
}

// RemovePatientrecordIDs removes the patientrecord edge to Patientrecord by ids.
func (m *MedicalrecordstaffMutation) RemovePatientrecordIDs(ids ...int) {
	if m.removedpatientrecord == nil {
		m.removedpatientrecord = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpatientrecord[ids[i]] = struct{}{}
	}
}

// RemovedPatientrecord returns the removed ids of patientrecord.
func (m *MedicalrecordstaffMutation) RemovedPatientrecordIDs() (ids []int) {
	for id := range m.removedpatientrecord {
		ids = append(ids, id)
	}
	return
}

// PatientrecordIDs returns the patientrecord ids in the mutation.
func (m *MedicalrecordstaffMutation) PatientrecordIDs() (ids []int) {
	for id := range m.patientrecord {
		ids = append(ids, id)
	}
	return
}

// ResetPatientrecord reset all changes of the "patientrecord" edge.
func (m *MedicalrecordstaffMutation) ResetPatientrecord() {
	m.patientrecord = nil
	m.removedpatientrecord = nil
}

// AddMedicalrecordstaffPatientrightIDs adds the MedicalrecordstaffPatientrights edge to Patientrights by ids.
func (m *MedicalrecordstaffMutation) AddMedicalrecordstaffPatientrightIDs(ids ...int) {
	if m._MedicalrecordstaffPatientrights == nil {
		m._MedicalrecordstaffPatientrights = make(map[int]struct{})
	}
	for i := range ids {
		m._MedicalrecordstaffPatientrights[ids[i]] = struct{}{}
	}
}

// RemoveMedicalrecordstaffPatientrightIDs removes the MedicalrecordstaffPatientrights edge to Patientrights by ids.
func (m *MedicalrecordstaffMutation) RemoveMedicalrecordstaffPatientrightIDs(ids ...int) {
	if m.removed_MedicalrecordstaffPatientrights == nil {
		m.removed_MedicalrecordstaffPatientrights = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_MedicalrecordstaffPatientrights[ids[i]] = struct{}{}
	}
}

// RemovedMedicalrecordstaffPatientrights returns the removed ids of MedicalrecordstaffPatientrights.
func (m *MedicalrecordstaffMutation) RemovedMedicalrecordstaffPatientrightsIDs() (ids []int) {
	for id := range m.removed_MedicalrecordstaffPatientrights {
		ids = append(ids, id)
	}
	return
}

// MedicalrecordstaffPatientrightsIDs returns the MedicalrecordstaffPatientrights ids in the mutation.
func (m *MedicalrecordstaffMutation) MedicalrecordstaffPatientrightsIDs() (ids []int) {
	for id := range m._MedicalrecordstaffPatientrights {
		ids = append(ids, id)
	}
	return
}

// ResetMedicalrecordstaffPatientrights reset all changes of the "MedicalrecordstaffPatientrights" edge.
func (m *MedicalrecordstaffMutation) ResetMedicalrecordstaffPatientrights() {
	m._MedicalrecordstaffPatientrights = nil
	m.removed_MedicalrecordstaffPatientrights = nil
}

// SetUserID sets the user edge to User by id.
func (m *MedicalrecordstaffMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *MedicalrecordstaffMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *MedicalrecordstaffMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *MedicalrecordstaffMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MedicalrecordstaffMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *MedicalrecordstaffMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *MedicalrecordstaffMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Medicalrecordstaff).
func (m *MedicalrecordstaffMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MedicalrecordstaffMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Name != nil {
		fields = append(fields, medicalrecordstaff.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MedicalrecordstaffMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medicalrecordstaff.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MedicalrecordstaffMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medicalrecordstaff.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Medicalrecordstaff field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MedicalrecordstaffMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medicalrecordstaff.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Medicalrecordstaff field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MedicalrecordstaffMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MedicalrecordstaffMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MedicalrecordstaffMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Medicalrecordstaff numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MedicalrecordstaffMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MedicalrecordstaffMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicalrecordstaffMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Medicalrecordstaff nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MedicalrecordstaffMutation) ResetField(name string) error {
	switch name {
	case medicalrecordstaff.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Medicalrecordstaff field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MedicalrecordstaffMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.patientrecord != nil {
		edges = append(edges, medicalrecordstaff.EdgePatientrecord)
	}
	if m._MedicalrecordstaffPatientrights != nil {
		edges = append(edges, medicalrecordstaff.EdgeMedicalrecordstaffPatientrights)
	}
	if m.user != nil {
		edges = append(edges, medicalrecordstaff.EdgeUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MedicalrecordstaffMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case medicalrecordstaff.EdgePatientrecord:
		ids := make([]ent.Value, 0, len(m.patientrecord))
		for id := range m.patientrecord {
			ids = append(ids, id)
		}
		return ids
	case medicalrecordstaff.EdgeMedicalrecordstaffPatientrights:
		ids := make([]ent.Value, 0, len(m._MedicalrecordstaffPatientrights))
		for id := range m._MedicalrecordstaffPatientrights {
			ids = append(ids, id)
		}
		return ids
	case medicalrecordstaff.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MedicalrecordstaffMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpatientrecord != nil {
		edges = append(edges, medicalrecordstaff.EdgePatientrecord)
	}
	if m.removed_MedicalrecordstaffPatientrights != nil {
		edges = append(edges, medicalrecordstaff.EdgeMedicalrecordstaffPatientrights)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MedicalrecordstaffMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case medicalrecordstaff.EdgePatientrecord:
		ids := make([]ent.Value, 0, len(m.removedpatientrecord))
		for id := range m.removedpatientrecord {
			ids = append(ids, id)
		}
		return ids
	case medicalrecordstaff.EdgeMedicalrecordstaffPatientrights:
		ids := make([]ent.Value, 0, len(m.removed_MedicalrecordstaffPatientrights))
		for id := range m.removed_MedicalrecordstaffPatientrights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MedicalrecordstaffMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, medicalrecordstaff.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MedicalrecordstaffMutation) EdgeCleared(name string) bool {
	switch name {
	case medicalrecordstaff.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MedicalrecordstaffMutation) ClearEdge(name string) error {
	switch name {
	case medicalrecordstaff.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Medicalrecordstaff unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MedicalrecordstaffMutation) ResetEdge(name string) error {
	switch name {
	case medicalrecordstaff.EdgePatientrecord:
		m.ResetPatientrecord()
		return nil
	case medicalrecordstaff.EdgeMedicalrecordstaffPatientrights:
		m.ResetMedicalrecordstaffPatientrights()
		return nil
	case medicalrecordstaff.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Medicalrecordstaff edge %s", name)
}

// NurseMutation represents an operation that mutate the Nurses
// nodes in the graph.
type NurseMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	nursinglicense       *string
	position             *string
	clearedFields        map[string]struct{}
	historytaking        map[int]struct{}
	removedhistorytaking map[int]struct{}
	user                 *int
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*Nurse, error)
}

var _ ent.Mutation = (*NurseMutation)(nil)

// nurseOption allows to manage the mutation configuration using functional options.
type nurseOption func(*NurseMutation)

// newNurseMutation creates new mutation for $n.Name.
func newNurseMutation(c config, op Op, opts ...nurseOption) *NurseMutation {
	m := &NurseMutation{
		config:        c,
		op:            op,
		typ:           TypeNurse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNurseID sets the id field of the mutation.
func withNurseID(id int) nurseOption {
	return func(m *NurseMutation) {
		var (
			err   error
			once  sync.Once
			value *Nurse
		)
		m.oldValue = func(ctx context.Context) (*Nurse, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Nurse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNurse sets the old Nurse of the mutation.
func withNurse(node *Nurse) nurseOption {
	return func(m *NurseMutation) {
		m.oldValue = func(context.Context) (*Nurse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NurseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NurseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *NurseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *NurseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *NurseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *NurseMutation) ResetName() {
	m.name = nil
}

// SetNursinglicense sets the nursinglicense field.
func (m *NurseMutation) SetNursinglicense(s string) {
	m.nursinglicense = &s
}

// Nursinglicense returns the nursinglicense value in the mutation.
func (m *NurseMutation) Nursinglicense() (r string, exists bool) {
	v := m.nursinglicense
	if v == nil {
		return
	}
	return *v, true
}

// OldNursinglicense returns the old nursinglicense value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldNursinglicense(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNursinglicense is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNursinglicense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNursinglicense: %w", err)
	}
	return oldValue.Nursinglicense, nil
}

// ResetNursinglicense reset all changes of the "nursinglicense" field.
func (m *NurseMutation) ResetNursinglicense() {
	m.nursinglicense = nil
}

// SetPosition sets the position field.
func (m *NurseMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the position value in the mutation.
func (m *NurseMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old position value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPosition is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition reset all changes of the "position" field.
func (m *NurseMutation) ResetPosition() {
	m.position = nil
}

// AddHistorytakingIDs adds the historytaking edge to Historytaking by ids.
func (m *NurseMutation) AddHistorytakingIDs(ids ...int) {
	if m.historytaking == nil {
		m.historytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.historytaking[ids[i]] = struct{}{}
	}
}

// RemoveHistorytakingIDs removes the historytaking edge to Historytaking by ids.
func (m *NurseMutation) RemoveHistorytakingIDs(ids ...int) {
	if m.removedhistorytaking == nil {
		m.removedhistorytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhistorytaking[ids[i]] = struct{}{}
	}
}

// RemovedHistorytaking returns the removed ids of historytaking.
func (m *NurseMutation) RemovedHistorytakingIDs() (ids []int) {
	for id := range m.removedhistorytaking {
		ids = append(ids, id)
	}
	return
}

// HistorytakingIDs returns the historytaking ids in the mutation.
func (m *NurseMutation) HistorytakingIDs() (ids []int) {
	for id := range m.historytaking {
		ids = append(ids, id)
	}
	return
}

// ResetHistorytaking reset all changes of the "historytaking" edge.
func (m *NurseMutation) ResetHistorytaking() {
	m.historytaking = nil
	m.removedhistorytaking = nil
}

// SetUserID sets the user edge to User by id.
func (m *NurseMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *NurseMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *NurseMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *NurseMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *NurseMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *NurseMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *NurseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Nurse).
func (m *NurseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *NurseMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, nurse.FieldName)
	}
	if m.nursinglicense != nil {
		fields = append(fields, nurse.FieldNursinglicense)
	}
	if m.position != nil {
		fields = append(fields, nurse.FieldPosition)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *NurseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nurse.FieldName:
		return m.Name()
	case nurse.FieldNursinglicense:
		return m.Nursinglicense()
	case nurse.FieldPosition:
		return m.Position()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *NurseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nurse.FieldName:
		return m.OldName(ctx)
	case nurse.FieldNursinglicense:
		return m.OldNursinglicense(ctx)
	case nurse.FieldPosition:
		return m.OldPosition(ctx)
	}
	return nil, fmt.Errorf("unknown Nurse field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NurseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nurse.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case nurse.FieldNursinglicense:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNursinglicense(v)
		return nil
	case nurse.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	}
	return fmt.Errorf("unknown Nurse field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *NurseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *NurseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NurseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Nurse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *NurseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *NurseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *NurseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Nurse nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *NurseMutation) ResetField(name string) error {
	switch name {
	case nurse.FieldName:
		m.ResetName()
		return nil
	case nurse.FieldNursinglicense:
		m.ResetNursinglicense()
		return nil
	case nurse.FieldPosition:
		m.ResetPosition()
		return nil
	}
	return fmt.Errorf("unknown Nurse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *NurseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.historytaking != nil {
		edges = append(edges, nurse.EdgeHistorytaking)
	}
	if m.user != nil {
		edges = append(edges, nurse.EdgeUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *NurseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nurse.EdgeHistorytaking:
		ids := make([]ent.Value, 0, len(m.historytaking))
		for id := range m.historytaking {
			ids = append(ids, id)
		}
		return ids
	case nurse.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *NurseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedhistorytaking != nil {
		edges = append(edges, nurse.EdgeHistorytaking)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *NurseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nurse.EdgeHistorytaking:
		ids := make([]ent.Value, 0, len(m.removedhistorytaking))
		for id := range m.removedhistorytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *NurseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, nurse.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *NurseMutation) EdgeCleared(name string) bool {
	switch name {
	case nurse.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *NurseMutation) ClearEdge(name string) error {
	switch name {
	case nurse.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Nurse unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *NurseMutation) ResetEdge(name string) error {
	switch name {
	case nurse.EdgeHistorytaking:
		m.ResetHistorytaking()
		return nil
	case nurse.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Nurse edge %s", name)
}

// OfficeroomMutation represents an operation that mutate the Officerooms
// nodes in the graph.
type OfficeroomMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	roomnumber                   *int
	addroomnumber                *int
	clearedFields                map[string]struct{}
	officeroom2doctorinfo        map[int]struct{}
	removedofficeroom2doctorinfo map[int]struct{}
	done                         bool
	oldValue                     func(context.Context) (*Officeroom, error)
}

var _ ent.Mutation = (*OfficeroomMutation)(nil)

// officeroomOption allows to manage the mutation configuration using functional options.
type officeroomOption func(*OfficeroomMutation)

// newOfficeroomMutation creates new mutation for $n.Name.
func newOfficeroomMutation(c config, op Op, opts ...officeroomOption) *OfficeroomMutation {
	m := &OfficeroomMutation{
		config:        c,
		op:            op,
		typ:           TypeOfficeroom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOfficeroomID sets the id field of the mutation.
func withOfficeroomID(id int) officeroomOption {
	return func(m *OfficeroomMutation) {
		var (
			err   error
			once  sync.Once
			value *Officeroom
		)
		m.oldValue = func(ctx context.Context) (*Officeroom, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Officeroom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOfficeroom sets the old Officeroom of the mutation.
func withOfficeroom(node *Officeroom) officeroomOption {
	return func(m *OfficeroomMutation) {
		m.oldValue = func(context.Context) (*Officeroom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OfficeroomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OfficeroomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OfficeroomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRoomnumber sets the roomnumber field.
func (m *OfficeroomMutation) SetRoomnumber(i int) {
	m.roomnumber = &i
	m.addroomnumber = nil
}

// Roomnumber returns the roomnumber value in the mutation.
func (m *OfficeroomMutation) Roomnumber() (r int, exists bool) {
	v := m.roomnumber
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomnumber returns the old roomnumber value of the Officeroom.
// If the Officeroom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OfficeroomMutation) OldRoomnumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomnumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomnumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomnumber: %w", err)
	}
	return oldValue.Roomnumber, nil
}

// AddRoomnumber adds i to roomnumber.
func (m *OfficeroomMutation) AddRoomnumber(i int) {
	if m.addroomnumber != nil {
		*m.addroomnumber += i
	} else {
		m.addroomnumber = &i
	}
}

// AddedRoomnumber returns the value that was added to the roomnumber field in this mutation.
func (m *OfficeroomMutation) AddedRoomnumber() (r int, exists bool) {
	v := m.addroomnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoomnumber reset all changes of the "roomnumber" field.
func (m *OfficeroomMutation) ResetRoomnumber() {
	m.roomnumber = nil
	m.addroomnumber = nil
}

// AddOfficeroom2doctorinfoIDs adds the officeroom2doctorinfo edge to Doctorinfo by ids.
func (m *OfficeroomMutation) AddOfficeroom2doctorinfoIDs(ids ...int) {
	if m.officeroom2doctorinfo == nil {
		m.officeroom2doctorinfo = make(map[int]struct{})
	}
	for i := range ids {
		m.officeroom2doctorinfo[ids[i]] = struct{}{}
	}
}

// RemoveOfficeroom2doctorinfoIDs removes the officeroom2doctorinfo edge to Doctorinfo by ids.
func (m *OfficeroomMutation) RemoveOfficeroom2doctorinfoIDs(ids ...int) {
	if m.removedofficeroom2doctorinfo == nil {
		m.removedofficeroom2doctorinfo = make(map[int]struct{})
	}
	for i := range ids {
		m.removedofficeroom2doctorinfo[ids[i]] = struct{}{}
	}
}

// RemovedOfficeroom2doctorinfo returns the removed ids of officeroom2doctorinfo.
func (m *OfficeroomMutation) RemovedOfficeroom2doctorinfoIDs() (ids []int) {
	for id := range m.removedofficeroom2doctorinfo {
		ids = append(ids, id)
	}
	return
}

// Officeroom2doctorinfoIDs returns the officeroom2doctorinfo ids in the mutation.
func (m *OfficeroomMutation) Officeroom2doctorinfoIDs() (ids []int) {
	for id := range m.officeroom2doctorinfo {
		ids = append(ids, id)
	}
	return
}

// ResetOfficeroom2doctorinfo reset all changes of the "officeroom2doctorinfo" edge.
func (m *OfficeroomMutation) ResetOfficeroom2doctorinfo() {
	m.officeroom2doctorinfo = nil
	m.removedofficeroom2doctorinfo = nil
}

// Op returns the operation name.
func (m *OfficeroomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Officeroom).
func (m *OfficeroomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OfficeroomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.roomnumber != nil {
		fields = append(fields, officeroom.FieldRoomnumber)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OfficeroomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case officeroom.FieldRoomnumber:
		return m.Roomnumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OfficeroomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case officeroom.FieldRoomnumber:
		return m.OldRoomnumber(ctx)
	}
	return nil, fmt.Errorf("unknown Officeroom field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OfficeroomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case officeroom.FieldRoomnumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomnumber(v)
		return nil
	}
	return fmt.Errorf("unknown Officeroom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OfficeroomMutation) AddedFields() []string {
	var fields []string
	if m.addroomnumber != nil {
		fields = append(fields, officeroom.FieldRoomnumber)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OfficeroomMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case officeroom.FieldRoomnumber:
		return m.AddedRoomnumber()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OfficeroomMutation) AddField(name string, value ent.Value) error {
	switch name {
	case officeroom.FieldRoomnumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoomnumber(v)
		return nil
	}
	return fmt.Errorf("unknown Officeroom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OfficeroomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OfficeroomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OfficeroomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Officeroom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OfficeroomMutation) ResetField(name string) error {
	switch name {
	case officeroom.FieldRoomnumber:
		m.ResetRoomnumber()
		return nil
	}
	return fmt.Errorf("unknown Officeroom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OfficeroomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.officeroom2doctorinfo != nil {
		edges = append(edges, officeroom.EdgeOfficeroom2doctorinfo)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OfficeroomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case officeroom.EdgeOfficeroom2doctorinfo:
		ids := make([]ent.Value, 0, len(m.officeroom2doctorinfo))
		for id := range m.officeroom2doctorinfo {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OfficeroomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedofficeroom2doctorinfo != nil {
		edges = append(edges, officeroom.EdgeOfficeroom2doctorinfo)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OfficeroomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case officeroom.EdgeOfficeroom2doctorinfo:
		ids := make([]ent.Value, 0, len(m.removedofficeroom2doctorinfo))
		for id := range m.removedofficeroom2doctorinfo {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OfficeroomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OfficeroomMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OfficeroomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Officeroom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OfficeroomMutation) ResetEdge(name string) error {
	switch name {
	case officeroom.EdgeOfficeroom2doctorinfo:
		m.ResetOfficeroom2doctorinfo()
		return nil
	}
	return fmt.Errorf("unknown Officeroom edge %s", name)
}

// PatientrecordMutation represents an operation that mutate the Patientrecords
// nodes in the graph.
type PatientrecordMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	_Name                              *string
	_Idcardnumber                      *int
	add_Idcardnumber                   *int
	_Age                               *int
	add_Age                            *int
	_Birthday                          *time.Time
	_Bloodtype                         *string
	_Disease                           *string
	_Allergic                          *string
	_Phonenumber                       *int
	add_Phonenumber                    *int
	_Email                             *string
	_Home                              *string
	_Date                              *time.Time
	clearedFields                      map[string]struct{}
	gender                             *int
	clearedgender                      bool
	medicalrecordstaff                 *int
	clearedmedicalrecordstaff          bool
	prename                            *int
	clearedprename                     bool
	historytaking                      map[int]struct{}
	removedhistorytaking               map[int]struct{}
	treatment                          map[int]struct{}
	removedtreatment                   map[int]struct{}
	_PatientrecordPatientrights        map[int]struct{}
	removed_PatientrecordPatientrights map[int]struct{}
	done                               bool
	oldValue                           func(context.Context) (*Patientrecord, error)
}

var _ ent.Mutation = (*PatientrecordMutation)(nil)

// patientrecordOption allows to manage the mutation configuration using functional options.
type patientrecordOption func(*PatientrecordMutation)

// newPatientrecordMutation creates new mutation for $n.Name.
func newPatientrecordMutation(c config, op Op, opts ...patientrecordOption) *PatientrecordMutation {
	m := &PatientrecordMutation{
		config:        c,
		op:            op,
		typ:           TypePatientrecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientrecordID sets the id field of the mutation.
func withPatientrecordID(id int) patientrecordOption {
	return func(m *PatientrecordMutation) {
		var (
			err   error
			once  sync.Once
			value *Patientrecord
		)
		m.oldValue = func(ctx context.Context) (*Patientrecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patientrecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatientrecord sets the old Patientrecord of the mutation.
func withPatientrecord(node *Patientrecord) patientrecordOption {
	return func(m *PatientrecordMutation) {
		m.oldValue = func(context.Context) (*Patientrecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientrecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientrecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PatientrecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the Name field.
func (m *PatientrecordMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the Name value in the mutation.
func (m *PatientrecordMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old Name value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "Name" field.
func (m *PatientrecordMutation) ResetName() {
	m._Name = nil
}

// SetIdcardnumber sets the Idcardnumber field.
func (m *PatientrecordMutation) SetIdcardnumber(i int) {
	m._Idcardnumber = &i
	m.add_Idcardnumber = nil
}

// Idcardnumber returns the Idcardnumber value in the mutation.
func (m *PatientrecordMutation) Idcardnumber() (r int, exists bool) {
	v := m._Idcardnumber
	if v == nil {
		return
	}
	return *v, true
}

// OldIdcardnumber returns the old Idcardnumber value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldIdcardnumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIdcardnumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIdcardnumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdcardnumber: %w", err)
	}
	return oldValue.Idcardnumber, nil
}

// AddIdcardnumber adds i to Idcardnumber.
func (m *PatientrecordMutation) AddIdcardnumber(i int) {
	if m.add_Idcardnumber != nil {
		*m.add_Idcardnumber += i
	} else {
		m.add_Idcardnumber = &i
	}
}

// AddedIdcardnumber returns the value that was added to the Idcardnumber field in this mutation.
func (m *PatientrecordMutation) AddedIdcardnumber() (r int, exists bool) {
	v := m.add_Idcardnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetIdcardnumber reset all changes of the "Idcardnumber" field.
func (m *PatientrecordMutation) ResetIdcardnumber() {
	m._Idcardnumber = nil
	m.add_Idcardnumber = nil
}

// SetAge sets the Age field.
func (m *PatientrecordMutation) SetAge(i int) {
	m._Age = &i
	m.add_Age = nil
}

// Age returns the Age value in the mutation.
func (m *PatientrecordMutation) Age() (r int, exists bool) {
	v := m._Age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old Age value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAge is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to Age.
func (m *PatientrecordMutation) AddAge(i int) {
	if m.add_Age != nil {
		*m.add_Age += i
	} else {
		m.add_Age = &i
	}
}

// AddedAge returns the value that was added to the Age field in this mutation.
func (m *PatientrecordMutation) AddedAge() (r int, exists bool) {
	v := m.add_Age
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge reset all changes of the "Age" field.
func (m *PatientrecordMutation) ResetAge() {
	m._Age = nil
	m.add_Age = nil
}

// SetBirthday sets the Birthday field.
func (m *PatientrecordMutation) SetBirthday(t time.Time) {
	m._Birthday = &t
}

// Birthday returns the Birthday value in the mutation.
func (m *PatientrecordMutation) Birthday() (r time.Time, exists bool) {
	v := m._Birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old Birthday value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthday is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ResetBirthday reset all changes of the "Birthday" field.
func (m *PatientrecordMutation) ResetBirthday() {
	m._Birthday = nil
}

// SetBloodtype sets the Bloodtype field.
func (m *PatientrecordMutation) SetBloodtype(s string) {
	m._Bloodtype = &s
}

// Bloodtype returns the Bloodtype value in the mutation.
func (m *PatientrecordMutation) Bloodtype() (r string, exists bool) {
	v := m._Bloodtype
	if v == nil {
		return
	}
	return *v, true
}

// OldBloodtype returns the old Bloodtype value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldBloodtype(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBloodtype is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBloodtype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBloodtype: %w", err)
	}
	return oldValue.Bloodtype, nil
}

// ResetBloodtype reset all changes of the "Bloodtype" field.
func (m *PatientrecordMutation) ResetBloodtype() {
	m._Bloodtype = nil
}

// SetDisease sets the Disease field.
func (m *PatientrecordMutation) SetDisease(s string) {
	m._Disease = &s
}

// Disease returns the Disease value in the mutation.
func (m *PatientrecordMutation) Disease() (r string, exists bool) {
	v := m._Disease
	if v == nil {
		return
	}
	return *v, true
}

// OldDisease returns the old Disease value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldDisease(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisease is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisease requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisease: %w", err)
	}
	return oldValue.Disease, nil
}

// ResetDisease reset all changes of the "Disease" field.
func (m *PatientrecordMutation) ResetDisease() {
	m._Disease = nil
}

// SetAllergic sets the Allergic field.
func (m *PatientrecordMutation) SetAllergic(s string) {
	m._Allergic = &s
}

// Allergic returns the Allergic value in the mutation.
func (m *PatientrecordMutation) Allergic() (r string, exists bool) {
	v := m._Allergic
	if v == nil {
		return
	}
	return *v, true
}

// OldAllergic returns the old Allergic value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldAllergic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAllergic is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAllergic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllergic: %w", err)
	}
	return oldValue.Allergic, nil
}

// ResetAllergic reset all changes of the "Allergic" field.
func (m *PatientrecordMutation) ResetAllergic() {
	m._Allergic = nil
}

// SetPhonenumber sets the Phonenumber field.
func (m *PatientrecordMutation) SetPhonenumber(i int) {
	m._Phonenumber = &i
	m.add_Phonenumber = nil
}

// Phonenumber returns the Phonenumber value in the mutation.
func (m *PatientrecordMutation) Phonenumber() (r int, exists bool) {
	v := m._Phonenumber
	if v == nil {
		return
	}
	return *v, true
}

// OldPhonenumber returns the old Phonenumber value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldPhonenumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhonenumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhonenumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhonenumber: %w", err)
	}
	return oldValue.Phonenumber, nil
}

// AddPhonenumber adds i to Phonenumber.
func (m *PatientrecordMutation) AddPhonenumber(i int) {
	if m.add_Phonenumber != nil {
		*m.add_Phonenumber += i
	} else {
		m.add_Phonenumber = &i
	}
}

// AddedPhonenumber returns the value that was added to the Phonenumber field in this mutation.
func (m *PatientrecordMutation) AddedPhonenumber() (r int, exists bool) {
	v := m.add_Phonenumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetPhonenumber reset all changes of the "Phonenumber" field.
func (m *PatientrecordMutation) ResetPhonenumber() {
	m._Phonenumber = nil
	m.add_Phonenumber = nil
}

// SetEmail sets the Email field.
func (m *PatientrecordMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the Email value in the mutation.
func (m *PatientrecordMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old Email value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "Email" field.
func (m *PatientrecordMutation) ResetEmail() {
	m._Email = nil
}

// SetHome sets the Home field.
func (m *PatientrecordMutation) SetHome(s string) {
	m._Home = &s
}

// Home returns the Home value in the mutation.
func (m *PatientrecordMutation) Home() (r string, exists bool) {
	v := m._Home
	if v == nil {
		return
	}
	return *v, true
}

// OldHome returns the old Home value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldHome(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHome is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHome: %w", err)
	}
	return oldValue.Home, nil
}

// ResetHome reset all changes of the "Home" field.
func (m *PatientrecordMutation) ResetHome() {
	m._Home = nil
}

// SetDate sets the Date field.
func (m *PatientrecordMutation) SetDate(t time.Time) {
	m._Date = &t
}

// Date returns the Date value in the mutation.
func (m *PatientrecordMutation) Date() (r time.Time, exists bool) {
	v := m._Date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old Date value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate reset all changes of the "Date" field.
func (m *PatientrecordMutation) ResetDate() {
	m._Date = nil
}

// SetGenderID sets the gender edge to Gender by id.
func (m *PatientrecordMutation) SetGenderID(id int) {
	m.gender = &id
}

// ClearGender clears the gender edge to Gender.
func (m *PatientrecordMutation) ClearGender() {
	m.clearedgender = true
}

// GenderCleared returns if the edge gender was cleared.
func (m *PatientrecordMutation) GenderCleared() bool {
	return m.clearedgender
}

// GenderID returns the gender id in the mutation.
func (m *PatientrecordMutation) GenderID() (id int, exists bool) {
	if m.gender != nil {
		return *m.gender, true
	}
	return
}

// GenderIDs returns the gender ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// GenderID instead. It exists only for internal usage by the builders.
func (m *PatientrecordMutation) GenderIDs() (ids []int) {
	if id := m.gender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGender reset all changes of the "gender" edge.
func (m *PatientrecordMutation) ResetGender() {
	m.gender = nil
	m.clearedgender = false
}

// SetMedicalrecordstaffID sets the medicalrecordstaff edge to Medicalrecordstaff by id.
func (m *PatientrecordMutation) SetMedicalrecordstaffID(id int) {
	m.medicalrecordstaff = &id
}

// ClearMedicalrecordstaff clears the medicalrecordstaff edge to Medicalrecordstaff.
func (m *PatientrecordMutation) ClearMedicalrecordstaff() {
	m.clearedmedicalrecordstaff = true
}

// MedicalrecordstaffCleared returns if the edge medicalrecordstaff was cleared.
func (m *PatientrecordMutation) MedicalrecordstaffCleared() bool {
	return m.clearedmedicalrecordstaff
}

// MedicalrecordstaffID returns the medicalrecordstaff id in the mutation.
func (m *PatientrecordMutation) MedicalrecordstaffID() (id int, exists bool) {
	if m.medicalrecordstaff != nil {
		return *m.medicalrecordstaff, true
	}
	return
}

// MedicalrecordstaffIDs returns the medicalrecordstaff ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MedicalrecordstaffID instead. It exists only for internal usage by the builders.
func (m *PatientrecordMutation) MedicalrecordstaffIDs() (ids []int) {
	if id := m.medicalrecordstaff; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedicalrecordstaff reset all changes of the "medicalrecordstaff" edge.
func (m *PatientrecordMutation) ResetMedicalrecordstaff() {
	m.medicalrecordstaff = nil
	m.clearedmedicalrecordstaff = false
}

// SetPrenameID sets the prename edge to Prename by id.
func (m *PatientrecordMutation) SetPrenameID(id int) {
	m.prename = &id
}

// ClearPrename clears the prename edge to Prename.
func (m *PatientrecordMutation) ClearPrename() {
	m.clearedprename = true
}

// PrenameCleared returns if the edge prename was cleared.
func (m *PatientrecordMutation) PrenameCleared() bool {
	return m.clearedprename
}

// PrenameID returns the prename id in the mutation.
func (m *PatientrecordMutation) PrenameID() (id int, exists bool) {
	if m.prename != nil {
		return *m.prename, true
	}
	return
}

// PrenameIDs returns the prename ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PrenameID instead. It exists only for internal usage by the builders.
func (m *PatientrecordMutation) PrenameIDs() (ids []int) {
	if id := m.prename; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrename reset all changes of the "prename" edge.
func (m *PatientrecordMutation) ResetPrename() {
	m.prename = nil
	m.clearedprename = false
}

// AddHistorytakingIDs adds the historytaking edge to Historytaking by ids.
func (m *PatientrecordMutation) AddHistorytakingIDs(ids ...int) {
	if m.historytaking == nil {
		m.historytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.historytaking[ids[i]] = struct{}{}
	}
}

// RemoveHistorytakingIDs removes the historytaking edge to Historytaking by ids.
func (m *PatientrecordMutation) RemoveHistorytakingIDs(ids ...int) {
	if m.removedhistorytaking == nil {
		m.removedhistorytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhistorytaking[ids[i]] = struct{}{}
	}
}

// RemovedHistorytaking returns the removed ids of historytaking.
func (m *PatientrecordMutation) RemovedHistorytakingIDs() (ids []int) {
	for id := range m.removedhistorytaking {
		ids = append(ids, id)
	}
	return
}

// HistorytakingIDs returns the historytaking ids in the mutation.
func (m *PatientrecordMutation) HistorytakingIDs() (ids []int) {
	for id := range m.historytaking {
		ids = append(ids, id)
	}
	return
}

// ResetHistorytaking reset all changes of the "historytaking" edge.
func (m *PatientrecordMutation) ResetHistorytaking() {
	m.historytaking = nil
	m.removedhistorytaking = nil
}

// AddTreatmentIDs adds the treatment edge to Treatment by ids.
func (m *PatientrecordMutation) AddTreatmentIDs(ids ...int) {
	if m.treatment == nil {
		m.treatment = make(map[int]struct{})
	}
	for i := range ids {
		m.treatment[ids[i]] = struct{}{}
	}
}

// RemoveTreatmentIDs removes the treatment edge to Treatment by ids.
func (m *PatientrecordMutation) RemoveTreatmentIDs(ids ...int) {
	if m.removedtreatment == nil {
		m.removedtreatment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtreatment[ids[i]] = struct{}{}
	}
}

// RemovedTreatment returns the removed ids of treatment.
func (m *PatientrecordMutation) RemovedTreatmentIDs() (ids []int) {
	for id := range m.removedtreatment {
		ids = append(ids, id)
	}
	return
}

// TreatmentIDs returns the treatment ids in the mutation.
func (m *PatientrecordMutation) TreatmentIDs() (ids []int) {
	for id := range m.treatment {
		ids = append(ids, id)
	}
	return
}

// ResetTreatment reset all changes of the "treatment" edge.
func (m *PatientrecordMutation) ResetTreatment() {
	m.treatment = nil
	m.removedtreatment = nil
}

// AddPatientrecordPatientrightIDs adds the PatientrecordPatientrights edge to Patientrights by ids.
func (m *PatientrecordMutation) AddPatientrecordPatientrightIDs(ids ...int) {
	if m._PatientrecordPatientrights == nil {
		m._PatientrecordPatientrights = make(map[int]struct{})
	}
	for i := range ids {
		m._PatientrecordPatientrights[ids[i]] = struct{}{}
	}
}

// RemovePatientrecordPatientrightIDs removes the PatientrecordPatientrights edge to Patientrights by ids.
func (m *PatientrecordMutation) RemovePatientrecordPatientrightIDs(ids ...int) {
	if m.removed_PatientrecordPatientrights == nil {
		m.removed_PatientrecordPatientrights = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_PatientrecordPatientrights[ids[i]] = struct{}{}
	}
}

// RemovedPatientrecordPatientrights returns the removed ids of PatientrecordPatientrights.
func (m *PatientrecordMutation) RemovedPatientrecordPatientrightsIDs() (ids []int) {
	for id := range m.removed_PatientrecordPatientrights {
		ids = append(ids, id)
	}
	return
}

// PatientrecordPatientrightsIDs returns the PatientrecordPatientrights ids in the mutation.
func (m *PatientrecordMutation) PatientrecordPatientrightsIDs() (ids []int) {
	for id := range m._PatientrecordPatientrights {
		ids = append(ids, id)
	}
	return
}

// ResetPatientrecordPatientrights reset all changes of the "PatientrecordPatientrights" edge.
func (m *PatientrecordMutation) ResetPatientrecordPatientrights() {
	m._PatientrecordPatientrights = nil
	m.removed_PatientrecordPatientrights = nil
}

// Op returns the operation name.
func (m *PatientrecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Patientrecord).
func (m *PatientrecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PatientrecordMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m._Name != nil {
		fields = append(fields, patientrecord.FieldName)
	}
	if m._Idcardnumber != nil {
		fields = append(fields, patientrecord.FieldIdcardnumber)
	}
	if m._Age != nil {
		fields = append(fields, patientrecord.FieldAge)
	}
	if m._Birthday != nil {
		fields = append(fields, patientrecord.FieldBirthday)
	}
	if m._Bloodtype != nil {
		fields = append(fields, patientrecord.FieldBloodtype)
	}
	if m._Disease != nil {
		fields = append(fields, patientrecord.FieldDisease)
	}
	if m._Allergic != nil {
		fields = append(fields, patientrecord.FieldAllergic)
	}
	if m._Phonenumber != nil {
		fields = append(fields, patientrecord.FieldPhonenumber)
	}
	if m._Email != nil {
		fields = append(fields, patientrecord.FieldEmail)
	}
	if m._Home != nil {
		fields = append(fields, patientrecord.FieldHome)
	}
	if m._Date != nil {
		fields = append(fields, patientrecord.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PatientrecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patientrecord.FieldName:
		return m.Name()
	case patientrecord.FieldIdcardnumber:
		return m.Idcardnumber()
	case patientrecord.FieldAge:
		return m.Age()
	case patientrecord.FieldBirthday:
		return m.Birthday()
	case patientrecord.FieldBloodtype:
		return m.Bloodtype()
	case patientrecord.FieldDisease:
		return m.Disease()
	case patientrecord.FieldAllergic:
		return m.Allergic()
	case patientrecord.FieldPhonenumber:
		return m.Phonenumber()
	case patientrecord.FieldEmail:
		return m.Email()
	case patientrecord.FieldHome:
		return m.Home()
	case patientrecord.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PatientrecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patientrecord.FieldName:
		return m.OldName(ctx)
	case patientrecord.FieldIdcardnumber:
		return m.OldIdcardnumber(ctx)
	case patientrecord.FieldAge:
		return m.OldAge(ctx)
	case patientrecord.FieldBirthday:
		return m.OldBirthday(ctx)
	case patientrecord.FieldBloodtype:
		return m.OldBloodtype(ctx)
	case patientrecord.FieldDisease:
		return m.OldDisease(ctx)
	case patientrecord.FieldAllergic:
		return m.OldAllergic(ctx)
	case patientrecord.FieldPhonenumber:
		return m.OldPhonenumber(ctx)
	case patientrecord.FieldEmail:
		return m.OldEmail(ctx)
	case patientrecord.FieldHome:
		return m.OldHome(ctx)
	case patientrecord.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown Patientrecord field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientrecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patientrecord.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case patientrecord.FieldIdcardnumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdcardnumber(v)
		return nil
	case patientrecord.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case patientrecord.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case patientrecord.FieldBloodtype:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBloodtype(v)
		return nil
	case patientrecord.FieldDisease:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisease(v)
		return nil
	case patientrecord.FieldAllergic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllergic(v)
		return nil
	case patientrecord.FieldPhonenumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhonenumber(v)
		return nil
	case patientrecord.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case patientrecord.FieldHome:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHome(v)
		return nil
	case patientrecord.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown Patientrecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PatientrecordMutation) AddedFields() []string {
	var fields []string
	if m.add_Idcardnumber != nil {
		fields = append(fields, patientrecord.FieldIdcardnumber)
	}
	if m.add_Age != nil {
		fields = append(fields, patientrecord.FieldAge)
	}
	if m.add_Phonenumber != nil {
		fields = append(fields, patientrecord.FieldPhonenumber)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PatientrecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case patientrecord.FieldIdcardnumber:
		return m.AddedIdcardnumber()
	case patientrecord.FieldAge:
		return m.AddedAge()
	case patientrecord.FieldPhonenumber:
		return m.AddedPhonenumber()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientrecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case patientrecord.FieldIdcardnumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIdcardnumber(v)
		return nil
	case patientrecord.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case patientrecord.FieldPhonenumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPhonenumber(v)
		return nil
	}
	return fmt.Errorf("unknown Patientrecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PatientrecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PatientrecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientrecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Patientrecord nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PatientrecordMutation) ResetField(name string) error {
	switch name {
	case patientrecord.FieldName:
		m.ResetName()
		return nil
	case patientrecord.FieldIdcardnumber:
		m.ResetIdcardnumber()
		return nil
	case patientrecord.FieldAge:
		m.ResetAge()
		return nil
	case patientrecord.FieldBirthday:
		m.ResetBirthday()
		return nil
	case patientrecord.FieldBloodtype:
		m.ResetBloodtype()
		return nil
	case patientrecord.FieldDisease:
		m.ResetDisease()
		return nil
	case patientrecord.FieldAllergic:
		m.ResetAllergic()
		return nil
	case patientrecord.FieldPhonenumber:
		m.ResetPhonenumber()
		return nil
	case patientrecord.FieldEmail:
		m.ResetEmail()
		return nil
	case patientrecord.FieldHome:
		m.ResetHome()
		return nil
	case patientrecord.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown Patientrecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PatientrecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.gender != nil {
		edges = append(edges, patientrecord.EdgeGender)
	}
	if m.medicalrecordstaff != nil {
		edges = append(edges, patientrecord.EdgeMedicalrecordstaff)
	}
	if m.prename != nil {
		edges = append(edges, patientrecord.EdgePrename)
	}
	if m.historytaking != nil {
		edges = append(edges, patientrecord.EdgeHistorytaking)
	}
	if m.treatment != nil {
		edges = append(edges, patientrecord.EdgeTreatment)
	}
	if m._PatientrecordPatientrights != nil {
		edges = append(edges, patientrecord.EdgePatientrecordPatientrights)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PatientrecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patientrecord.EdgeGender:
		if id := m.gender; id != nil {
			return []ent.Value{*id}
		}
	case patientrecord.EdgeMedicalrecordstaff:
		if id := m.medicalrecordstaff; id != nil {
			return []ent.Value{*id}
		}
	case patientrecord.EdgePrename:
		if id := m.prename; id != nil {
			return []ent.Value{*id}
		}
	case patientrecord.EdgeHistorytaking:
		ids := make([]ent.Value, 0, len(m.historytaking))
		for id := range m.historytaking {
			ids = append(ids, id)
		}
		return ids
	case patientrecord.EdgeTreatment:
		ids := make([]ent.Value, 0, len(m.treatment))
		for id := range m.treatment {
			ids = append(ids, id)
		}
		return ids
	case patientrecord.EdgePatientrecordPatientrights:
		ids := make([]ent.Value, 0, len(m._PatientrecordPatientrights))
		for id := range m._PatientrecordPatientrights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PatientrecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedhistorytaking != nil {
		edges = append(edges, patientrecord.EdgeHistorytaking)
	}
	if m.removedtreatment != nil {
		edges = append(edges, patientrecord.EdgeTreatment)
	}
	if m.removed_PatientrecordPatientrights != nil {
		edges = append(edges, patientrecord.EdgePatientrecordPatientrights)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PatientrecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patientrecord.EdgeHistorytaking:
		ids := make([]ent.Value, 0, len(m.removedhistorytaking))
		for id := range m.removedhistorytaking {
			ids = append(ids, id)
		}
		return ids
	case patientrecord.EdgeTreatment:
		ids := make([]ent.Value, 0, len(m.removedtreatment))
		for id := range m.removedtreatment {
			ids = append(ids, id)
		}
		return ids
	case patientrecord.EdgePatientrecordPatientrights:
		ids := make([]ent.Value, 0, len(m.removed_PatientrecordPatientrights))
		for id := range m.removed_PatientrecordPatientrights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PatientrecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedgender {
		edges = append(edges, patientrecord.EdgeGender)
	}
	if m.clearedmedicalrecordstaff {
		edges = append(edges, patientrecord.EdgeMedicalrecordstaff)
	}
	if m.clearedprename {
		edges = append(edges, patientrecord.EdgePrename)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PatientrecordMutation) EdgeCleared(name string) bool {
	switch name {
	case patientrecord.EdgeGender:
		return m.clearedgender
	case patientrecord.EdgeMedicalrecordstaff:
		return m.clearedmedicalrecordstaff
	case patientrecord.EdgePrename:
		return m.clearedprename
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PatientrecordMutation) ClearEdge(name string) error {
	switch name {
	case patientrecord.EdgeGender:
		m.ClearGender()
		return nil
	case patientrecord.EdgeMedicalrecordstaff:
		m.ClearMedicalrecordstaff()
		return nil
	case patientrecord.EdgePrename:
		m.ClearPrename()
		return nil
	}
	return fmt.Errorf("unknown Patientrecord unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PatientrecordMutation) ResetEdge(name string) error {
	switch name {
	case patientrecord.EdgeGender:
		m.ResetGender()
		return nil
	case patientrecord.EdgeMedicalrecordstaff:
		m.ResetMedicalrecordstaff()
		return nil
	case patientrecord.EdgePrename:
		m.ResetPrename()
		return nil
	case patientrecord.EdgeHistorytaking:
		m.ResetHistorytaking()
		return nil
	case patientrecord.EdgeTreatment:
		m.ResetTreatment()
		return nil
	case patientrecord.EdgePatientrecordPatientrights:
		m.ResetPatientrecordPatientrights()
		return nil
	}
	return fmt.Errorf("unknown Patientrecord edge %s", name)
}

// PatientrightsMutation represents an operation that mutate the PatientrightsSlice
// nodes in the graph.
type PatientrightsMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *int
	_PermissionDate                         *time.Time
	clearedFields                           map[string]struct{}
	_PatientrightsPatientrightstype         *int
	cleared_PatientrightsPatientrightstype  bool
	_PatientrightsInsurance                 *int
	cleared_PatientrightsInsurance          bool
	_PatientrightsPatientrecord             *int
	cleared_PatientrightsPatientrecord      bool
	_PatientrightsMedicalrecordstaff        *int
	cleared_PatientrightsMedicalrecordstaff bool
	done                                    bool
	oldValue                                func(context.Context) (*Patientrights, error)
}

var _ ent.Mutation = (*PatientrightsMutation)(nil)

// patientrightsOption allows to manage the mutation configuration using functional options.
type patientrightsOption func(*PatientrightsMutation)

// newPatientrightsMutation creates new mutation for $n.Name.
func newPatientrightsMutation(c config, op Op, opts ...patientrightsOption) *PatientrightsMutation {
	m := &PatientrightsMutation{
		config:        c,
		op:            op,
		typ:           TypePatientrights,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientrightsID sets the id field of the mutation.
func withPatientrightsID(id int) patientrightsOption {
	return func(m *PatientrightsMutation) {
		var (
			err   error
			once  sync.Once
			value *Patientrights
		)
		m.oldValue = func(ctx context.Context) (*Patientrights, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patientrights.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatientrights sets the old Patientrights of the mutation.
func withPatientrights(node *Patientrights) patientrightsOption {
	return func(m *PatientrightsMutation) {
		m.oldValue = func(context.Context) (*Patientrights, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientrightsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientrightsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PatientrightsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPermissionDate sets the PermissionDate field.
func (m *PatientrightsMutation) SetPermissionDate(t time.Time) {
	m._PermissionDate = &t
}

// PermissionDate returns the PermissionDate value in the mutation.
func (m *PatientrightsMutation) PermissionDate() (r time.Time, exists bool) {
	v := m._PermissionDate
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionDate returns the old PermissionDate value of the Patientrights.
// If the Patientrights object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrightsMutation) OldPermissionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPermissionDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPermissionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionDate: %w", err)
	}
	return oldValue.PermissionDate, nil
}

// ResetPermissionDate reset all changes of the "PermissionDate" field.
func (m *PatientrightsMutation) ResetPermissionDate() {
	m._PermissionDate = nil
}

// SetPatientrightsPatientrightstypeID sets the PatientrightsPatientrightstype edge to Patientrightstype by id.
func (m *PatientrightsMutation) SetPatientrightsPatientrightstypeID(id int) {
	m._PatientrightsPatientrightstype = &id
}

// ClearPatientrightsPatientrightstype clears the PatientrightsPatientrightstype edge to Patientrightstype.
func (m *PatientrightsMutation) ClearPatientrightsPatientrightstype() {
	m.cleared_PatientrightsPatientrightstype = true
}

// PatientrightsPatientrightstypeCleared returns if the edge PatientrightsPatientrightstype was cleared.
func (m *PatientrightsMutation) PatientrightsPatientrightstypeCleared() bool {
	return m.cleared_PatientrightsPatientrightstype
}

// PatientrightsPatientrightstypeID returns the PatientrightsPatientrightstype id in the mutation.
func (m *PatientrightsMutation) PatientrightsPatientrightstypeID() (id int, exists bool) {
	if m._PatientrightsPatientrightstype != nil {
		return *m._PatientrightsPatientrightstype, true
	}
	return
}

// PatientrightsPatientrightstypeIDs returns the PatientrightsPatientrightstype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PatientrightsPatientrightstypeID instead. It exists only for internal usage by the builders.
func (m *PatientrightsMutation) PatientrightsPatientrightstypeIDs() (ids []int) {
	if id := m._PatientrightsPatientrightstype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatientrightsPatientrightstype reset all changes of the "PatientrightsPatientrightstype" edge.
func (m *PatientrightsMutation) ResetPatientrightsPatientrightstype() {
	m._PatientrightsPatientrightstype = nil
	m.cleared_PatientrightsPatientrightstype = false
}

// SetPatientrightsInsuranceID sets the PatientrightsInsurance edge to Insurance by id.
func (m *PatientrightsMutation) SetPatientrightsInsuranceID(id int) {
	m._PatientrightsInsurance = &id
}

// ClearPatientrightsInsurance clears the PatientrightsInsurance edge to Insurance.
func (m *PatientrightsMutation) ClearPatientrightsInsurance() {
	m.cleared_PatientrightsInsurance = true
}

// PatientrightsInsuranceCleared returns if the edge PatientrightsInsurance was cleared.
func (m *PatientrightsMutation) PatientrightsInsuranceCleared() bool {
	return m.cleared_PatientrightsInsurance
}

// PatientrightsInsuranceID returns the PatientrightsInsurance id in the mutation.
func (m *PatientrightsMutation) PatientrightsInsuranceID() (id int, exists bool) {
	if m._PatientrightsInsurance != nil {
		return *m._PatientrightsInsurance, true
	}
	return
}

// PatientrightsInsuranceIDs returns the PatientrightsInsurance ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PatientrightsInsuranceID instead. It exists only for internal usage by the builders.
func (m *PatientrightsMutation) PatientrightsInsuranceIDs() (ids []int) {
	if id := m._PatientrightsInsurance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatientrightsInsurance reset all changes of the "PatientrightsInsurance" edge.
func (m *PatientrightsMutation) ResetPatientrightsInsurance() {
	m._PatientrightsInsurance = nil
	m.cleared_PatientrightsInsurance = false
}

// SetPatientrightsPatientrecordID sets the PatientrightsPatientrecord edge to Patientrecord by id.
func (m *PatientrightsMutation) SetPatientrightsPatientrecordID(id int) {
	m._PatientrightsPatientrecord = &id
}

// ClearPatientrightsPatientrecord clears the PatientrightsPatientrecord edge to Patientrecord.
func (m *PatientrightsMutation) ClearPatientrightsPatientrecord() {
	m.cleared_PatientrightsPatientrecord = true
}

// PatientrightsPatientrecordCleared returns if the edge PatientrightsPatientrecord was cleared.
func (m *PatientrightsMutation) PatientrightsPatientrecordCleared() bool {
	return m.cleared_PatientrightsPatientrecord
}

// PatientrightsPatientrecordID returns the PatientrightsPatientrecord id in the mutation.
func (m *PatientrightsMutation) PatientrightsPatientrecordID() (id int, exists bool) {
	if m._PatientrightsPatientrecord != nil {
		return *m._PatientrightsPatientrecord, true
	}
	return
}

// PatientrightsPatientrecordIDs returns the PatientrightsPatientrecord ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PatientrightsPatientrecordID instead. It exists only for internal usage by the builders.
func (m *PatientrightsMutation) PatientrightsPatientrecordIDs() (ids []int) {
	if id := m._PatientrightsPatientrecord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatientrightsPatientrecord reset all changes of the "PatientrightsPatientrecord" edge.
func (m *PatientrightsMutation) ResetPatientrightsPatientrecord() {
	m._PatientrightsPatientrecord = nil
	m.cleared_PatientrightsPatientrecord = false
}

// SetPatientrightsMedicalrecordstaffID sets the PatientrightsMedicalrecordstaff edge to Medicalrecordstaff by id.
func (m *PatientrightsMutation) SetPatientrightsMedicalrecordstaffID(id int) {
	m._PatientrightsMedicalrecordstaff = &id
}

// ClearPatientrightsMedicalrecordstaff clears the PatientrightsMedicalrecordstaff edge to Medicalrecordstaff.
func (m *PatientrightsMutation) ClearPatientrightsMedicalrecordstaff() {
	m.cleared_PatientrightsMedicalrecordstaff = true
}

// PatientrightsMedicalrecordstaffCleared returns if the edge PatientrightsMedicalrecordstaff was cleared.
func (m *PatientrightsMutation) PatientrightsMedicalrecordstaffCleared() bool {
	return m.cleared_PatientrightsMedicalrecordstaff
}

// PatientrightsMedicalrecordstaffID returns the PatientrightsMedicalrecordstaff id in the mutation.
func (m *PatientrightsMutation) PatientrightsMedicalrecordstaffID() (id int, exists bool) {
	if m._PatientrightsMedicalrecordstaff != nil {
		return *m._PatientrightsMedicalrecordstaff, true
	}
	return
}

// PatientrightsMedicalrecordstaffIDs returns the PatientrightsMedicalrecordstaff ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PatientrightsMedicalrecordstaffID instead. It exists only for internal usage by the builders.
func (m *PatientrightsMutation) PatientrightsMedicalrecordstaffIDs() (ids []int) {
	if id := m._PatientrightsMedicalrecordstaff; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatientrightsMedicalrecordstaff reset all changes of the "PatientrightsMedicalrecordstaff" edge.
func (m *PatientrightsMutation) ResetPatientrightsMedicalrecordstaff() {
	m._PatientrightsMedicalrecordstaff = nil
	m.cleared_PatientrightsMedicalrecordstaff = false
}

// Op returns the operation name.
func (m *PatientrightsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Patientrights).
func (m *PatientrightsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PatientrightsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._PermissionDate != nil {
		fields = append(fields, patientrights.FieldPermissionDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PatientrightsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patientrights.FieldPermissionDate:
		return m.PermissionDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PatientrightsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patientrights.FieldPermissionDate:
		return m.OldPermissionDate(ctx)
	}
	return nil, fmt.Errorf("unknown Patientrights field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientrightsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patientrights.FieldPermissionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionDate(v)
		return nil
	}
	return fmt.Errorf("unknown Patientrights field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PatientrightsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PatientrightsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientrightsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Patientrights numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PatientrightsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PatientrightsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientrightsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Patientrights nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PatientrightsMutation) ResetField(name string) error {
	switch name {
	case patientrights.FieldPermissionDate:
		m.ResetPermissionDate()
		return nil
	}
	return fmt.Errorf("unknown Patientrights field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PatientrightsMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._PatientrightsPatientrightstype != nil {
		edges = append(edges, patientrights.EdgePatientrightsPatientrightstype)
	}
	if m._PatientrightsInsurance != nil {
		edges = append(edges, patientrights.EdgePatientrightsInsurance)
	}
	if m._PatientrightsPatientrecord != nil {
		edges = append(edges, patientrights.EdgePatientrightsPatientrecord)
	}
	if m._PatientrightsMedicalrecordstaff != nil {
		edges = append(edges, patientrights.EdgePatientrightsMedicalrecordstaff)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PatientrightsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patientrights.EdgePatientrightsPatientrightstype:
		if id := m._PatientrightsPatientrightstype; id != nil {
			return []ent.Value{*id}
		}
	case patientrights.EdgePatientrightsInsurance:
		if id := m._PatientrightsInsurance; id != nil {
			return []ent.Value{*id}
		}
	case patientrights.EdgePatientrightsPatientrecord:
		if id := m._PatientrightsPatientrecord; id != nil {
			return []ent.Value{*id}
		}
	case patientrights.EdgePatientrightsMedicalrecordstaff:
		if id := m._PatientrightsMedicalrecordstaff; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PatientrightsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PatientrightsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PatientrightsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_PatientrightsPatientrightstype {
		edges = append(edges, patientrights.EdgePatientrightsPatientrightstype)
	}
	if m.cleared_PatientrightsInsurance {
		edges = append(edges, patientrights.EdgePatientrightsInsurance)
	}
	if m.cleared_PatientrightsPatientrecord {
		edges = append(edges, patientrights.EdgePatientrightsPatientrecord)
	}
	if m.cleared_PatientrightsMedicalrecordstaff {
		edges = append(edges, patientrights.EdgePatientrightsMedicalrecordstaff)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PatientrightsMutation) EdgeCleared(name string) bool {
	switch name {
	case patientrights.EdgePatientrightsPatientrightstype:
		return m.cleared_PatientrightsPatientrightstype
	case patientrights.EdgePatientrightsInsurance:
		return m.cleared_PatientrightsInsurance
	case patientrights.EdgePatientrightsPatientrecord:
		return m.cleared_PatientrightsPatientrecord
	case patientrights.EdgePatientrightsMedicalrecordstaff:
		return m.cleared_PatientrightsMedicalrecordstaff
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PatientrightsMutation) ClearEdge(name string) error {
	switch name {
	case patientrights.EdgePatientrightsPatientrightstype:
		m.ClearPatientrightsPatientrightstype()
		return nil
	case patientrights.EdgePatientrightsInsurance:
		m.ClearPatientrightsInsurance()
		return nil
	case patientrights.EdgePatientrightsPatientrecord:
		m.ClearPatientrightsPatientrecord()
		return nil
	case patientrights.EdgePatientrightsMedicalrecordstaff:
		m.ClearPatientrightsMedicalrecordstaff()
		return nil
	}
	return fmt.Errorf("unknown Patientrights unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PatientrightsMutation) ResetEdge(name string) error {
	switch name {
	case patientrights.EdgePatientrightsPatientrightstype:
		m.ResetPatientrightsPatientrightstype()
		return nil
	case patientrights.EdgePatientrightsInsurance:
		m.ResetPatientrightsInsurance()
		return nil
	case patientrights.EdgePatientrightsPatientrecord:
		m.ResetPatientrightsPatientrecord()
		return nil
	case patientrights.EdgePatientrightsMedicalrecordstaff:
		m.ResetPatientrightsMedicalrecordstaff()
		return nil
	}
	return fmt.Errorf("unknown Patientrights edge %s", name)
}

// PatientrightstypeMutation represents an operation that mutate the Patientrightstypes
// nodes in the graph.
type PatientrightstypeMutation struct {
	config
	op                                            Op
	typ                                           string
	id                                            *int
	_Permission                                   *string
	_PermissionArea                               *string
	_Responsible                                  *string
	clearedFields                                 map[string]struct{}
	_PatientrightstypePatientrights               map[int]struct{}
	removed_PatientrightstypePatientrights        map[int]struct{}
	_PatientrightstypeAbilitypatientrights        *int
	cleared_PatientrightstypeAbilitypatientrights bool
	done                                          bool
	oldValue                                      func(context.Context) (*Patientrightstype, error)
}

var _ ent.Mutation = (*PatientrightstypeMutation)(nil)

// patientrightstypeOption allows to manage the mutation configuration using functional options.
type patientrightstypeOption func(*PatientrightstypeMutation)

// newPatientrightstypeMutation creates new mutation for $n.Name.
func newPatientrightstypeMutation(c config, op Op, opts ...patientrightstypeOption) *PatientrightstypeMutation {
	m := &PatientrightstypeMutation{
		config:        c,
		op:            op,
		typ:           TypePatientrightstype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientrightstypeID sets the id field of the mutation.
func withPatientrightstypeID(id int) patientrightstypeOption {
	return func(m *PatientrightstypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Patientrightstype
		)
		m.oldValue = func(ctx context.Context) (*Patientrightstype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patientrightstype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatientrightstype sets the old Patientrightstype of the mutation.
func withPatientrightstype(node *Patientrightstype) patientrightstypeOption {
	return func(m *PatientrightstypeMutation) {
		m.oldValue = func(context.Context) (*Patientrightstype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientrightstypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientrightstypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PatientrightstypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPermission sets the Permission field.
func (m *PatientrightstypeMutation) SetPermission(s string) {
	m._Permission = &s
}

// Permission returns the Permission value in the mutation.
func (m *PatientrightstypeMutation) Permission() (r string, exists bool) {
	v := m._Permission
	if v == nil {
		return
	}
	return *v, true
}

// OldPermission returns the old Permission value of the Patientrightstype.
// If the Patientrightstype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrightstypeMutation) OldPermission(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPermission is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPermission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermission: %w", err)
	}
	return oldValue.Permission, nil
}

// ResetPermission reset all changes of the "Permission" field.
func (m *PatientrightstypeMutation) ResetPermission() {
	m._Permission = nil
}

// SetPermissionArea sets the PermissionArea field.
func (m *PatientrightstypeMutation) SetPermissionArea(s string) {
	m._PermissionArea = &s
}

// PermissionArea returns the PermissionArea value in the mutation.
func (m *PatientrightstypeMutation) PermissionArea() (r string, exists bool) {
	v := m._PermissionArea
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionArea returns the old PermissionArea value of the Patientrightstype.
// If the Patientrightstype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrightstypeMutation) OldPermissionArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPermissionArea is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPermissionArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionArea: %w", err)
	}
	return oldValue.PermissionArea, nil
}

// ResetPermissionArea reset all changes of the "PermissionArea" field.
func (m *PatientrightstypeMutation) ResetPermissionArea() {
	m._PermissionArea = nil
}

// SetResponsible sets the Responsible field.
func (m *PatientrightstypeMutation) SetResponsible(s string) {
	m._Responsible = &s
}

// Responsible returns the Responsible value in the mutation.
func (m *PatientrightstypeMutation) Responsible() (r string, exists bool) {
	v := m._Responsible
	if v == nil {
		return
	}
	return *v, true
}

// OldResponsible returns the old Responsible value of the Patientrightstype.
// If the Patientrightstype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrightstypeMutation) OldResponsible(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResponsible is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResponsible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponsible: %w", err)
	}
	return oldValue.Responsible, nil
}

// ResetResponsible reset all changes of the "Responsible" field.
func (m *PatientrightstypeMutation) ResetResponsible() {
	m._Responsible = nil
}

// AddPatientrightstypePatientrightIDs adds the PatientrightstypePatientrights edge to Patientrights by ids.
func (m *PatientrightstypeMutation) AddPatientrightstypePatientrightIDs(ids ...int) {
	if m._PatientrightstypePatientrights == nil {
		m._PatientrightstypePatientrights = make(map[int]struct{})
	}
	for i := range ids {
		m._PatientrightstypePatientrights[ids[i]] = struct{}{}
	}
}

// RemovePatientrightstypePatientrightIDs removes the PatientrightstypePatientrights edge to Patientrights by ids.
func (m *PatientrightstypeMutation) RemovePatientrightstypePatientrightIDs(ids ...int) {
	if m.removed_PatientrightstypePatientrights == nil {
		m.removed_PatientrightstypePatientrights = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_PatientrightstypePatientrights[ids[i]] = struct{}{}
	}
}

// RemovedPatientrightstypePatientrights returns the removed ids of PatientrightstypePatientrights.
func (m *PatientrightstypeMutation) RemovedPatientrightstypePatientrightsIDs() (ids []int) {
	for id := range m.removed_PatientrightstypePatientrights {
		ids = append(ids, id)
	}
	return
}

// PatientrightstypePatientrightsIDs returns the PatientrightstypePatientrights ids in the mutation.
func (m *PatientrightstypeMutation) PatientrightstypePatientrightsIDs() (ids []int) {
	for id := range m._PatientrightstypePatientrights {
		ids = append(ids, id)
	}
	return
}

// ResetPatientrightstypePatientrights reset all changes of the "PatientrightstypePatientrights" edge.
func (m *PatientrightstypeMutation) ResetPatientrightstypePatientrights() {
	m._PatientrightstypePatientrights = nil
	m.removed_PatientrightstypePatientrights = nil
}

// SetPatientrightstypeAbilitypatientrightsID sets the PatientrightstypeAbilitypatientrights edge to Abilitypatientrights by id.
func (m *PatientrightstypeMutation) SetPatientrightstypeAbilitypatientrightsID(id int) {
	m._PatientrightstypeAbilitypatientrights = &id
}

// ClearPatientrightstypeAbilitypatientrights clears the PatientrightstypeAbilitypatientrights edge to Abilitypatientrights.
func (m *PatientrightstypeMutation) ClearPatientrightstypeAbilitypatientrights() {
	m.cleared_PatientrightstypeAbilitypatientrights = true
}

// PatientrightstypeAbilitypatientrightsCleared returns if the edge PatientrightstypeAbilitypatientrights was cleared.
func (m *PatientrightstypeMutation) PatientrightstypeAbilitypatientrightsCleared() bool {
	return m.cleared_PatientrightstypeAbilitypatientrights
}

// PatientrightstypeAbilitypatientrightsID returns the PatientrightstypeAbilitypatientrights id in the mutation.
func (m *PatientrightstypeMutation) PatientrightstypeAbilitypatientrightsID() (id int, exists bool) {
	if m._PatientrightstypeAbilitypatientrights != nil {
		return *m._PatientrightstypeAbilitypatientrights, true
	}
	return
}

// PatientrightstypeAbilitypatientrightsIDs returns the PatientrightstypeAbilitypatientrights ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PatientrightstypeAbilitypatientrightsID instead. It exists only for internal usage by the builders.
func (m *PatientrightstypeMutation) PatientrightstypeAbilitypatientrightsIDs() (ids []int) {
	if id := m._PatientrightstypeAbilitypatientrights; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatientrightstypeAbilitypatientrights reset all changes of the "PatientrightstypeAbilitypatientrights" edge.
func (m *PatientrightstypeMutation) ResetPatientrightstypeAbilitypatientrights() {
	m._PatientrightstypeAbilitypatientrights = nil
	m.cleared_PatientrightstypeAbilitypatientrights = false
}

// Op returns the operation name.
func (m *PatientrightstypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Patientrightstype).
func (m *PatientrightstypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PatientrightstypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._Permission != nil {
		fields = append(fields, patientrightstype.FieldPermission)
	}
	if m._PermissionArea != nil {
		fields = append(fields, patientrightstype.FieldPermissionArea)
	}
	if m._Responsible != nil {
		fields = append(fields, patientrightstype.FieldResponsible)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PatientrightstypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patientrightstype.FieldPermission:
		return m.Permission()
	case patientrightstype.FieldPermissionArea:
		return m.PermissionArea()
	case patientrightstype.FieldResponsible:
		return m.Responsible()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PatientrightstypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patientrightstype.FieldPermission:
		return m.OldPermission(ctx)
	case patientrightstype.FieldPermissionArea:
		return m.OldPermissionArea(ctx)
	case patientrightstype.FieldResponsible:
		return m.OldResponsible(ctx)
	}
	return nil, fmt.Errorf("unknown Patientrightstype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientrightstypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patientrightstype.FieldPermission:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermission(v)
		return nil
	case patientrightstype.FieldPermissionArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionArea(v)
		return nil
	case patientrightstype.FieldResponsible:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponsible(v)
		return nil
	}
	return fmt.Errorf("unknown Patientrightstype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PatientrightstypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PatientrightstypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientrightstypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Patientrightstype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PatientrightstypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PatientrightstypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientrightstypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Patientrightstype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PatientrightstypeMutation) ResetField(name string) error {
	switch name {
	case patientrightstype.FieldPermission:
		m.ResetPermission()
		return nil
	case patientrightstype.FieldPermissionArea:
		m.ResetPermissionArea()
		return nil
	case patientrightstype.FieldResponsible:
		m.ResetResponsible()
		return nil
	}
	return fmt.Errorf("unknown Patientrightstype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PatientrightstypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._PatientrightstypePatientrights != nil {
		edges = append(edges, patientrightstype.EdgePatientrightstypePatientrights)
	}
	if m._PatientrightstypeAbilitypatientrights != nil {
		edges = append(edges, patientrightstype.EdgePatientrightstypeAbilitypatientrights)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PatientrightstypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patientrightstype.EdgePatientrightstypePatientrights:
		ids := make([]ent.Value, 0, len(m._PatientrightstypePatientrights))
		for id := range m._PatientrightstypePatientrights {
			ids = append(ids, id)
		}
		return ids
	case patientrightstype.EdgePatientrightstypeAbilitypatientrights:
		if id := m._PatientrightstypeAbilitypatientrights; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PatientrightstypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_PatientrightstypePatientrights != nil {
		edges = append(edges, patientrightstype.EdgePatientrightstypePatientrights)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PatientrightstypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patientrightstype.EdgePatientrightstypePatientrights:
		ids := make([]ent.Value, 0, len(m.removed_PatientrightstypePatientrights))
		for id := range m.removed_PatientrightstypePatientrights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PatientrightstypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_PatientrightstypeAbilitypatientrights {
		edges = append(edges, patientrightstype.EdgePatientrightstypeAbilitypatientrights)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PatientrightstypeMutation) EdgeCleared(name string) bool {
	switch name {
	case patientrightstype.EdgePatientrightstypeAbilitypatientrights:
		return m.cleared_PatientrightstypeAbilitypatientrights
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PatientrightstypeMutation) ClearEdge(name string) error {
	switch name {
	case patientrightstype.EdgePatientrightstypeAbilitypatientrights:
		m.ClearPatientrightstypeAbilitypatientrights()
		return nil
	}
	return fmt.Errorf("unknown Patientrightstype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PatientrightstypeMutation) ResetEdge(name string) error {
	switch name {
	case patientrightstype.EdgePatientrightstypePatientrights:
		m.ResetPatientrightstypePatientrights()
		return nil
	case patientrightstype.EdgePatientrightstypeAbilitypatientrights:
		m.ResetPatientrightstypeAbilitypatientrights()
		return nil
	}
	return fmt.Errorf("unknown Patientrightstype edge %s", name)
}

// PaytypeMutation represents an operation that mutate the Paytypes
// nodes in the graph.
type PaytypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	paytype       *string
	clearedFields map[string]struct{}
	bills         map[int]struct{}
	removedbills  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Paytype, error)
}

var _ ent.Mutation = (*PaytypeMutation)(nil)

// paytypeOption allows to manage the mutation configuration using functional options.
type paytypeOption func(*PaytypeMutation)

// newPaytypeMutation creates new mutation for $n.Name.
func newPaytypeMutation(c config, op Op, opts ...paytypeOption) *PaytypeMutation {
	m := &PaytypeMutation{
		config:        c,
		op:            op,
		typ:           TypePaytype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaytypeID sets the id field of the mutation.
func withPaytypeID(id int) paytypeOption {
	return func(m *PaytypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Paytype
		)
		m.oldValue = func(ctx context.Context) (*Paytype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Paytype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaytype sets the old Paytype of the mutation.
func withPaytype(node *Paytype) paytypeOption {
	return func(m *PaytypeMutation) {
		m.oldValue = func(context.Context) (*Paytype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaytypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaytypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PaytypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPaytype sets the paytype field.
func (m *PaytypeMutation) SetPaytype(s string) {
	m.paytype = &s
}

// Paytype returns the paytype value in the mutation.
func (m *PaytypeMutation) Paytype() (r string, exists bool) {
	v := m.paytype
	if v == nil {
		return
	}
	return *v, true
}

// OldPaytype returns the old paytype value of the Paytype.
// If the Paytype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PaytypeMutation) OldPaytype(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaytype is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaytype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaytype: %w", err)
	}
	return oldValue.Paytype, nil
}

// ResetPaytype reset all changes of the "paytype" field.
func (m *PaytypeMutation) ResetPaytype() {
	m.paytype = nil
}

// AddBillIDs adds the bills edge to Bill by ids.
func (m *PaytypeMutation) AddBillIDs(ids ...int) {
	if m.bills == nil {
		m.bills = make(map[int]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// RemoveBillIDs removes the bills edge to Bill by ids.
func (m *PaytypeMutation) RemoveBillIDs(ids ...int) {
	if m.removedbills == nil {
		m.removedbills = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed ids of bills.
func (m *PaytypeMutation) RemovedBillsIDs() (ids []int) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the bills ids in the mutation.
func (m *PaytypeMutation) BillsIDs() (ids []int) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills reset all changes of the "bills" edge.
func (m *PaytypeMutation) ResetBills() {
	m.bills = nil
	m.removedbills = nil
}

// Op returns the operation name.
func (m *PaytypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Paytype).
func (m *PaytypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PaytypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.paytype != nil {
		fields = append(fields, paytype.FieldPaytype)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PaytypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paytype.FieldPaytype:
		return m.Paytype()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PaytypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paytype.FieldPaytype:
		return m.OldPaytype(ctx)
	}
	return nil, fmt.Errorf("unknown Paytype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaytypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paytype.FieldPaytype:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaytype(v)
		return nil
	}
	return fmt.Errorf("unknown Paytype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PaytypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PaytypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaytypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Paytype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PaytypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PaytypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaytypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Paytype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PaytypeMutation) ResetField(name string) error {
	switch name {
	case paytype.FieldPaytype:
		m.ResetPaytype()
		return nil
	}
	return fmt.Errorf("unknown Paytype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PaytypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bills != nil {
		edges = append(edges, paytype.EdgeBills)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PaytypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paytype.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PaytypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbills != nil {
		edges = append(edges, paytype.EdgeBills)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PaytypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case paytype.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PaytypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PaytypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PaytypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Paytype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PaytypeMutation) ResetEdge(name string) error {
	switch name {
	case paytype.EdgeBills:
		m.ResetBills()
		return nil
	}
	return fmt.Errorf("unknown Paytype edge %s", name)
}

// PrenameMutation represents an operation that mutate the Prenames
// nodes in the graph.
type PrenameMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	prefix                    *string
	clearedFields             map[string]struct{}
	prename2doctorinfo        map[int]struct{}
	removedprename2doctorinfo map[int]struct{}
	patientrecord             map[int]struct{}
	removedpatientrecord      map[int]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Prename, error)
}

var _ ent.Mutation = (*PrenameMutation)(nil)

// prenameOption allows to manage the mutation configuration using functional options.
type prenameOption func(*PrenameMutation)

// newPrenameMutation creates new mutation for $n.Name.
func newPrenameMutation(c config, op Op, opts ...prenameOption) *PrenameMutation {
	m := &PrenameMutation{
		config:        c,
		op:            op,
		typ:           TypePrename,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrenameID sets the id field of the mutation.
func withPrenameID(id int) prenameOption {
	return func(m *PrenameMutation) {
		var (
			err   error
			once  sync.Once
			value *Prename
		)
		m.oldValue = func(ctx context.Context) (*Prename, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prename.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrename sets the old Prename of the mutation.
func withPrename(node *Prename) prenameOption {
	return func(m *PrenameMutation) {
		m.oldValue = func(context.Context) (*Prename, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrenameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrenameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PrenameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPrefix sets the prefix field.
func (m *PrenameMutation) SetPrefix(s string) {
	m.prefix = &s
}

// Prefix returns the prefix value in the mutation.
func (m *PrenameMutation) Prefix() (r string, exists bool) {
	v := m.prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefix returns the old prefix value of the Prename.
// If the Prename object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PrenameMutation) OldPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrefix is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefix: %w", err)
	}
	return oldValue.Prefix, nil
}

// ResetPrefix reset all changes of the "prefix" field.
func (m *PrenameMutation) ResetPrefix() {
	m.prefix = nil
}

// AddPrename2doctorinfoIDs adds the prename2doctorinfo edge to Doctorinfo by ids.
func (m *PrenameMutation) AddPrename2doctorinfoIDs(ids ...int) {
	if m.prename2doctorinfo == nil {
		m.prename2doctorinfo = make(map[int]struct{})
	}
	for i := range ids {
		m.prename2doctorinfo[ids[i]] = struct{}{}
	}
}

// RemovePrename2doctorinfoIDs removes the prename2doctorinfo edge to Doctorinfo by ids.
func (m *PrenameMutation) RemovePrename2doctorinfoIDs(ids ...int) {
	if m.removedprename2doctorinfo == nil {
		m.removedprename2doctorinfo = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprename2doctorinfo[ids[i]] = struct{}{}
	}
}

// RemovedPrename2doctorinfo returns the removed ids of prename2doctorinfo.
func (m *PrenameMutation) RemovedPrename2doctorinfoIDs() (ids []int) {
	for id := range m.removedprename2doctorinfo {
		ids = append(ids, id)
	}
	return
}

// Prename2doctorinfoIDs returns the prename2doctorinfo ids in the mutation.
func (m *PrenameMutation) Prename2doctorinfoIDs() (ids []int) {
	for id := range m.prename2doctorinfo {
		ids = append(ids, id)
	}
	return
}

// ResetPrename2doctorinfo reset all changes of the "prename2doctorinfo" edge.
func (m *PrenameMutation) ResetPrename2doctorinfo() {
	m.prename2doctorinfo = nil
	m.removedprename2doctorinfo = nil
}

// AddPatientrecordIDs adds the patientrecord edge to Patientrecord by ids.
func (m *PrenameMutation) AddPatientrecordIDs(ids ...int) {
	if m.patientrecord == nil {
		m.patientrecord = make(map[int]struct{})
	}
	for i := range ids {
		m.patientrecord[ids[i]] = struct{}{}
	}
}

// RemovePatientrecordIDs removes the patientrecord edge to Patientrecord by ids.
func (m *PrenameMutation) RemovePatientrecordIDs(ids ...int) {
	if m.removedpatientrecord == nil {
		m.removedpatientrecord = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpatientrecord[ids[i]] = struct{}{}
	}
}

// RemovedPatientrecord returns the removed ids of patientrecord.
func (m *PrenameMutation) RemovedPatientrecordIDs() (ids []int) {
	for id := range m.removedpatientrecord {
		ids = append(ids, id)
	}
	return
}

// PatientrecordIDs returns the patientrecord ids in the mutation.
func (m *PrenameMutation) PatientrecordIDs() (ids []int) {
	for id := range m.patientrecord {
		ids = append(ids, id)
	}
	return
}

// ResetPatientrecord reset all changes of the "patientrecord" edge.
func (m *PrenameMutation) ResetPatientrecord() {
	m.patientrecord = nil
	m.removedpatientrecord = nil
}

// Op returns the operation name.
func (m *PrenameMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Prename).
func (m *PrenameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PrenameMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.prefix != nil {
		fields = append(fields, prename.FieldPrefix)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PrenameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prename.FieldPrefix:
		return m.Prefix()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PrenameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prename.FieldPrefix:
		return m.OldPrefix(ctx)
	}
	return nil, fmt.Errorf("unknown Prename field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PrenameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prename.FieldPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefix(v)
		return nil
	}
	return fmt.Errorf("unknown Prename field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PrenameMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PrenameMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PrenameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Prename numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PrenameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PrenameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrenameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Prename nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PrenameMutation) ResetField(name string) error {
	switch name {
	case prename.FieldPrefix:
		m.ResetPrefix()
		return nil
	}
	return fmt.Errorf("unknown Prename field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PrenameMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.prename2doctorinfo != nil {
		edges = append(edges, prename.EdgePrename2doctorinfo)
	}
	if m.patientrecord != nil {
		edges = append(edges, prename.EdgePatientrecord)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PrenameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prename.EdgePrename2doctorinfo:
		ids := make([]ent.Value, 0, len(m.prename2doctorinfo))
		for id := range m.prename2doctorinfo {
			ids = append(ids, id)
		}
		return ids
	case prename.EdgePatientrecord:
		ids := make([]ent.Value, 0, len(m.patientrecord))
		for id := range m.patientrecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PrenameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprename2doctorinfo != nil {
		edges = append(edges, prename.EdgePrename2doctorinfo)
	}
	if m.removedpatientrecord != nil {
		edges = append(edges, prename.EdgePatientrecord)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PrenameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prename.EdgePrename2doctorinfo:
		ids := make([]ent.Value, 0, len(m.removedprename2doctorinfo))
		for id := range m.removedprename2doctorinfo {
			ids = append(ids, id)
		}
		return ids
	case prename.EdgePatientrecord:
		ids := make([]ent.Value, 0, len(m.removedpatientrecord))
		for id := range m.removedpatientrecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PrenameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PrenameMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PrenameMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Prename unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PrenameMutation) ResetEdge(name string) error {
	switch name {
	case prename.EdgePrename2doctorinfo:
		m.ResetPrename2doctorinfo()
		return nil
	case prename.EdgePatientrecord:
		m.ResetPatientrecord()
		return nil
	}
	return fmt.Errorf("unknown Prename edge %s", name)
}

// SymptomseverityMutation represents an operation that mutate the Symptomseverities
// nodes in the graph.
type SymptomseverityMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	symptomseverity      *string
	clearedFields        map[string]struct{}
	historytaking        map[int]struct{}
	removedhistorytaking map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Symptomseverity, error)
}

var _ ent.Mutation = (*SymptomseverityMutation)(nil)

// symptomseverityOption allows to manage the mutation configuration using functional options.
type symptomseverityOption func(*SymptomseverityMutation)

// newSymptomseverityMutation creates new mutation for $n.Name.
func newSymptomseverityMutation(c config, op Op, opts ...symptomseverityOption) *SymptomseverityMutation {
	m := &SymptomseverityMutation{
		config:        c,
		op:            op,
		typ:           TypeSymptomseverity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSymptomseverityID sets the id field of the mutation.
func withSymptomseverityID(id int) symptomseverityOption {
	return func(m *SymptomseverityMutation) {
		var (
			err   error
			once  sync.Once
			value *Symptomseverity
		)
		m.oldValue = func(ctx context.Context) (*Symptomseverity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Symptomseverity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSymptomseverity sets the old Symptomseverity of the mutation.
func withSymptomseverity(node *Symptomseverity) symptomseverityOption {
	return func(m *SymptomseverityMutation) {
		m.oldValue = func(context.Context) (*Symptomseverity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SymptomseverityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SymptomseverityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SymptomseverityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSymptomseverity sets the symptomseverity field.
func (m *SymptomseverityMutation) SetSymptomseverity(s string) {
	m.symptomseverity = &s
}

// Symptomseverity returns the symptomseverity value in the mutation.
func (m *SymptomseverityMutation) Symptomseverity() (r string, exists bool) {
	v := m.symptomseverity
	if v == nil {
		return
	}
	return *v, true
}

// OldSymptomseverity returns the old symptomseverity value of the Symptomseverity.
// If the Symptomseverity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SymptomseverityMutation) OldSymptomseverity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSymptomseverity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSymptomseverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymptomseverity: %w", err)
	}
	return oldValue.Symptomseverity, nil
}

// ResetSymptomseverity reset all changes of the "symptomseverity" field.
func (m *SymptomseverityMutation) ResetSymptomseverity() {
	m.symptomseverity = nil
}

// AddHistorytakingIDs adds the historytaking edge to Historytaking by ids.
func (m *SymptomseverityMutation) AddHistorytakingIDs(ids ...int) {
	if m.historytaking == nil {
		m.historytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.historytaking[ids[i]] = struct{}{}
	}
}

// RemoveHistorytakingIDs removes the historytaking edge to Historytaking by ids.
func (m *SymptomseverityMutation) RemoveHistorytakingIDs(ids ...int) {
	if m.removedhistorytaking == nil {
		m.removedhistorytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhistorytaking[ids[i]] = struct{}{}
	}
}

// RemovedHistorytaking returns the removed ids of historytaking.
func (m *SymptomseverityMutation) RemovedHistorytakingIDs() (ids []int) {
	for id := range m.removedhistorytaking {
		ids = append(ids, id)
	}
	return
}

// HistorytakingIDs returns the historytaking ids in the mutation.
func (m *SymptomseverityMutation) HistorytakingIDs() (ids []int) {
	for id := range m.historytaking {
		ids = append(ids, id)
	}
	return
}

// ResetHistorytaking reset all changes of the "historytaking" edge.
func (m *SymptomseverityMutation) ResetHistorytaking() {
	m.historytaking = nil
	m.removedhistorytaking = nil
}

// Op returns the operation name.
func (m *SymptomseverityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Symptomseverity).
func (m *SymptomseverityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SymptomseverityMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.symptomseverity != nil {
		fields = append(fields, symptomseverity.FieldSymptomseverity)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SymptomseverityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case symptomseverity.FieldSymptomseverity:
		return m.Symptomseverity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SymptomseverityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case symptomseverity.FieldSymptomseverity:
		return m.OldSymptomseverity(ctx)
	}
	return nil, fmt.Errorf("unknown Symptomseverity field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SymptomseverityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case symptomseverity.FieldSymptomseverity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymptomseverity(v)
		return nil
	}
	return fmt.Errorf("unknown Symptomseverity field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SymptomseverityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SymptomseverityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SymptomseverityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Symptomseverity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SymptomseverityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SymptomseverityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SymptomseverityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Symptomseverity nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SymptomseverityMutation) ResetField(name string) error {
	switch name {
	case symptomseverity.FieldSymptomseverity:
		m.ResetSymptomseverity()
		return nil
	}
	return fmt.Errorf("unknown Symptomseverity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SymptomseverityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.historytaking != nil {
		edges = append(edges, symptomseverity.EdgeHistorytaking)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SymptomseverityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case symptomseverity.EdgeHistorytaking:
		ids := make([]ent.Value, 0, len(m.historytaking))
		for id := range m.historytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SymptomseverityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedhistorytaking != nil {
		edges = append(edges, symptomseverity.EdgeHistorytaking)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SymptomseverityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case symptomseverity.EdgeHistorytaking:
		ids := make([]ent.Value, 0, len(m.removedhistorytaking))
		for id := range m.removedhistorytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SymptomseverityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SymptomseverityMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SymptomseverityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Symptomseverity unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SymptomseverityMutation) ResetEdge(name string) error {
	switch name {
	case symptomseverity.EdgeHistorytaking:
		m.ResetHistorytaking()
		return nil
	}
	return fmt.Errorf("unknown Symptomseverity edge %s", name)
}

// TreatmentMutation represents an operation that mutate the Treatments
// nodes in the graph.
type TreatmentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	treatment            *string
	datetime             *time.Time
	clearedFields        map[string]struct{}
	typetreatment        *int
	clearedtypetreatment bool
	patientrecord        *int
	clearedpatientrecord bool
	doctorinfo           *int
	cleareddoctorinfo    bool
	unpaybills           *int
	clearedunpaybills    bool
	done                 bool
	oldValue             func(context.Context) (*Treatment, error)
}

var _ ent.Mutation = (*TreatmentMutation)(nil)

// treatmentOption allows to manage the mutation configuration using functional options.
type treatmentOption func(*TreatmentMutation)

// newTreatmentMutation creates new mutation for $n.Name.
func newTreatmentMutation(c config, op Op, opts ...treatmentOption) *TreatmentMutation {
	m := &TreatmentMutation{
		config:        c,
		op:            op,
		typ:           TypeTreatment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreatmentID sets the id field of the mutation.
func withTreatmentID(id int) treatmentOption {
	return func(m *TreatmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Treatment
		)
		m.oldValue = func(ctx context.Context) (*Treatment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Treatment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreatment sets the old Treatment of the mutation.
func withTreatment(node *Treatment) treatmentOption {
	return func(m *TreatmentMutation) {
		m.oldValue = func(context.Context) (*Treatment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreatmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreatmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TreatmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTreatment sets the treatment field.
func (m *TreatmentMutation) SetTreatment(s string) {
	m.treatment = &s
}

// Treatment returns the treatment value in the mutation.
func (m *TreatmentMutation) Treatment() (r string, exists bool) {
	v := m.treatment
	if v == nil {
		return
	}
	return *v, true
}

// OldTreatment returns the old treatment value of the Treatment.
// If the Treatment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TreatmentMutation) OldTreatment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTreatment is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTreatment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTreatment: %w", err)
	}
	return oldValue.Treatment, nil
}

// ResetTreatment reset all changes of the "treatment" field.
func (m *TreatmentMutation) ResetTreatment() {
	m.treatment = nil
}

// SetDatetime sets the datetime field.
func (m *TreatmentMutation) SetDatetime(t time.Time) {
	m.datetime = &t
}

// Datetime returns the datetime value in the mutation.
func (m *TreatmentMutation) Datetime() (r time.Time, exists bool) {
	v := m.datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetime returns the old datetime value of the Treatment.
// If the Treatment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TreatmentMutation) OldDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDatetime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetime: %w", err)
	}
	return oldValue.Datetime, nil
}

// ResetDatetime reset all changes of the "datetime" field.
func (m *TreatmentMutation) ResetDatetime() {
	m.datetime = nil
}

// SetTypetreatmentID sets the typetreatment edge to Typetreatment by id.
func (m *TreatmentMutation) SetTypetreatmentID(id int) {
	m.typetreatment = &id
}

// ClearTypetreatment clears the typetreatment edge to Typetreatment.
func (m *TreatmentMutation) ClearTypetreatment() {
	m.clearedtypetreatment = true
}

// TypetreatmentCleared returns if the edge typetreatment was cleared.
func (m *TreatmentMutation) TypetreatmentCleared() bool {
	return m.clearedtypetreatment
}

// TypetreatmentID returns the typetreatment id in the mutation.
func (m *TreatmentMutation) TypetreatmentID() (id int, exists bool) {
	if m.typetreatment != nil {
		return *m.typetreatment, true
	}
	return
}

// TypetreatmentIDs returns the typetreatment ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TypetreatmentID instead. It exists only for internal usage by the builders.
func (m *TreatmentMutation) TypetreatmentIDs() (ids []int) {
	if id := m.typetreatment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTypetreatment reset all changes of the "typetreatment" edge.
func (m *TreatmentMutation) ResetTypetreatment() {
	m.typetreatment = nil
	m.clearedtypetreatment = false
}

// SetPatientrecordID sets the patientrecord edge to Patientrecord by id.
func (m *TreatmentMutation) SetPatientrecordID(id int) {
	m.patientrecord = &id
}

// ClearPatientrecord clears the patientrecord edge to Patientrecord.
func (m *TreatmentMutation) ClearPatientrecord() {
	m.clearedpatientrecord = true
}

// PatientrecordCleared returns if the edge patientrecord was cleared.
func (m *TreatmentMutation) PatientrecordCleared() bool {
	return m.clearedpatientrecord
}

// PatientrecordID returns the patientrecord id in the mutation.
func (m *TreatmentMutation) PatientrecordID() (id int, exists bool) {
	if m.patientrecord != nil {
		return *m.patientrecord, true
	}
	return
}

// PatientrecordIDs returns the patientrecord ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PatientrecordID instead. It exists only for internal usage by the builders.
func (m *TreatmentMutation) PatientrecordIDs() (ids []int) {
	if id := m.patientrecord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatientrecord reset all changes of the "patientrecord" edge.
func (m *TreatmentMutation) ResetPatientrecord() {
	m.patientrecord = nil
	m.clearedpatientrecord = false
}

// SetDoctorinfoID sets the doctorinfo edge to Doctorinfo by id.
func (m *TreatmentMutation) SetDoctorinfoID(id int) {
	m.doctorinfo = &id
}

// ClearDoctorinfo clears the doctorinfo edge to Doctorinfo.
func (m *TreatmentMutation) ClearDoctorinfo() {
	m.cleareddoctorinfo = true
}

// DoctorinfoCleared returns if the edge doctorinfo was cleared.
func (m *TreatmentMutation) DoctorinfoCleared() bool {
	return m.cleareddoctorinfo
}

// DoctorinfoID returns the doctorinfo id in the mutation.
func (m *TreatmentMutation) DoctorinfoID() (id int, exists bool) {
	if m.doctorinfo != nil {
		return *m.doctorinfo, true
	}
	return
}

// DoctorinfoIDs returns the doctorinfo ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DoctorinfoID instead. It exists only for internal usage by the builders.
func (m *TreatmentMutation) DoctorinfoIDs() (ids []int) {
	if id := m.doctorinfo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctorinfo reset all changes of the "doctorinfo" edge.
func (m *TreatmentMutation) ResetDoctorinfo() {
	m.doctorinfo = nil
	m.cleareddoctorinfo = false
}

// SetUnpaybillsID sets the unpaybills edge to Unpaybill by id.
func (m *TreatmentMutation) SetUnpaybillsID(id int) {
	m.unpaybills = &id
}

// ClearUnpaybills clears the unpaybills edge to Unpaybill.
func (m *TreatmentMutation) ClearUnpaybills() {
	m.clearedunpaybills = true
}

// UnpaybillsCleared returns if the edge unpaybills was cleared.
func (m *TreatmentMutation) UnpaybillsCleared() bool {
	return m.clearedunpaybills
}

// UnpaybillsID returns the unpaybills id in the mutation.
func (m *TreatmentMutation) UnpaybillsID() (id int, exists bool) {
	if m.unpaybills != nil {
		return *m.unpaybills, true
	}
	return
}

// UnpaybillsIDs returns the unpaybills ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UnpaybillsID instead. It exists only for internal usage by the builders.
func (m *TreatmentMutation) UnpaybillsIDs() (ids []int) {
	if id := m.unpaybills; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUnpaybills reset all changes of the "unpaybills" edge.
func (m *TreatmentMutation) ResetUnpaybills() {
	m.unpaybills = nil
	m.clearedunpaybills = false
}

// Op returns the operation name.
func (m *TreatmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Treatment).
func (m *TreatmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TreatmentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.treatment != nil {
		fields = append(fields, treatment.FieldTreatment)
	}
	if m.datetime != nil {
		fields = append(fields, treatment.FieldDatetime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TreatmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treatment.FieldTreatment:
		return m.Treatment()
	case treatment.FieldDatetime:
		return m.Datetime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TreatmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treatment.FieldTreatment:
		return m.OldTreatment(ctx)
	case treatment.FieldDatetime:
		return m.OldDatetime(ctx)
	}
	return nil, fmt.Errorf("unknown Treatment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TreatmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treatment.FieldTreatment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTreatment(v)
		return nil
	case treatment.FieldDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetime(v)
		return nil
	}
	return fmt.Errorf("unknown Treatment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TreatmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TreatmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TreatmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Treatment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TreatmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TreatmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreatmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Treatment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TreatmentMutation) ResetField(name string) error {
	switch name {
	case treatment.FieldTreatment:
		m.ResetTreatment()
		return nil
	case treatment.FieldDatetime:
		m.ResetDatetime()
		return nil
	}
	return fmt.Errorf("unknown Treatment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TreatmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.typetreatment != nil {
		edges = append(edges, treatment.EdgeTypetreatment)
	}
	if m.patientrecord != nil {
		edges = append(edges, treatment.EdgePatientrecord)
	}
	if m.doctorinfo != nil {
		edges = append(edges, treatment.EdgeDoctorinfo)
	}
	if m.unpaybills != nil {
		edges = append(edges, treatment.EdgeUnpaybills)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TreatmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case treatment.EdgeTypetreatment:
		if id := m.typetreatment; id != nil {
			return []ent.Value{*id}
		}
	case treatment.EdgePatientrecord:
		if id := m.patientrecord; id != nil {
			return []ent.Value{*id}
		}
	case treatment.EdgeDoctorinfo:
		if id := m.doctorinfo; id != nil {
			return []ent.Value{*id}
		}
	case treatment.EdgeUnpaybills:
		if id := m.unpaybills; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TreatmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TreatmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TreatmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtypetreatment {
		edges = append(edges, treatment.EdgeTypetreatment)
	}
	if m.clearedpatientrecord {
		edges = append(edges, treatment.EdgePatientrecord)
	}
	if m.cleareddoctorinfo {
		edges = append(edges, treatment.EdgeDoctorinfo)
	}
	if m.clearedunpaybills {
		edges = append(edges, treatment.EdgeUnpaybills)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TreatmentMutation) EdgeCleared(name string) bool {
	switch name {
	case treatment.EdgeTypetreatment:
		return m.clearedtypetreatment
	case treatment.EdgePatientrecord:
		return m.clearedpatientrecord
	case treatment.EdgeDoctorinfo:
		return m.cleareddoctorinfo
	case treatment.EdgeUnpaybills:
		return m.clearedunpaybills
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TreatmentMutation) ClearEdge(name string) error {
	switch name {
	case treatment.EdgeTypetreatment:
		m.ClearTypetreatment()
		return nil
	case treatment.EdgePatientrecord:
		m.ClearPatientrecord()
		return nil
	case treatment.EdgeDoctorinfo:
		m.ClearDoctorinfo()
		return nil
	case treatment.EdgeUnpaybills:
		m.ClearUnpaybills()
		return nil
	}
	return fmt.Errorf("unknown Treatment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TreatmentMutation) ResetEdge(name string) error {
	switch name {
	case treatment.EdgeTypetreatment:
		m.ResetTypetreatment()
		return nil
	case treatment.EdgePatientrecord:
		m.ResetPatientrecord()
		return nil
	case treatment.EdgeDoctorinfo:
		m.ResetDoctorinfo()
		return nil
	case treatment.EdgeUnpaybills:
		m.ResetUnpaybills()
		return nil
	}
	return fmt.Errorf("unknown Treatment edge %s", name)
}

// TypetreatmentMutation represents an operation that mutate the Typetreatments
// nodes in the graph.
type TypetreatmentMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_type            *string
	clearedFields    map[string]struct{}
	treatment        map[int]struct{}
	removedtreatment map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Typetreatment, error)
}

var _ ent.Mutation = (*TypetreatmentMutation)(nil)

// typetreatmentOption allows to manage the mutation configuration using functional options.
type typetreatmentOption func(*TypetreatmentMutation)

// newTypetreatmentMutation creates new mutation for $n.Name.
func newTypetreatmentMutation(c config, op Op, opts ...typetreatmentOption) *TypetreatmentMutation {
	m := &TypetreatmentMutation{
		config:        c,
		op:            op,
		typ:           TypeTypetreatment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTypetreatmentID sets the id field of the mutation.
func withTypetreatmentID(id int) typetreatmentOption {
	return func(m *TypetreatmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Typetreatment
		)
		m.oldValue = func(ctx context.Context) (*Typetreatment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Typetreatment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTypetreatment sets the old Typetreatment of the mutation.
func withTypetreatment(node *Typetreatment) typetreatmentOption {
	return func(m *TypetreatmentMutation) {
		m.oldValue = func(context.Context) (*Typetreatment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TypetreatmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TypetreatmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TypetreatmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the type field.
func (m *TypetreatmentMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *TypetreatmentMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the Typetreatment.
// If the Typetreatment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TypetreatmentMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *TypetreatmentMutation) ResetType() {
	m._type = nil
}

// AddTreatmentIDs adds the treatment edge to Treatment by ids.
func (m *TypetreatmentMutation) AddTreatmentIDs(ids ...int) {
	if m.treatment == nil {
		m.treatment = make(map[int]struct{})
	}
	for i := range ids {
		m.treatment[ids[i]] = struct{}{}
	}
}

// RemoveTreatmentIDs removes the treatment edge to Treatment by ids.
func (m *TypetreatmentMutation) RemoveTreatmentIDs(ids ...int) {
	if m.removedtreatment == nil {
		m.removedtreatment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtreatment[ids[i]] = struct{}{}
	}
}

// RemovedTreatment returns the removed ids of treatment.
func (m *TypetreatmentMutation) RemovedTreatmentIDs() (ids []int) {
	for id := range m.removedtreatment {
		ids = append(ids, id)
	}
	return
}

// TreatmentIDs returns the treatment ids in the mutation.
func (m *TypetreatmentMutation) TreatmentIDs() (ids []int) {
	for id := range m.treatment {
		ids = append(ids, id)
	}
	return
}

// ResetTreatment reset all changes of the "treatment" edge.
func (m *TypetreatmentMutation) ResetTreatment() {
	m.treatment = nil
	m.removedtreatment = nil
}

// Op returns the operation name.
func (m *TypetreatmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Typetreatment).
func (m *TypetreatmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TypetreatmentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._type != nil {
		fields = append(fields, typetreatment.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TypetreatmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case typetreatment.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TypetreatmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case typetreatment.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Typetreatment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TypetreatmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case typetreatment.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Typetreatment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TypetreatmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TypetreatmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TypetreatmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Typetreatment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TypetreatmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TypetreatmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TypetreatmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Typetreatment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TypetreatmentMutation) ResetField(name string) error {
	switch name {
	case typetreatment.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Typetreatment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TypetreatmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.treatment != nil {
		edges = append(edges, typetreatment.EdgeTreatment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TypetreatmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case typetreatment.EdgeTreatment:
		ids := make([]ent.Value, 0, len(m.treatment))
		for id := range m.treatment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TypetreatmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtreatment != nil {
		edges = append(edges, typetreatment.EdgeTreatment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TypetreatmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case typetreatment.EdgeTreatment:
		ids := make([]ent.Value, 0, len(m.removedtreatment))
		for id := range m.removedtreatment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TypetreatmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TypetreatmentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TypetreatmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Typetreatment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TypetreatmentMutation) ResetEdge(name string) error {
	switch name {
	case typetreatment.EdgeTreatment:
		m.ResetTreatment()
		return nil
	}
	return fmt.Errorf("unknown Typetreatment edge %s", name)
}

// UnpaybillMutation represents an operation that mutate the Unpaybills
// nodes in the graph.
type UnpaybillMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_Status          *string
	clearedFields    map[string]struct{}
	treatment        *int
	clearedtreatment bool
	bills            *int
	clearedbills     bool
	done             bool
	oldValue         func(context.Context) (*Unpaybill, error)
}

var _ ent.Mutation = (*UnpaybillMutation)(nil)

// unpaybillOption allows to manage the mutation configuration using functional options.
type unpaybillOption func(*UnpaybillMutation)

// newUnpaybillMutation creates new mutation for $n.Name.
func newUnpaybillMutation(c config, op Op, opts ...unpaybillOption) *UnpaybillMutation {
	m := &UnpaybillMutation{
		config:        c,
		op:            op,
		typ:           TypeUnpaybill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUnpaybillID sets the id field of the mutation.
func withUnpaybillID(id int) unpaybillOption {
	return func(m *UnpaybillMutation) {
		var (
			err   error
			once  sync.Once
			value *Unpaybill
		)
		m.oldValue = func(ctx context.Context) (*Unpaybill, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Unpaybill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUnpaybill sets the old Unpaybill of the mutation.
func withUnpaybill(node *Unpaybill) unpaybillOption {
	return func(m *UnpaybillMutation) {
		m.oldValue = func(context.Context) (*Unpaybill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UnpaybillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UnpaybillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UnpaybillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatus sets the Status field.
func (m *UnpaybillMutation) SetStatus(s string) {
	m._Status = &s
}

// Status returns the Status value in the mutation.
func (m *UnpaybillMutation) Status() (r string, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old Status value of the Unpaybill.
// If the Unpaybill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UnpaybillMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "Status" field.
func (m *UnpaybillMutation) ResetStatus() {
	m._Status = nil
}

// SetTreatmentID sets the treatment edge to Treatment by id.
func (m *UnpaybillMutation) SetTreatmentID(id int) {
	m.treatment = &id
}

// ClearTreatment clears the treatment edge to Treatment.
func (m *UnpaybillMutation) ClearTreatment() {
	m.clearedtreatment = true
}

// TreatmentCleared returns if the edge treatment was cleared.
func (m *UnpaybillMutation) TreatmentCleared() bool {
	return m.clearedtreatment
}

// TreatmentID returns the treatment id in the mutation.
func (m *UnpaybillMutation) TreatmentID() (id int, exists bool) {
	if m.treatment != nil {
		return *m.treatment, true
	}
	return
}

// TreatmentIDs returns the treatment ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TreatmentID instead. It exists only for internal usage by the builders.
func (m *UnpaybillMutation) TreatmentIDs() (ids []int) {
	if id := m.treatment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTreatment reset all changes of the "treatment" edge.
func (m *UnpaybillMutation) ResetTreatment() {
	m.treatment = nil
	m.clearedtreatment = false
}

// SetBillsID sets the bills edge to Bill by id.
func (m *UnpaybillMutation) SetBillsID(id int) {
	m.bills = &id
}

// ClearBills clears the bills edge to Bill.
func (m *UnpaybillMutation) ClearBills() {
	m.clearedbills = true
}

// BillsCleared returns if the edge bills was cleared.
func (m *UnpaybillMutation) BillsCleared() bool {
	return m.clearedbills
}

// BillsID returns the bills id in the mutation.
func (m *UnpaybillMutation) BillsID() (id int, exists bool) {
	if m.bills != nil {
		return *m.bills, true
	}
	return
}

// BillsIDs returns the bills ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BillsID instead. It exists only for internal usage by the builders.
func (m *UnpaybillMutation) BillsIDs() (ids []int) {
	if id := m.bills; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBills reset all changes of the "bills" edge.
func (m *UnpaybillMutation) ResetBills() {
	m.bills = nil
	m.clearedbills = false
}

// Op returns the operation name.
func (m *UnpaybillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Unpaybill).
func (m *UnpaybillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UnpaybillMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Status != nil {
		fields = append(fields, unpaybill.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UnpaybillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case unpaybill.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UnpaybillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case unpaybill.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Unpaybill field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UnpaybillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case unpaybill.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Unpaybill field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UnpaybillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UnpaybillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UnpaybillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Unpaybill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UnpaybillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UnpaybillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UnpaybillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Unpaybill nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UnpaybillMutation) ResetField(name string) error {
	switch name {
	case unpaybill.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Unpaybill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UnpaybillMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.treatment != nil {
		edges = append(edges, unpaybill.EdgeTreatment)
	}
	if m.bills != nil {
		edges = append(edges, unpaybill.EdgeBills)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UnpaybillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case unpaybill.EdgeTreatment:
		if id := m.treatment; id != nil {
			return []ent.Value{*id}
		}
	case unpaybill.EdgeBills:
		if id := m.bills; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UnpaybillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UnpaybillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UnpaybillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtreatment {
		edges = append(edges, unpaybill.EdgeTreatment)
	}
	if m.clearedbills {
		edges = append(edges, unpaybill.EdgeBills)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UnpaybillMutation) EdgeCleared(name string) bool {
	switch name {
	case unpaybill.EdgeTreatment:
		return m.clearedtreatment
	case unpaybill.EdgeBills:
		return m.clearedbills
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UnpaybillMutation) ClearEdge(name string) error {
	switch name {
	case unpaybill.EdgeTreatment:
		m.ClearTreatment()
		return nil
	case unpaybill.EdgeBills:
		m.ClearBills()
		return nil
	}
	return fmt.Errorf("unknown Unpaybill unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UnpaybillMutation) ResetEdge(name string) error {
	switch name {
	case unpaybill.EdgeTreatment:
		m.ResetTreatment()
		return nil
	case unpaybill.EdgeBills:
		m.ResetBills()
		return nil
	}
	return fmt.Errorf("unknown Unpaybill edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	email                     *string
	password                  *string
	clearedFields             map[string]struct{}
	financier                 *int
	clearedfinancier          bool
	historytaking             *int
	clearedhistorytaking      bool
	_UserPatientrights        *int
	cleared_UserPatientrights bool
	medicalrecordstaff        *int
	clearedmedicalrecordstaff bool
	user2doctorinfo           *int
	cleareduser2doctorinfo    bool
	done                      bool
	oldValue                  func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetFinancierID sets the financier edge to Financier by id.
func (m *UserMutation) SetFinancierID(id int) {
	m.financier = &id
}

// ClearFinancier clears the financier edge to Financier.
func (m *UserMutation) ClearFinancier() {
	m.clearedfinancier = true
}

// FinancierCleared returns if the edge financier was cleared.
func (m *UserMutation) FinancierCleared() bool {
	return m.clearedfinancier
}

// FinancierID returns the financier id in the mutation.
func (m *UserMutation) FinancierID() (id int, exists bool) {
	if m.financier != nil {
		return *m.financier, true
	}
	return
}

// FinancierIDs returns the financier ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FinancierID instead. It exists only for internal usage by the builders.
func (m *UserMutation) FinancierIDs() (ids []int) {
	if id := m.financier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFinancier reset all changes of the "financier" edge.
func (m *UserMutation) ResetFinancier() {
	m.financier = nil
	m.clearedfinancier = false
}

// SetHistorytakingID sets the historytaking edge to Nurse by id.
func (m *UserMutation) SetHistorytakingID(id int) {
	m.historytaking = &id
}

// ClearHistorytaking clears the historytaking edge to Nurse.
func (m *UserMutation) ClearHistorytaking() {
	m.clearedhistorytaking = true
}

// HistorytakingCleared returns if the edge historytaking was cleared.
func (m *UserMutation) HistorytakingCleared() bool {
	return m.clearedhistorytaking
}

// HistorytakingID returns the historytaking id in the mutation.
func (m *UserMutation) HistorytakingID() (id int, exists bool) {
	if m.historytaking != nil {
		return *m.historytaking, true
	}
	return
}

// HistorytakingIDs returns the historytaking ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// HistorytakingID instead. It exists only for internal usage by the builders.
func (m *UserMutation) HistorytakingIDs() (ids []int) {
	if id := m.historytaking; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHistorytaking reset all changes of the "historytaking" edge.
func (m *UserMutation) ResetHistorytaking() {
	m.historytaking = nil
	m.clearedhistorytaking = false
}

// SetUserPatientrightsID sets the UserPatientrights edge to Patientrights by id.
func (m *UserMutation) SetUserPatientrightsID(id int) {
	m._UserPatientrights = &id
}

// ClearUserPatientrights clears the UserPatientrights edge to Patientrights.
func (m *UserMutation) ClearUserPatientrights() {
	m.cleared_UserPatientrights = true
}

// UserPatientrightsCleared returns if the edge UserPatientrights was cleared.
func (m *UserMutation) UserPatientrightsCleared() bool {
	return m.cleared_UserPatientrights
}

// UserPatientrightsID returns the UserPatientrights id in the mutation.
func (m *UserMutation) UserPatientrightsID() (id int, exists bool) {
	if m._UserPatientrights != nil {
		return *m._UserPatientrights, true
	}
	return
}

// UserPatientrightsIDs returns the UserPatientrights ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserPatientrightsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) UserPatientrightsIDs() (ids []int) {
	if id := m._UserPatientrights; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserPatientrights reset all changes of the "UserPatientrights" edge.
func (m *UserMutation) ResetUserPatientrights() {
	m._UserPatientrights = nil
	m.cleared_UserPatientrights = false
}

// SetMedicalrecordstaffID sets the medicalrecordstaff edge to Medicalrecordstaff by id.
func (m *UserMutation) SetMedicalrecordstaffID(id int) {
	m.medicalrecordstaff = &id
}

// ClearMedicalrecordstaff clears the medicalrecordstaff edge to Medicalrecordstaff.
func (m *UserMutation) ClearMedicalrecordstaff() {
	m.clearedmedicalrecordstaff = true
}

// MedicalrecordstaffCleared returns if the edge medicalrecordstaff was cleared.
func (m *UserMutation) MedicalrecordstaffCleared() bool {
	return m.clearedmedicalrecordstaff
}

// MedicalrecordstaffID returns the medicalrecordstaff id in the mutation.
func (m *UserMutation) MedicalrecordstaffID() (id int, exists bool) {
	if m.medicalrecordstaff != nil {
		return *m.medicalrecordstaff, true
	}
	return
}

// MedicalrecordstaffIDs returns the medicalrecordstaff ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MedicalrecordstaffID instead. It exists only for internal usage by the builders.
func (m *UserMutation) MedicalrecordstaffIDs() (ids []int) {
	if id := m.medicalrecordstaff; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedicalrecordstaff reset all changes of the "medicalrecordstaff" edge.
func (m *UserMutation) ResetMedicalrecordstaff() {
	m.medicalrecordstaff = nil
	m.clearedmedicalrecordstaff = false
}

// SetUser2doctorinfoID sets the user2doctorinfo edge to Doctorinfo by id.
func (m *UserMutation) SetUser2doctorinfoID(id int) {
	m.user2doctorinfo = &id
}

// ClearUser2doctorinfo clears the user2doctorinfo edge to Doctorinfo.
func (m *UserMutation) ClearUser2doctorinfo() {
	m.cleareduser2doctorinfo = true
}

// User2doctorinfoCleared returns if the edge user2doctorinfo was cleared.
func (m *UserMutation) User2doctorinfoCleared() bool {
	return m.cleareduser2doctorinfo
}

// User2doctorinfoID returns the user2doctorinfo id in the mutation.
func (m *UserMutation) User2doctorinfoID() (id int, exists bool) {
	if m.user2doctorinfo != nil {
		return *m.user2doctorinfo, true
	}
	return
}

// User2doctorinfoIDs returns the user2doctorinfo ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// User2doctorinfoID instead. It exists only for internal usage by the builders.
func (m *UserMutation) User2doctorinfoIDs() (ids []int) {
	if id := m.user2doctorinfo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser2doctorinfo reset all changes of the "user2doctorinfo" edge.
func (m *UserMutation) ResetUser2doctorinfo() {
	m.user2doctorinfo = nil
	m.cleareduser2doctorinfo = false
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.financier != nil {
		edges = append(edges, user.EdgeFinancier)
	}
	if m.historytaking != nil {
		edges = append(edges, user.EdgeHistorytaking)
	}
	if m._UserPatientrights != nil {
		edges = append(edges, user.EdgeUserPatientrights)
	}
	if m.medicalrecordstaff != nil {
		edges = append(edges, user.EdgeMedicalrecordstaff)
	}
	if m.user2doctorinfo != nil {
		edges = append(edges, user.EdgeUser2doctorinfo)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeFinancier:
		if id := m.financier; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeHistorytaking:
		if id := m.historytaking; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeUserPatientrights:
		if id := m._UserPatientrights; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeMedicalrecordstaff:
		if id := m.medicalrecordstaff; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeUser2doctorinfo:
		if id := m.user2doctorinfo; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedfinancier {
		edges = append(edges, user.EdgeFinancier)
	}
	if m.clearedhistorytaking {
		edges = append(edges, user.EdgeHistorytaking)
	}
	if m.cleared_UserPatientrights {
		edges = append(edges, user.EdgeUserPatientrights)
	}
	if m.clearedmedicalrecordstaff {
		edges = append(edges, user.EdgeMedicalrecordstaff)
	}
	if m.cleareduser2doctorinfo {
		edges = append(edges, user.EdgeUser2doctorinfo)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeFinancier:
		return m.clearedfinancier
	case user.EdgeHistorytaking:
		return m.clearedhistorytaking
	case user.EdgeUserPatientrights:
		return m.cleared_UserPatientrights
	case user.EdgeMedicalrecordstaff:
		return m.clearedmedicalrecordstaff
	case user.EdgeUser2doctorinfo:
		return m.cleareduser2doctorinfo
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeFinancier:
		m.ClearFinancier()
		return nil
	case user.EdgeHistorytaking:
		m.ClearHistorytaking()
		return nil
	case user.EdgeUserPatientrights:
		m.ClearUserPatientrights()
		return nil
	case user.EdgeMedicalrecordstaff:
		m.ClearMedicalrecordstaff()
		return nil
	case user.EdgeUser2doctorinfo:
		m.ClearUser2doctorinfo()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeFinancier:
		m.ResetFinancier()
		return nil
	case user.EdgeHistorytaking:
		m.ResetHistorytaking()
		return nil
	case user.EdgeUserPatientrights:
		m.ResetUserPatientrights()
		return nil
	case user.EdgeMedicalrecordstaff:
		m.ResetMedicalrecordstaff()
		return nil
	case user.EdgeUser2doctorinfo:
		m.ResetUser2doctorinfo()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
