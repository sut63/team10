// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/team10/app/ent/abilitypatientrights"
	"github.com/team10/app/ent/bill"
	"github.com/team10/app/ent/bloodtype"
	"github.com/team10/app/ent/department"
	"github.com/team10/app/ent/doctor"
	"github.com/team10/app/ent/doctorinfo"
	"github.com/team10/app/ent/educationlevel"
	"github.com/team10/app/ent/financier"
	"github.com/team10/app/ent/gender"
	"github.com/team10/app/ent/historytaking"
	"github.com/team10/app/ent/insurance"
	"github.com/team10/app/ent/medicalrecordstaff"
	"github.com/team10/app/ent/nurse"
	"github.com/team10/app/ent/officeroom"
	"github.com/team10/app/ent/patientrecord"
	"github.com/team10/app/ent/patientrights"
	"github.com/team10/app/ent/paytype"
	"github.com/team10/app/ent/prename"
	"github.com/team10/app/ent/registrar"
	"github.com/team10/app/ent/symptomseverity"
	"github.com/team10/app/ent/treatment"
	"github.com/team10/app/ent/typetreatment"
	"github.com/team10/app/ent/unpaybill"
	"github.com/team10/app/ent/user"
	"github.com/team10/app/ent/userstatus"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAbilitypatientrights = "Abilitypatientrights"
	TypeBill                 = "Bill"
	TypeBloodtype            = "Bloodtype"
	TypeDepartment           = "Department"
	TypeDoctor               = "Doctor"
	TypeDoctorinfo           = "Doctorinfo"
	TypeEducationlevel       = "Educationlevel"
	TypeFinancier            = "Financier"
	TypeGender               = "Gender"
	TypeHistorytaking        = "Historytaking"
	TypeInsurance            = "Insurance"
	TypeMedicalrecordstaff   = "Medicalrecordstaff"
	TypeNurse                = "Nurse"
	TypeOfficeroom           = "Officeroom"
	TypePatientrecord        = "Patientrecord"
	TypePatientrights        = "Patientrights"
	TypePaytype              = "Paytype"
	TypePrename              = "Prename"
	TypeRegistrar            = "Registrar"
	TypeSymptomseverity      = "Symptomseverity"
	TypeTreatment            = "Treatment"
	TypeTypetreatment        = "Typetreatment"
	TypeUnpaybill            = "Unpaybill"
	TypeUser                 = "User"
	TypeUserstatus           = "Userstatus"
)

// AbilitypatientrightsMutation represents an operation that mutate the AbilitypatientrightsSlice
// nodes in the graph.
type AbilitypatientrightsMutation struct {
	config
	op                                               Op
	typ                                              string
	id                                               *int
	_Operative                                       *int
	add_Operative                                    *int
	_MedicalSupplies                                 *int
	add_MedicalSupplies                              *int
	_Examine                                         *int
	add_Examine                                      *int
	_StayInHospital                                  *int
	add_StayInHospital                               *int
	check                                            *string
	clearedFields                                    map[string]struct{}
	_EdgesOfAbilitypatientrightsPatientrights        map[int]struct{}
	removed_EdgesOfAbilitypatientrightsPatientrights map[int]struct{}
	done                                             bool
	oldValue                                         func(context.Context) (*Abilitypatientrights, error)
}

var _ ent.Mutation = (*AbilitypatientrightsMutation)(nil)

// abilitypatientrightsOption allows to manage the mutation configuration using functional options.
type abilitypatientrightsOption func(*AbilitypatientrightsMutation)

// newAbilitypatientrightsMutation creates new mutation for $n.Name.
func newAbilitypatientrightsMutation(c config, op Op, opts ...abilitypatientrightsOption) *AbilitypatientrightsMutation {
	m := &AbilitypatientrightsMutation{
		config:        c,
		op:            op,
		typ:           TypeAbilitypatientrights,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAbilitypatientrightsID sets the id field of the mutation.
func withAbilitypatientrightsID(id int) abilitypatientrightsOption {
	return func(m *AbilitypatientrightsMutation) {
		var (
			err   error
			once  sync.Once
			value *Abilitypatientrights
		)
		m.oldValue = func(ctx context.Context) (*Abilitypatientrights, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Abilitypatientrights.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAbilitypatientrights sets the old Abilitypatientrights of the mutation.
func withAbilitypatientrights(node *Abilitypatientrights) abilitypatientrightsOption {
	return func(m *AbilitypatientrightsMutation) {
		m.oldValue = func(context.Context) (*Abilitypatientrights, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AbilitypatientrightsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AbilitypatientrightsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AbilitypatientrightsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOperative sets the Operative field.
func (m *AbilitypatientrightsMutation) SetOperative(i int) {
	m._Operative = &i
	m.add_Operative = nil
}

// Operative returns the Operative value in the mutation.
func (m *AbilitypatientrightsMutation) Operative() (r int, exists bool) {
	v := m._Operative
	if v == nil {
		return
	}
	return *v, true
}

// OldOperative returns the old Operative value of the Abilitypatientrights.
// If the Abilitypatientrights object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbilitypatientrightsMutation) OldOperative(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOperative is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOperative requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperative: %w", err)
	}
	return oldValue.Operative, nil
}

// AddOperative adds i to Operative.
func (m *AbilitypatientrightsMutation) AddOperative(i int) {
	if m.add_Operative != nil {
		*m.add_Operative += i
	} else {
		m.add_Operative = &i
	}
}

// AddedOperative returns the value that was added to the Operative field in this mutation.
func (m *AbilitypatientrightsMutation) AddedOperative() (r int, exists bool) {
	v := m.add_Operative
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperative reset all changes of the "Operative" field.
func (m *AbilitypatientrightsMutation) ResetOperative() {
	m._Operative = nil
	m.add_Operative = nil
}

// SetMedicalSupplies sets the MedicalSupplies field.
func (m *AbilitypatientrightsMutation) SetMedicalSupplies(i int) {
	m._MedicalSupplies = &i
	m.add_MedicalSupplies = nil
}

// MedicalSupplies returns the MedicalSupplies value in the mutation.
func (m *AbilitypatientrightsMutation) MedicalSupplies() (r int, exists bool) {
	v := m._MedicalSupplies
	if v == nil {
		return
	}
	return *v, true
}

// OldMedicalSupplies returns the old MedicalSupplies value of the Abilitypatientrights.
// If the Abilitypatientrights object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbilitypatientrightsMutation) OldMedicalSupplies(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMedicalSupplies is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMedicalSupplies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedicalSupplies: %w", err)
	}
	return oldValue.MedicalSupplies, nil
}

// AddMedicalSupplies adds i to MedicalSupplies.
func (m *AbilitypatientrightsMutation) AddMedicalSupplies(i int) {
	if m.add_MedicalSupplies != nil {
		*m.add_MedicalSupplies += i
	} else {
		m.add_MedicalSupplies = &i
	}
}

// AddedMedicalSupplies returns the value that was added to the MedicalSupplies field in this mutation.
func (m *AbilitypatientrightsMutation) AddedMedicalSupplies() (r int, exists bool) {
	v := m.add_MedicalSupplies
	if v == nil {
		return
	}
	return *v, true
}

// ResetMedicalSupplies reset all changes of the "MedicalSupplies" field.
func (m *AbilitypatientrightsMutation) ResetMedicalSupplies() {
	m._MedicalSupplies = nil
	m.add_MedicalSupplies = nil
}

// SetExamine sets the Examine field.
func (m *AbilitypatientrightsMutation) SetExamine(i int) {
	m._Examine = &i
	m.add_Examine = nil
}

// Examine returns the Examine value in the mutation.
func (m *AbilitypatientrightsMutation) Examine() (r int, exists bool) {
	v := m._Examine
	if v == nil {
		return
	}
	return *v, true
}

// OldExamine returns the old Examine value of the Abilitypatientrights.
// If the Abilitypatientrights object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbilitypatientrightsMutation) OldExamine(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamine is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamine: %w", err)
	}
	return oldValue.Examine, nil
}

// AddExamine adds i to Examine.
func (m *AbilitypatientrightsMutation) AddExamine(i int) {
	if m.add_Examine != nil {
		*m.add_Examine += i
	} else {
		m.add_Examine = &i
	}
}

// AddedExamine returns the value that was added to the Examine field in this mutation.
func (m *AbilitypatientrightsMutation) AddedExamine() (r int, exists bool) {
	v := m.add_Examine
	if v == nil {
		return
	}
	return *v, true
}

// ResetExamine reset all changes of the "Examine" field.
func (m *AbilitypatientrightsMutation) ResetExamine() {
	m._Examine = nil
	m.add_Examine = nil
}

// SetStayInHospital sets the StayInHospital field.
func (m *AbilitypatientrightsMutation) SetStayInHospital(i int) {
	m._StayInHospital = &i
	m.add_StayInHospital = nil
}

// StayInHospital returns the StayInHospital value in the mutation.
func (m *AbilitypatientrightsMutation) StayInHospital() (r int, exists bool) {
	v := m._StayInHospital
	if v == nil {
		return
	}
	return *v, true
}

// OldStayInHospital returns the old StayInHospital value of the Abilitypatientrights.
// If the Abilitypatientrights object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbilitypatientrightsMutation) OldStayInHospital(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStayInHospital is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStayInHospital requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStayInHospital: %w", err)
	}
	return oldValue.StayInHospital, nil
}

// AddStayInHospital adds i to StayInHospital.
func (m *AbilitypatientrightsMutation) AddStayInHospital(i int) {
	if m.add_StayInHospital != nil {
		*m.add_StayInHospital += i
	} else {
		m.add_StayInHospital = &i
	}
}

// AddedStayInHospital returns the value that was added to the StayInHospital field in this mutation.
func (m *AbilitypatientrightsMutation) AddedStayInHospital() (r int, exists bool) {
	v := m.add_StayInHospital
	if v == nil {
		return
	}
	return *v, true
}

// ResetStayInHospital reset all changes of the "StayInHospital" field.
func (m *AbilitypatientrightsMutation) ResetStayInHospital() {
	m._StayInHospital = nil
	m.add_StayInHospital = nil
}

// SetCheck sets the check field.
func (m *AbilitypatientrightsMutation) SetCheck(s string) {
	m.check = &s
}

// Check returns the check value in the mutation.
func (m *AbilitypatientrightsMutation) Check() (r string, exists bool) {
	v := m.check
	if v == nil {
		return
	}
	return *v, true
}

// OldCheck returns the old check value of the Abilitypatientrights.
// If the Abilitypatientrights object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbilitypatientrightsMutation) OldCheck(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheck is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheck requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheck: %w", err)
	}
	return oldValue.Check, nil
}

// ResetCheck reset all changes of the "check" field.
func (m *AbilitypatientrightsMutation) ResetCheck() {
	m.check = nil
}

// AddEdgesOfAbilitypatientrightsPatientrightIDs adds the EdgesOfAbilitypatientrightsPatientrights edge to Patientrights by ids.
func (m *AbilitypatientrightsMutation) AddEdgesOfAbilitypatientrightsPatientrightIDs(ids ...int) {
	if m._EdgesOfAbilitypatientrightsPatientrights == nil {
		m._EdgesOfAbilitypatientrightsPatientrights = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfAbilitypatientrightsPatientrights[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfAbilitypatientrightsPatientrightIDs removes the EdgesOfAbilitypatientrightsPatientrights edge to Patientrights by ids.
func (m *AbilitypatientrightsMutation) RemoveEdgesOfAbilitypatientrightsPatientrightIDs(ids ...int) {
	if m.removed_EdgesOfAbilitypatientrightsPatientrights == nil {
		m.removed_EdgesOfAbilitypatientrightsPatientrights = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfAbilitypatientrightsPatientrights[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfAbilitypatientrightsPatientrights returns the removed ids of EdgesOfAbilitypatientrightsPatientrights.
func (m *AbilitypatientrightsMutation) RemovedEdgesOfAbilitypatientrightsPatientrightsIDs() (ids []int) {
	for id := range m.removed_EdgesOfAbilitypatientrightsPatientrights {
		ids = append(ids, id)
	}
	return
}

// EdgesOfAbilitypatientrightsPatientrightsIDs returns the EdgesOfAbilitypatientrightsPatientrights ids in the mutation.
func (m *AbilitypatientrightsMutation) EdgesOfAbilitypatientrightsPatientrightsIDs() (ids []int) {
	for id := range m._EdgesOfAbilitypatientrightsPatientrights {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfAbilitypatientrightsPatientrights reset all changes of the "EdgesOfAbilitypatientrightsPatientrights" edge.
func (m *AbilitypatientrightsMutation) ResetEdgesOfAbilitypatientrightsPatientrights() {
	m._EdgesOfAbilitypatientrightsPatientrights = nil
	m.removed_EdgesOfAbilitypatientrightsPatientrights = nil
}

// Op returns the operation name.
func (m *AbilitypatientrightsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Abilitypatientrights).
func (m *AbilitypatientrightsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AbilitypatientrightsMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._Operative != nil {
		fields = append(fields, abilitypatientrights.FieldOperative)
	}
	if m._MedicalSupplies != nil {
		fields = append(fields, abilitypatientrights.FieldMedicalSupplies)
	}
	if m._Examine != nil {
		fields = append(fields, abilitypatientrights.FieldExamine)
	}
	if m._StayInHospital != nil {
		fields = append(fields, abilitypatientrights.FieldStayInHospital)
	}
	if m.check != nil {
		fields = append(fields, abilitypatientrights.FieldCheck)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AbilitypatientrightsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case abilitypatientrights.FieldOperative:
		return m.Operative()
	case abilitypatientrights.FieldMedicalSupplies:
		return m.MedicalSupplies()
	case abilitypatientrights.FieldExamine:
		return m.Examine()
	case abilitypatientrights.FieldStayInHospital:
		return m.StayInHospital()
	case abilitypatientrights.FieldCheck:
		return m.Check()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AbilitypatientrightsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case abilitypatientrights.FieldOperative:
		return m.OldOperative(ctx)
	case abilitypatientrights.FieldMedicalSupplies:
		return m.OldMedicalSupplies(ctx)
	case abilitypatientrights.FieldExamine:
		return m.OldExamine(ctx)
	case abilitypatientrights.FieldStayInHospital:
		return m.OldStayInHospital(ctx)
	case abilitypatientrights.FieldCheck:
		return m.OldCheck(ctx)
	}
	return nil, fmt.Errorf("unknown Abilitypatientrights field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AbilitypatientrightsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case abilitypatientrights.FieldOperative:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperative(v)
		return nil
	case abilitypatientrights.FieldMedicalSupplies:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedicalSupplies(v)
		return nil
	case abilitypatientrights.FieldExamine:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamine(v)
		return nil
	case abilitypatientrights.FieldStayInHospital:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStayInHospital(v)
		return nil
	case abilitypatientrights.FieldCheck:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheck(v)
		return nil
	}
	return fmt.Errorf("unknown Abilitypatientrights field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AbilitypatientrightsMutation) AddedFields() []string {
	var fields []string
	if m.add_Operative != nil {
		fields = append(fields, abilitypatientrights.FieldOperative)
	}
	if m.add_MedicalSupplies != nil {
		fields = append(fields, abilitypatientrights.FieldMedicalSupplies)
	}
	if m.add_Examine != nil {
		fields = append(fields, abilitypatientrights.FieldExamine)
	}
	if m.add_StayInHospital != nil {
		fields = append(fields, abilitypatientrights.FieldStayInHospital)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AbilitypatientrightsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case abilitypatientrights.FieldOperative:
		return m.AddedOperative()
	case abilitypatientrights.FieldMedicalSupplies:
		return m.AddedMedicalSupplies()
	case abilitypatientrights.FieldExamine:
		return m.AddedExamine()
	case abilitypatientrights.FieldStayInHospital:
		return m.AddedStayInHospital()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AbilitypatientrightsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case abilitypatientrights.FieldOperative:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperative(v)
		return nil
	case abilitypatientrights.FieldMedicalSupplies:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMedicalSupplies(v)
		return nil
	case abilitypatientrights.FieldExamine:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamine(v)
		return nil
	case abilitypatientrights.FieldStayInHospital:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStayInHospital(v)
		return nil
	}
	return fmt.Errorf("unknown Abilitypatientrights numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AbilitypatientrightsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AbilitypatientrightsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AbilitypatientrightsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Abilitypatientrights nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AbilitypatientrightsMutation) ResetField(name string) error {
	switch name {
	case abilitypatientrights.FieldOperative:
		m.ResetOperative()
		return nil
	case abilitypatientrights.FieldMedicalSupplies:
		m.ResetMedicalSupplies()
		return nil
	case abilitypatientrights.FieldExamine:
		m.ResetExamine()
		return nil
	case abilitypatientrights.FieldStayInHospital:
		m.ResetStayInHospital()
		return nil
	case abilitypatientrights.FieldCheck:
		m.ResetCheck()
		return nil
	}
	return fmt.Errorf("unknown Abilitypatientrights field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AbilitypatientrightsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._EdgesOfAbilitypatientrightsPatientrights != nil {
		edges = append(edges, abilitypatientrights.EdgeEdgesOfAbilitypatientrightsPatientrights)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AbilitypatientrightsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case abilitypatientrights.EdgeEdgesOfAbilitypatientrightsPatientrights:
		ids := make([]ent.Value, 0, len(m._EdgesOfAbilitypatientrightsPatientrights))
		for id := range m._EdgesOfAbilitypatientrightsPatientrights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AbilitypatientrightsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_EdgesOfAbilitypatientrightsPatientrights != nil {
		edges = append(edges, abilitypatientrights.EdgeEdgesOfAbilitypatientrightsPatientrights)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AbilitypatientrightsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case abilitypatientrights.EdgeEdgesOfAbilitypatientrightsPatientrights:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfAbilitypatientrightsPatientrights))
		for id := range m.removed_EdgesOfAbilitypatientrightsPatientrights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AbilitypatientrightsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AbilitypatientrightsMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AbilitypatientrightsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Abilitypatientrights unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AbilitypatientrightsMutation) ResetEdge(name string) error {
	switch name {
	case abilitypatientrights.EdgeEdgesOfAbilitypatientrightsPatientrights:
		m.ResetEdgesOfAbilitypatientrightsPatientrights()
		return nil
	}
	return fmt.Errorf("unknown Abilitypatientrights edge %s", name)
}

// BillMutation represents an operation that mutate the Bills
// nodes in the graph.
type BillMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	_Amount                  *int
	add_Amount               *int
	_Payer                   *string
	_Payercontact            *string
	_Date                    *time.Time
	clearedFields            map[string]struct{}
	_EdgesOfPaytype          *int
	cleared_EdgesOfPaytype   bool
	_EdgesOfOfficer          *int
	cleared_EdgesOfOfficer   bool
	_EdgesOfUnpaybill        *int
	cleared_EdgesOfUnpaybill bool
	done                     bool
	oldValue                 func(context.Context) (*Bill, error)
}

var _ ent.Mutation = (*BillMutation)(nil)

// billOption allows to manage the mutation configuration using functional options.
type billOption func(*BillMutation)

// newBillMutation creates new mutation for $n.Name.
func newBillMutation(c config, op Op, opts ...billOption) *BillMutation {
	m := &BillMutation{
		config:        c,
		op:            op,
		typ:           TypeBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillID sets the id field of the mutation.
func withBillID(id int) billOption {
	return func(m *BillMutation) {
		var (
			err   error
			once  sync.Once
			value *Bill
		)
		m.oldValue = func(ctx context.Context) (*Bill, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBill sets the old Bill of the mutation.
func withBill(node *Bill) billOption {
	return func(m *BillMutation) {
		m.oldValue = func(context.Context) (*Bill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAmount sets the Amount field.
func (m *BillMutation) SetAmount(i int) {
	m._Amount = &i
	m.add_Amount = nil
}

// Amount returns the Amount value in the mutation.
func (m *BillMutation) Amount() (r int, exists bool) {
	v := m._Amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old Amount value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to Amount.
func (m *BillMutation) AddAmount(i int) {
	if m.add_Amount != nil {
		*m.add_Amount += i
	} else {
		m.add_Amount = &i
	}
}

// AddedAmount returns the value that was added to the Amount field in this mutation.
func (m *BillMutation) AddedAmount() (r int, exists bool) {
	v := m.add_Amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount reset all changes of the "Amount" field.
func (m *BillMutation) ResetAmount() {
	m._Amount = nil
	m.add_Amount = nil
}

// SetPayer sets the Payer field.
func (m *BillMutation) SetPayer(s string) {
	m._Payer = &s
}

// Payer returns the Payer value in the mutation.
func (m *BillMutation) Payer() (r string, exists bool) {
	v := m._Payer
	if v == nil {
		return
	}
	return *v, true
}

// OldPayer returns the old Payer value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldPayer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayer is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayer: %w", err)
	}
	return oldValue.Payer, nil
}

// ResetPayer reset all changes of the "Payer" field.
func (m *BillMutation) ResetPayer() {
	m._Payer = nil
}

// SetPayercontact sets the Payercontact field.
func (m *BillMutation) SetPayercontact(s string) {
	m._Payercontact = &s
}

// Payercontact returns the Payercontact value in the mutation.
func (m *BillMutation) Payercontact() (r string, exists bool) {
	v := m._Payercontact
	if v == nil {
		return
	}
	return *v, true
}

// OldPayercontact returns the old Payercontact value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldPayercontact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayercontact is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayercontact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayercontact: %w", err)
	}
	return oldValue.Payercontact, nil
}

// ResetPayercontact reset all changes of the "Payercontact" field.
func (m *BillMutation) ResetPayercontact() {
	m._Payercontact = nil
}

// SetDate sets the Date field.
func (m *BillMutation) SetDate(t time.Time) {
	m._Date = &t
}

// Date returns the Date value in the mutation.
func (m *BillMutation) Date() (r time.Time, exists bool) {
	v := m._Date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old Date value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate reset all changes of the "Date" field.
func (m *BillMutation) ResetDate() {
	m._Date = nil
}

// SetEdgesOfPaytypeID sets the EdgesOfPaytype edge to Paytype by id.
func (m *BillMutation) SetEdgesOfPaytypeID(id int) {
	m._EdgesOfPaytype = &id
}

// ClearEdgesOfPaytype clears the EdgesOfPaytype edge to Paytype.
func (m *BillMutation) ClearEdgesOfPaytype() {
	m.cleared_EdgesOfPaytype = true
}

// EdgesOfPaytypeCleared returns if the edge EdgesOfPaytype was cleared.
func (m *BillMutation) EdgesOfPaytypeCleared() bool {
	return m.cleared_EdgesOfPaytype
}

// EdgesOfPaytypeID returns the EdgesOfPaytype id in the mutation.
func (m *BillMutation) EdgesOfPaytypeID() (id int, exists bool) {
	if m._EdgesOfPaytype != nil {
		return *m._EdgesOfPaytype, true
	}
	return
}

// EdgesOfPaytypeIDs returns the EdgesOfPaytype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfPaytypeID instead. It exists only for internal usage by the builders.
func (m *BillMutation) EdgesOfPaytypeIDs() (ids []int) {
	if id := m._EdgesOfPaytype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfPaytype reset all changes of the "EdgesOfPaytype" edge.
func (m *BillMutation) ResetEdgesOfPaytype() {
	m._EdgesOfPaytype = nil
	m.cleared_EdgesOfPaytype = false
}

// SetEdgesOfOfficerID sets the EdgesOfOfficer edge to Financier by id.
func (m *BillMutation) SetEdgesOfOfficerID(id int) {
	m._EdgesOfOfficer = &id
}

// ClearEdgesOfOfficer clears the EdgesOfOfficer edge to Financier.
func (m *BillMutation) ClearEdgesOfOfficer() {
	m.cleared_EdgesOfOfficer = true
}

// EdgesOfOfficerCleared returns if the edge EdgesOfOfficer was cleared.
func (m *BillMutation) EdgesOfOfficerCleared() bool {
	return m.cleared_EdgesOfOfficer
}

// EdgesOfOfficerID returns the EdgesOfOfficer id in the mutation.
func (m *BillMutation) EdgesOfOfficerID() (id int, exists bool) {
	if m._EdgesOfOfficer != nil {
		return *m._EdgesOfOfficer, true
	}
	return
}

// EdgesOfOfficerIDs returns the EdgesOfOfficer ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfOfficerID instead. It exists only for internal usage by the builders.
func (m *BillMutation) EdgesOfOfficerIDs() (ids []int) {
	if id := m._EdgesOfOfficer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfOfficer reset all changes of the "EdgesOfOfficer" edge.
func (m *BillMutation) ResetEdgesOfOfficer() {
	m._EdgesOfOfficer = nil
	m.cleared_EdgesOfOfficer = false
}

// SetEdgesOfUnpaybillID sets the EdgesOfUnpaybill edge to Unpaybill by id.
func (m *BillMutation) SetEdgesOfUnpaybillID(id int) {
	m._EdgesOfUnpaybill = &id
}

// ClearEdgesOfUnpaybill clears the EdgesOfUnpaybill edge to Unpaybill.
func (m *BillMutation) ClearEdgesOfUnpaybill() {
	m.cleared_EdgesOfUnpaybill = true
}

// EdgesOfUnpaybillCleared returns if the edge EdgesOfUnpaybill was cleared.
func (m *BillMutation) EdgesOfUnpaybillCleared() bool {
	return m.cleared_EdgesOfUnpaybill
}

// EdgesOfUnpaybillID returns the EdgesOfUnpaybill id in the mutation.
func (m *BillMutation) EdgesOfUnpaybillID() (id int, exists bool) {
	if m._EdgesOfUnpaybill != nil {
		return *m._EdgesOfUnpaybill, true
	}
	return
}

// EdgesOfUnpaybillIDs returns the EdgesOfUnpaybill ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfUnpaybillID instead. It exists only for internal usage by the builders.
func (m *BillMutation) EdgesOfUnpaybillIDs() (ids []int) {
	if id := m._EdgesOfUnpaybill; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfUnpaybill reset all changes of the "EdgesOfUnpaybill" edge.
func (m *BillMutation) ResetEdgesOfUnpaybill() {
	m._EdgesOfUnpaybill = nil
	m.cleared_EdgesOfUnpaybill = false
}

// Op returns the operation name.
func (m *BillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bill).
func (m *BillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BillMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Amount != nil {
		fields = append(fields, bill.FieldAmount)
	}
	if m._Payer != nil {
		fields = append(fields, bill.FieldPayer)
	}
	if m._Payercontact != nil {
		fields = append(fields, bill.FieldPayercontact)
	}
	if m._Date != nil {
		fields = append(fields, bill.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldAmount:
		return m.Amount()
	case bill.FieldPayer:
		return m.Payer()
	case bill.FieldPayercontact:
		return m.Payercontact()
	case bill.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bill.FieldAmount:
		return m.OldAmount(ctx)
	case bill.FieldPayer:
		return m.OldPayer(ctx)
	case bill.FieldPayercontact:
		return m.OldPayercontact(ctx)
	case bill.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown Bill field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bill.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case bill.FieldPayer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayer(v)
		return nil
	case bill.FieldPayercontact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayercontact(v)
		return nil
	case bill.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BillMutation) AddedFields() []string {
	var fields []string
	if m.add_Amount != nil {
		fields = append(fields, bill.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bill.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Bill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bill nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BillMutation) ResetField(name string) error {
	switch name {
	case bill.FieldAmount:
		m.ResetAmount()
		return nil
	case bill.FieldPayer:
		m.ResetPayer()
		return nil
	case bill.FieldPayercontact:
		m.ResetPayercontact()
		return nil
	case bill.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BillMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._EdgesOfPaytype != nil {
		edges = append(edges, bill.EdgeEdgesOfPaytype)
	}
	if m._EdgesOfOfficer != nil {
		edges = append(edges, bill.EdgeEdgesOfOfficer)
	}
	if m._EdgesOfUnpaybill != nil {
		edges = append(edges, bill.EdgeEdgesOfUnpaybill)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bill.EdgeEdgesOfPaytype:
		if id := m._EdgesOfPaytype; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeEdgesOfOfficer:
		if id := m._EdgesOfOfficer; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeEdgesOfUnpaybill:
		if id := m._EdgesOfUnpaybill; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_EdgesOfPaytype {
		edges = append(edges, bill.EdgeEdgesOfPaytype)
	}
	if m.cleared_EdgesOfOfficer {
		edges = append(edges, bill.EdgeEdgesOfOfficer)
	}
	if m.cleared_EdgesOfUnpaybill {
		edges = append(edges, bill.EdgeEdgesOfUnpaybill)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BillMutation) EdgeCleared(name string) bool {
	switch name {
	case bill.EdgeEdgesOfPaytype:
		return m.cleared_EdgesOfPaytype
	case bill.EdgeEdgesOfOfficer:
		return m.cleared_EdgesOfOfficer
	case bill.EdgeEdgesOfUnpaybill:
		return m.cleared_EdgesOfUnpaybill
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BillMutation) ClearEdge(name string) error {
	switch name {
	case bill.EdgeEdgesOfPaytype:
		m.ClearEdgesOfPaytype()
		return nil
	case bill.EdgeEdgesOfOfficer:
		m.ClearEdgesOfOfficer()
		return nil
	case bill.EdgeEdgesOfUnpaybill:
		m.ClearEdgesOfUnpaybill()
		return nil
	}
	return fmt.Errorf("unknown Bill unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BillMutation) ResetEdge(name string) error {
	switch name {
	case bill.EdgeEdgesOfPaytype:
		m.ResetEdgesOfPaytype()
		return nil
	case bill.EdgeEdgesOfOfficer:
		m.ResetEdgesOfOfficer()
		return nil
	case bill.EdgeEdgesOfUnpaybill:
		m.ResetEdgesOfUnpaybill()
		return nil
	}
	return fmt.Errorf("unknown Bill edge %s", name)
}

// BloodtypeMutation represents an operation that mutate the Bloodtypes
// nodes in the graph.
type BloodtypeMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	bloodtype                    *string
	clearedFields                map[string]struct{}
	_EdgesOfPatientrecord        map[int]struct{}
	removed_EdgesOfPatientrecord map[int]struct{}
	done                         bool
	oldValue                     func(context.Context) (*Bloodtype, error)
}

var _ ent.Mutation = (*BloodtypeMutation)(nil)

// bloodtypeOption allows to manage the mutation configuration using functional options.
type bloodtypeOption func(*BloodtypeMutation)

// newBloodtypeMutation creates new mutation for $n.Name.
func newBloodtypeMutation(c config, op Op, opts ...bloodtypeOption) *BloodtypeMutation {
	m := &BloodtypeMutation{
		config:        c,
		op:            op,
		typ:           TypeBloodtype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBloodtypeID sets the id field of the mutation.
func withBloodtypeID(id int) bloodtypeOption {
	return func(m *BloodtypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Bloodtype
		)
		m.oldValue = func(ctx context.Context) (*Bloodtype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bloodtype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBloodtype sets the old Bloodtype of the mutation.
func withBloodtype(node *Bloodtype) bloodtypeOption {
	return func(m *BloodtypeMutation) {
		m.oldValue = func(context.Context) (*Bloodtype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BloodtypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BloodtypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BloodtypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBloodtype sets the bloodtype field.
func (m *BloodtypeMutation) SetBloodtype(s string) {
	m.bloodtype = &s
}

// Bloodtype returns the bloodtype value in the mutation.
func (m *BloodtypeMutation) Bloodtype() (r string, exists bool) {
	v := m.bloodtype
	if v == nil {
		return
	}
	return *v, true
}

// OldBloodtype returns the old bloodtype value of the Bloodtype.
// If the Bloodtype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BloodtypeMutation) OldBloodtype(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBloodtype is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBloodtype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBloodtype: %w", err)
	}
	return oldValue.Bloodtype, nil
}

// ResetBloodtype reset all changes of the "bloodtype" field.
func (m *BloodtypeMutation) ResetBloodtype() {
	m.bloodtype = nil
}

// AddEdgesOfPatientrecordIDs adds the EdgesOfPatientrecord edge to Patientrecord by ids.
func (m *BloodtypeMutation) AddEdgesOfPatientrecordIDs(ids ...int) {
	if m._EdgesOfPatientrecord == nil {
		m._EdgesOfPatientrecord = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfPatientrecord[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfPatientrecordIDs removes the EdgesOfPatientrecord edge to Patientrecord by ids.
func (m *BloodtypeMutation) RemoveEdgesOfPatientrecordIDs(ids ...int) {
	if m.removed_EdgesOfPatientrecord == nil {
		m.removed_EdgesOfPatientrecord = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfPatientrecord[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfPatientrecord returns the removed ids of EdgesOfPatientrecord.
func (m *BloodtypeMutation) RemovedEdgesOfPatientrecordIDs() (ids []int) {
	for id := range m.removed_EdgesOfPatientrecord {
		ids = append(ids, id)
	}
	return
}

// EdgesOfPatientrecordIDs returns the EdgesOfPatientrecord ids in the mutation.
func (m *BloodtypeMutation) EdgesOfPatientrecordIDs() (ids []int) {
	for id := range m._EdgesOfPatientrecord {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfPatientrecord reset all changes of the "EdgesOfPatientrecord" edge.
func (m *BloodtypeMutation) ResetEdgesOfPatientrecord() {
	m._EdgesOfPatientrecord = nil
	m.removed_EdgesOfPatientrecord = nil
}

// Op returns the operation name.
func (m *BloodtypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bloodtype).
func (m *BloodtypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BloodtypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.bloodtype != nil {
		fields = append(fields, bloodtype.FieldBloodtype)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BloodtypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bloodtype.FieldBloodtype:
		return m.Bloodtype()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BloodtypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bloodtype.FieldBloodtype:
		return m.OldBloodtype(ctx)
	}
	return nil, fmt.Errorf("unknown Bloodtype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BloodtypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bloodtype.FieldBloodtype:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBloodtype(v)
		return nil
	}
	return fmt.Errorf("unknown Bloodtype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BloodtypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BloodtypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BloodtypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bloodtype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BloodtypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BloodtypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BloodtypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bloodtype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BloodtypeMutation) ResetField(name string) error {
	switch name {
	case bloodtype.FieldBloodtype:
		m.ResetBloodtype()
		return nil
	}
	return fmt.Errorf("unknown Bloodtype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BloodtypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._EdgesOfPatientrecord != nil {
		edges = append(edges, bloodtype.EdgeEdgesOfPatientrecord)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BloodtypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bloodtype.EdgeEdgesOfPatientrecord:
		ids := make([]ent.Value, 0, len(m._EdgesOfPatientrecord))
		for id := range m._EdgesOfPatientrecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BloodtypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_EdgesOfPatientrecord != nil {
		edges = append(edges, bloodtype.EdgeEdgesOfPatientrecord)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BloodtypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bloodtype.EdgeEdgesOfPatientrecord:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfPatientrecord))
		for id := range m.removed_EdgesOfPatientrecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BloodtypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BloodtypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BloodtypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Bloodtype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BloodtypeMutation) ResetEdge(name string) error {
	switch name {
	case bloodtype.EdgeEdgesOfPatientrecord:
		m.ResetEdgesOfPatientrecord()
		return nil
	}
	return fmt.Errorf("unknown Bloodtype edge %s", name)
}

// DepartmentMutation represents an operation that mutate the Departments
// nodes in the graph.
type DepartmentMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	department                           *string
	clearedFields                        map[string]struct{}
	_EdgesOfDepartment2doctorinfo        map[int]struct{}
	removed_EdgesOfDepartment2doctorinfo map[int]struct{}
	_EdgesOfHistorytaking                map[int]struct{}
	removed_EdgesOfHistorytaking         map[int]struct{}
	done                                 bool
	oldValue                             func(context.Context) (*Department, error)
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows to manage the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for $n.Name.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the id field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDepartment sets the department field.
func (m *DepartmentMutation) SetDepartment(s string) {
	m.department = &s
}

// Department returns the department value in the mutation.
func (m *DepartmentMutation) Department() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartment returns the old department value of the Department.
// If the Department object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepartmentMutation) OldDepartment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDepartment is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartment: %w", err)
	}
	return oldValue.Department, nil
}

// ResetDepartment reset all changes of the "department" field.
func (m *DepartmentMutation) ResetDepartment() {
	m.department = nil
}

// AddEdgesOfDepartment2doctorinfoIDs adds the EdgesOfDepartment2doctorinfo edge to Doctorinfo by ids.
func (m *DepartmentMutation) AddEdgesOfDepartment2doctorinfoIDs(ids ...int) {
	if m._EdgesOfDepartment2doctorinfo == nil {
		m._EdgesOfDepartment2doctorinfo = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfDepartment2doctorinfo[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfDepartment2doctorinfoIDs removes the EdgesOfDepartment2doctorinfo edge to Doctorinfo by ids.
func (m *DepartmentMutation) RemoveEdgesOfDepartment2doctorinfoIDs(ids ...int) {
	if m.removed_EdgesOfDepartment2doctorinfo == nil {
		m.removed_EdgesOfDepartment2doctorinfo = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfDepartment2doctorinfo[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfDepartment2doctorinfo returns the removed ids of EdgesOfDepartment2doctorinfo.
func (m *DepartmentMutation) RemovedEdgesOfDepartment2doctorinfoIDs() (ids []int) {
	for id := range m.removed_EdgesOfDepartment2doctorinfo {
		ids = append(ids, id)
	}
	return
}

// EdgesOfDepartment2doctorinfoIDs returns the EdgesOfDepartment2doctorinfo ids in the mutation.
func (m *DepartmentMutation) EdgesOfDepartment2doctorinfoIDs() (ids []int) {
	for id := range m._EdgesOfDepartment2doctorinfo {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfDepartment2doctorinfo reset all changes of the "EdgesOfDepartment2doctorinfo" edge.
func (m *DepartmentMutation) ResetEdgesOfDepartment2doctorinfo() {
	m._EdgesOfDepartment2doctorinfo = nil
	m.removed_EdgesOfDepartment2doctorinfo = nil
}

// AddEdgesOfHistorytakingIDs adds the EdgesOfHistorytaking edge to Historytaking by ids.
func (m *DepartmentMutation) AddEdgesOfHistorytakingIDs(ids ...int) {
	if m._EdgesOfHistorytaking == nil {
		m._EdgesOfHistorytaking = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfHistorytaking[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfHistorytakingIDs removes the EdgesOfHistorytaking edge to Historytaking by ids.
func (m *DepartmentMutation) RemoveEdgesOfHistorytakingIDs(ids ...int) {
	if m.removed_EdgesOfHistorytaking == nil {
		m.removed_EdgesOfHistorytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfHistorytaking[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfHistorytaking returns the removed ids of EdgesOfHistorytaking.
func (m *DepartmentMutation) RemovedEdgesOfHistorytakingIDs() (ids []int) {
	for id := range m.removed_EdgesOfHistorytaking {
		ids = append(ids, id)
	}
	return
}

// EdgesOfHistorytakingIDs returns the EdgesOfHistorytaking ids in the mutation.
func (m *DepartmentMutation) EdgesOfHistorytakingIDs() (ids []int) {
	for id := range m._EdgesOfHistorytaking {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfHistorytaking reset all changes of the "EdgesOfHistorytaking" edge.
func (m *DepartmentMutation) ResetEdgesOfHistorytaking() {
	m._EdgesOfHistorytaking = nil
	m.removed_EdgesOfHistorytaking = nil
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.department != nil {
		fields = append(fields, department.FieldDepartment)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldDepartment:
		return m.Department()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldDepartment:
		return m.OldDepartment(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartment(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._EdgesOfDepartment2doctorinfo != nil {
		edges = append(edges, department.EdgeEdgesOfDepartment2doctorinfo)
	}
	if m._EdgesOfHistorytaking != nil {
		edges = append(edges, department.EdgeEdgesOfHistorytaking)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeEdgesOfDepartment2doctorinfo:
		ids := make([]ent.Value, 0, len(m._EdgesOfDepartment2doctorinfo))
		for id := range m._EdgesOfDepartment2doctorinfo {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeEdgesOfHistorytaking:
		ids := make([]ent.Value, 0, len(m._EdgesOfHistorytaking))
		for id := range m._EdgesOfHistorytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_EdgesOfDepartment2doctorinfo != nil {
		edges = append(edges, department.EdgeEdgesOfDepartment2doctorinfo)
	}
	if m.removed_EdgesOfHistorytaking != nil {
		edges = append(edges, department.EdgeEdgesOfHistorytaking)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeEdgesOfDepartment2doctorinfo:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfDepartment2doctorinfo))
		for id := range m.removed_EdgesOfDepartment2doctorinfo {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeEdgesOfHistorytaking:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfHistorytaking))
		for id := range m.removed_EdgesOfHistorytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeEdgesOfDepartment2doctorinfo:
		m.ResetEdgesOfDepartment2doctorinfo()
		return nil
	case department.EdgeEdgesOfHistorytaking:
		m.ResetEdgesOfHistorytaking()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DoctorMutation represents an operation that mutate the Doctors
// nodes in the graph.
type DoctorMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	clearedFields             map[string]struct{}
	_EdgesOfDoctorinfo        *int
	cleared_EdgesOfDoctorinfo bool
	_EdgesOfUser              *int
	cleared_EdgesOfUser       bool
	_EdgesOfTreatment         map[int]struct{}
	removed_EdgesOfTreatment  map[int]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Doctor, error)
}

var _ ent.Mutation = (*DoctorMutation)(nil)

// doctorOption allows to manage the mutation configuration using functional options.
type doctorOption func(*DoctorMutation)

// newDoctorMutation creates new mutation for $n.Name.
func newDoctorMutation(c config, op Op, opts ...doctorOption) *DoctorMutation {
	m := &DoctorMutation{
		config:        c,
		op:            op,
		typ:           TypeDoctor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDoctorID sets the id field of the mutation.
func withDoctorID(id int) doctorOption {
	return func(m *DoctorMutation) {
		var (
			err   error
			once  sync.Once
			value *Doctor
		)
		m.oldValue = func(ctx context.Context) (*Doctor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Doctor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDoctor sets the old Doctor of the mutation.
func withDoctor(node *Doctor) doctorOption {
	return func(m *DoctorMutation) {
		m.oldValue = func(context.Context) (*Doctor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DoctorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DoctorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DoctorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEdgesOfDoctorinfoID sets the EdgesOfDoctorinfo edge to Doctorinfo by id.
func (m *DoctorMutation) SetEdgesOfDoctorinfoID(id int) {
	m._EdgesOfDoctorinfo = &id
}

// ClearEdgesOfDoctorinfo clears the EdgesOfDoctorinfo edge to Doctorinfo.
func (m *DoctorMutation) ClearEdgesOfDoctorinfo() {
	m.cleared_EdgesOfDoctorinfo = true
}

// EdgesOfDoctorinfoCleared returns if the edge EdgesOfDoctorinfo was cleared.
func (m *DoctorMutation) EdgesOfDoctorinfoCleared() bool {
	return m.cleared_EdgesOfDoctorinfo
}

// EdgesOfDoctorinfoID returns the EdgesOfDoctorinfo id in the mutation.
func (m *DoctorMutation) EdgesOfDoctorinfoID() (id int, exists bool) {
	if m._EdgesOfDoctorinfo != nil {
		return *m._EdgesOfDoctorinfo, true
	}
	return
}

// EdgesOfDoctorinfoIDs returns the EdgesOfDoctorinfo ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfDoctorinfoID instead. It exists only for internal usage by the builders.
func (m *DoctorMutation) EdgesOfDoctorinfoIDs() (ids []int) {
	if id := m._EdgesOfDoctorinfo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfDoctorinfo reset all changes of the "EdgesOfDoctorinfo" edge.
func (m *DoctorMutation) ResetEdgesOfDoctorinfo() {
	m._EdgesOfDoctorinfo = nil
	m.cleared_EdgesOfDoctorinfo = false
}

// SetEdgesOfUserID sets the EdgesOfUser edge to User by id.
func (m *DoctorMutation) SetEdgesOfUserID(id int) {
	m._EdgesOfUser = &id
}

// ClearEdgesOfUser clears the EdgesOfUser edge to User.
func (m *DoctorMutation) ClearEdgesOfUser() {
	m.cleared_EdgesOfUser = true
}

// EdgesOfUserCleared returns if the edge EdgesOfUser was cleared.
func (m *DoctorMutation) EdgesOfUserCleared() bool {
	return m.cleared_EdgesOfUser
}

// EdgesOfUserID returns the EdgesOfUser id in the mutation.
func (m *DoctorMutation) EdgesOfUserID() (id int, exists bool) {
	if m._EdgesOfUser != nil {
		return *m._EdgesOfUser, true
	}
	return
}

// EdgesOfUserIDs returns the EdgesOfUser ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfUserID instead. It exists only for internal usage by the builders.
func (m *DoctorMutation) EdgesOfUserIDs() (ids []int) {
	if id := m._EdgesOfUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfUser reset all changes of the "EdgesOfUser" edge.
func (m *DoctorMutation) ResetEdgesOfUser() {
	m._EdgesOfUser = nil
	m.cleared_EdgesOfUser = false
}

// AddEdgesOfTreatmentIDs adds the EdgesOfTreatment edge to Treatment by ids.
func (m *DoctorMutation) AddEdgesOfTreatmentIDs(ids ...int) {
	if m._EdgesOfTreatment == nil {
		m._EdgesOfTreatment = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfTreatment[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfTreatmentIDs removes the EdgesOfTreatment edge to Treatment by ids.
func (m *DoctorMutation) RemoveEdgesOfTreatmentIDs(ids ...int) {
	if m.removed_EdgesOfTreatment == nil {
		m.removed_EdgesOfTreatment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfTreatment[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfTreatment returns the removed ids of EdgesOfTreatment.
func (m *DoctorMutation) RemovedEdgesOfTreatmentIDs() (ids []int) {
	for id := range m.removed_EdgesOfTreatment {
		ids = append(ids, id)
	}
	return
}

// EdgesOfTreatmentIDs returns the EdgesOfTreatment ids in the mutation.
func (m *DoctorMutation) EdgesOfTreatmentIDs() (ids []int) {
	for id := range m._EdgesOfTreatment {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfTreatment reset all changes of the "EdgesOfTreatment" edge.
func (m *DoctorMutation) ResetEdgesOfTreatment() {
	m._EdgesOfTreatment = nil
	m.removed_EdgesOfTreatment = nil
}

// Op returns the operation name.
func (m *DoctorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Doctor).
func (m *DoctorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DoctorMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DoctorMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DoctorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Doctor field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DoctorMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DoctorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DoctorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DoctorMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Doctor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DoctorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DoctorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DoctorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Doctor nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DoctorMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DoctorMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._EdgesOfDoctorinfo != nil {
		edges = append(edges, doctor.EdgeEdgesOfDoctorinfo)
	}
	if m._EdgesOfUser != nil {
		edges = append(edges, doctor.EdgeEdgesOfUser)
	}
	if m._EdgesOfTreatment != nil {
		edges = append(edges, doctor.EdgeEdgesOfTreatment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DoctorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgeEdgesOfDoctorinfo:
		if id := m._EdgesOfDoctorinfo; id != nil {
			return []ent.Value{*id}
		}
	case doctor.EdgeEdgesOfUser:
		if id := m._EdgesOfUser; id != nil {
			return []ent.Value{*id}
		}
	case doctor.EdgeEdgesOfTreatment:
		ids := make([]ent.Value, 0, len(m._EdgesOfTreatment))
		for id := range m._EdgesOfTreatment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DoctorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_EdgesOfTreatment != nil {
		edges = append(edges, doctor.EdgeEdgesOfTreatment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DoctorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgeEdgesOfTreatment:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfTreatment))
		for id := range m.removed_EdgesOfTreatment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DoctorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_EdgesOfDoctorinfo {
		edges = append(edges, doctor.EdgeEdgesOfDoctorinfo)
	}
	if m.cleared_EdgesOfUser {
		edges = append(edges, doctor.EdgeEdgesOfUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DoctorMutation) EdgeCleared(name string) bool {
	switch name {
	case doctor.EdgeEdgesOfDoctorinfo:
		return m.cleared_EdgesOfDoctorinfo
	case doctor.EdgeEdgesOfUser:
		return m.cleared_EdgesOfUser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DoctorMutation) ClearEdge(name string) error {
	switch name {
	case doctor.EdgeEdgesOfDoctorinfo:
		m.ClearEdgesOfDoctorinfo()
		return nil
	case doctor.EdgeEdgesOfUser:
		m.ClearEdgesOfUser()
		return nil
	}
	return fmt.Errorf("unknown Doctor unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DoctorMutation) ResetEdge(name string) error {
	switch name {
	case doctor.EdgeEdgesOfDoctorinfo:
		m.ResetEdgesOfDoctorinfo()
		return nil
	case doctor.EdgeEdgesOfUser:
		m.ResetEdgesOfUser()
		return nil
	case doctor.EdgeEdgesOfTreatment:
		m.ResetEdgesOfTreatment()
		return nil
	}
	return fmt.Errorf("unknown Doctor edge %s", name)
}

// DoctorinfoMutation represents an operation that mutate the Doctorinfos
// nodes in the graph.
type DoctorinfoMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	doctorname                    *string
	doctorsurname                 *string
	telephonenumber               *string
	licensenumber                 *string
	clearedFields                 map[string]struct{}
	_EdgesOfDepartment            *int
	cleared_EdgesOfDepartment     bool
	_EdgesOfEducationlevel        *int
	cleared_EdgesOfEducationlevel bool
	_EdgesOfOfficeroom            *int
	cleared_EdgesOfOfficeroom     bool
	_EdgesOfPrename               *int
	cleared_EdgesOfPrename        bool
	_EdgesOfDoctor                *int
	cleared_EdgesOfDoctor         bool
	done                          bool
	oldValue                      func(context.Context) (*Doctorinfo, error)
}

var _ ent.Mutation = (*DoctorinfoMutation)(nil)

// doctorinfoOption allows to manage the mutation configuration using functional options.
type doctorinfoOption func(*DoctorinfoMutation)

// newDoctorinfoMutation creates new mutation for $n.Name.
func newDoctorinfoMutation(c config, op Op, opts ...doctorinfoOption) *DoctorinfoMutation {
	m := &DoctorinfoMutation{
		config:        c,
		op:            op,
		typ:           TypeDoctorinfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDoctorinfoID sets the id field of the mutation.
func withDoctorinfoID(id int) doctorinfoOption {
	return func(m *DoctorinfoMutation) {
		var (
			err   error
			once  sync.Once
			value *Doctorinfo
		)
		m.oldValue = func(ctx context.Context) (*Doctorinfo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Doctorinfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDoctorinfo sets the old Doctorinfo of the mutation.
func withDoctorinfo(node *Doctorinfo) doctorinfoOption {
	return func(m *DoctorinfoMutation) {
		m.oldValue = func(context.Context) (*Doctorinfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DoctorinfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DoctorinfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DoctorinfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDoctorname sets the doctorname field.
func (m *DoctorinfoMutation) SetDoctorname(s string) {
	m.doctorname = &s
}

// Doctorname returns the doctorname value in the mutation.
func (m *DoctorinfoMutation) Doctorname() (r string, exists bool) {
	v := m.doctorname
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorname returns the old doctorname value of the Doctorinfo.
// If the Doctorinfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorinfoMutation) OldDoctorname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctorname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctorname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorname: %w", err)
	}
	return oldValue.Doctorname, nil
}

// ResetDoctorname reset all changes of the "doctorname" field.
func (m *DoctorinfoMutation) ResetDoctorname() {
	m.doctorname = nil
}

// SetDoctorsurname sets the doctorsurname field.
func (m *DoctorinfoMutation) SetDoctorsurname(s string) {
	m.doctorsurname = &s
}

// Doctorsurname returns the doctorsurname value in the mutation.
func (m *DoctorinfoMutation) Doctorsurname() (r string, exists bool) {
	v := m.doctorsurname
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorsurname returns the old doctorsurname value of the Doctorinfo.
// If the Doctorinfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorinfoMutation) OldDoctorsurname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctorsurname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctorsurname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorsurname: %w", err)
	}
	return oldValue.Doctorsurname, nil
}

// ResetDoctorsurname reset all changes of the "doctorsurname" field.
func (m *DoctorinfoMutation) ResetDoctorsurname() {
	m.doctorsurname = nil
}

// SetTelephonenumber sets the telephonenumber field.
func (m *DoctorinfoMutation) SetTelephonenumber(s string) {
	m.telephonenumber = &s
}

// Telephonenumber returns the telephonenumber value in the mutation.
func (m *DoctorinfoMutation) Telephonenumber() (r string, exists bool) {
	v := m.telephonenumber
	if v == nil {
		return
	}
	return *v, true
}

// OldTelephonenumber returns the old telephonenumber value of the Doctorinfo.
// If the Doctorinfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorinfoMutation) OldTelephonenumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTelephonenumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTelephonenumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelephonenumber: %w", err)
	}
	return oldValue.Telephonenumber, nil
}

// ResetTelephonenumber reset all changes of the "telephonenumber" field.
func (m *DoctorinfoMutation) ResetTelephonenumber() {
	m.telephonenumber = nil
}

// SetLicensenumber sets the licensenumber field.
func (m *DoctorinfoMutation) SetLicensenumber(s string) {
	m.licensenumber = &s
}

// Licensenumber returns the licensenumber value in the mutation.
func (m *DoctorinfoMutation) Licensenumber() (r string, exists bool) {
	v := m.licensenumber
	if v == nil {
		return
	}
	return *v, true
}

// OldLicensenumber returns the old licensenumber value of the Doctorinfo.
// If the Doctorinfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorinfoMutation) OldLicensenumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLicensenumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLicensenumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicensenumber: %w", err)
	}
	return oldValue.Licensenumber, nil
}

// ResetLicensenumber reset all changes of the "licensenumber" field.
func (m *DoctorinfoMutation) ResetLicensenumber() {
	m.licensenumber = nil
}

// SetEdgesOfDepartmentID sets the EdgesOfDepartment edge to Department by id.
func (m *DoctorinfoMutation) SetEdgesOfDepartmentID(id int) {
	m._EdgesOfDepartment = &id
}

// ClearEdgesOfDepartment clears the EdgesOfDepartment edge to Department.
func (m *DoctorinfoMutation) ClearEdgesOfDepartment() {
	m.cleared_EdgesOfDepartment = true
}

// EdgesOfDepartmentCleared returns if the edge EdgesOfDepartment was cleared.
func (m *DoctorinfoMutation) EdgesOfDepartmentCleared() bool {
	return m.cleared_EdgesOfDepartment
}

// EdgesOfDepartmentID returns the EdgesOfDepartment id in the mutation.
func (m *DoctorinfoMutation) EdgesOfDepartmentID() (id int, exists bool) {
	if m._EdgesOfDepartment != nil {
		return *m._EdgesOfDepartment, true
	}
	return
}

// EdgesOfDepartmentIDs returns the EdgesOfDepartment ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfDepartmentID instead. It exists only for internal usage by the builders.
func (m *DoctorinfoMutation) EdgesOfDepartmentIDs() (ids []int) {
	if id := m._EdgesOfDepartment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfDepartment reset all changes of the "EdgesOfDepartment" edge.
func (m *DoctorinfoMutation) ResetEdgesOfDepartment() {
	m._EdgesOfDepartment = nil
	m.cleared_EdgesOfDepartment = false
}

// SetEdgesOfEducationlevelID sets the EdgesOfEducationlevel edge to Educationlevel by id.
func (m *DoctorinfoMutation) SetEdgesOfEducationlevelID(id int) {
	m._EdgesOfEducationlevel = &id
}

// ClearEdgesOfEducationlevel clears the EdgesOfEducationlevel edge to Educationlevel.
func (m *DoctorinfoMutation) ClearEdgesOfEducationlevel() {
	m.cleared_EdgesOfEducationlevel = true
}

// EdgesOfEducationlevelCleared returns if the edge EdgesOfEducationlevel was cleared.
func (m *DoctorinfoMutation) EdgesOfEducationlevelCleared() bool {
	return m.cleared_EdgesOfEducationlevel
}

// EdgesOfEducationlevelID returns the EdgesOfEducationlevel id in the mutation.
func (m *DoctorinfoMutation) EdgesOfEducationlevelID() (id int, exists bool) {
	if m._EdgesOfEducationlevel != nil {
		return *m._EdgesOfEducationlevel, true
	}
	return
}

// EdgesOfEducationlevelIDs returns the EdgesOfEducationlevel ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfEducationlevelID instead. It exists only for internal usage by the builders.
func (m *DoctorinfoMutation) EdgesOfEducationlevelIDs() (ids []int) {
	if id := m._EdgesOfEducationlevel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfEducationlevel reset all changes of the "EdgesOfEducationlevel" edge.
func (m *DoctorinfoMutation) ResetEdgesOfEducationlevel() {
	m._EdgesOfEducationlevel = nil
	m.cleared_EdgesOfEducationlevel = false
}

// SetEdgesOfOfficeroomID sets the EdgesOfOfficeroom edge to Officeroom by id.
func (m *DoctorinfoMutation) SetEdgesOfOfficeroomID(id int) {
	m._EdgesOfOfficeroom = &id
}

// ClearEdgesOfOfficeroom clears the EdgesOfOfficeroom edge to Officeroom.
func (m *DoctorinfoMutation) ClearEdgesOfOfficeroom() {
	m.cleared_EdgesOfOfficeroom = true
}

// EdgesOfOfficeroomCleared returns if the edge EdgesOfOfficeroom was cleared.
func (m *DoctorinfoMutation) EdgesOfOfficeroomCleared() bool {
	return m.cleared_EdgesOfOfficeroom
}

// EdgesOfOfficeroomID returns the EdgesOfOfficeroom id in the mutation.
func (m *DoctorinfoMutation) EdgesOfOfficeroomID() (id int, exists bool) {
	if m._EdgesOfOfficeroom != nil {
		return *m._EdgesOfOfficeroom, true
	}
	return
}

// EdgesOfOfficeroomIDs returns the EdgesOfOfficeroom ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfOfficeroomID instead. It exists only for internal usage by the builders.
func (m *DoctorinfoMutation) EdgesOfOfficeroomIDs() (ids []int) {
	if id := m._EdgesOfOfficeroom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfOfficeroom reset all changes of the "EdgesOfOfficeroom" edge.
func (m *DoctorinfoMutation) ResetEdgesOfOfficeroom() {
	m._EdgesOfOfficeroom = nil
	m.cleared_EdgesOfOfficeroom = false
}

// SetEdgesOfPrenameID sets the EdgesOfPrename edge to Prename by id.
func (m *DoctorinfoMutation) SetEdgesOfPrenameID(id int) {
	m._EdgesOfPrename = &id
}

// ClearEdgesOfPrename clears the EdgesOfPrename edge to Prename.
func (m *DoctorinfoMutation) ClearEdgesOfPrename() {
	m.cleared_EdgesOfPrename = true
}

// EdgesOfPrenameCleared returns if the edge EdgesOfPrename was cleared.
func (m *DoctorinfoMutation) EdgesOfPrenameCleared() bool {
	return m.cleared_EdgesOfPrename
}

// EdgesOfPrenameID returns the EdgesOfPrename id in the mutation.
func (m *DoctorinfoMutation) EdgesOfPrenameID() (id int, exists bool) {
	if m._EdgesOfPrename != nil {
		return *m._EdgesOfPrename, true
	}
	return
}

// EdgesOfPrenameIDs returns the EdgesOfPrename ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfPrenameID instead. It exists only for internal usage by the builders.
func (m *DoctorinfoMutation) EdgesOfPrenameIDs() (ids []int) {
	if id := m._EdgesOfPrename; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfPrename reset all changes of the "EdgesOfPrename" edge.
func (m *DoctorinfoMutation) ResetEdgesOfPrename() {
	m._EdgesOfPrename = nil
	m.cleared_EdgesOfPrename = false
}

// SetEdgesOfDoctorID sets the EdgesOfDoctor edge to Doctor by id.
func (m *DoctorinfoMutation) SetEdgesOfDoctorID(id int) {
	m._EdgesOfDoctor = &id
}

// ClearEdgesOfDoctor clears the EdgesOfDoctor edge to Doctor.
func (m *DoctorinfoMutation) ClearEdgesOfDoctor() {
	m.cleared_EdgesOfDoctor = true
}

// EdgesOfDoctorCleared returns if the edge EdgesOfDoctor was cleared.
func (m *DoctorinfoMutation) EdgesOfDoctorCleared() bool {
	return m.cleared_EdgesOfDoctor
}

// EdgesOfDoctorID returns the EdgesOfDoctor id in the mutation.
func (m *DoctorinfoMutation) EdgesOfDoctorID() (id int, exists bool) {
	if m._EdgesOfDoctor != nil {
		return *m._EdgesOfDoctor, true
	}
	return
}

// EdgesOfDoctorIDs returns the EdgesOfDoctor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfDoctorID instead. It exists only for internal usage by the builders.
func (m *DoctorinfoMutation) EdgesOfDoctorIDs() (ids []int) {
	if id := m._EdgesOfDoctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfDoctor reset all changes of the "EdgesOfDoctor" edge.
func (m *DoctorinfoMutation) ResetEdgesOfDoctor() {
	m._EdgesOfDoctor = nil
	m.cleared_EdgesOfDoctor = false
}

// Op returns the operation name.
func (m *DoctorinfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Doctorinfo).
func (m *DoctorinfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DoctorinfoMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.doctorname != nil {
		fields = append(fields, doctorinfo.FieldDoctorname)
	}
	if m.doctorsurname != nil {
		fields = append(fields, doctorinfo.FieldDoctorsurname)
	}
	if m.telephonenumber != nil {
		fields = append(fields, doctorinfo.FieldTelephonenumber)
	}
	if m.licensenumber != nil {
		fields = append(fields, doctorinfo.FieldLicensenumber)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DoctorinfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case doctorinfo.FieldDoctorname:
		return m.Doctorname()
	case doctorinfo.FieldDoctorsurname:
		return m.Doctorsurname()
	case doctorinfo.FieldTelephonenumber:
		return m.Telephonenumber()
	case doctorinfo.FieldLicensenumber:
		return m.Licensenumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DoctorinfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case doctorinfo.FieldDoctorname:
		return m.OldDoctorname(ctx)
	case doctorinfo.FieldDoctorsurname:
		return m.OldDoctorsurname(ctx)
	case doctorinfo.FieldTelephonenumber:
		return m.OldTelephonenumber(ctx)
	case doctorinfo.FieldLicensenumber:
		return m.OldLicensenumber(ctx)
	}
	return nil, fmt.Errorf("unknown Doctorinfo field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DoctorinfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case doctorinfo.FieldDoctorname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorname(v)
		return nil
	case doctorinfo.FieldDoctorsurname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorsurname(v)
		return nil
	case doctorinfo.FieldTelephonenumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelephonenumber(v)
		return nil
	case doctorinfo.FieldLicensenumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicensenumber(v)
		return nil
	}
	return fmt.Errorf("unknown Doctorinfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DoctorinfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DoctorinfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DoctorinfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Doctorinfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DoctorinfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DoctorinfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DoctorinfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Doctorinfo nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DoctorinfoMutation) ResetField(name string) error {
	switch name {
	case doctorinfo.FieldDoctorname:
		m.ResetDoctorname()
		return nil
	case doctorinfo.FieldDoctorsurname:
		m.ResetDoctorsurname()
		return nil
	case doctorinfo.FieldTelephonenumber:
		m.ResetTelephonenumber()
		return nil
	case doctorinfo.FieldLicensenumber:
		m.ResetLicensenumber()
		return nil
	}
	return fmt.Errorf("unknown Doctorinfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DoctorinfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m._EdgesOfDepartment != nil {
		edges = append(edges, doctorinfo.EdgeEdgesOfDepartment)
	}
	if m._EdgesOfEducationlevel != nil {
		edges = append(edges, doctorinfo.EdgeEdgesOfEducationlevel)
	}
	if m._EdgesOfOfficeroom != nil {
		edges = append(edges, doctorinfo.EdgeEdgesOfOfficeroom)
	}
	if m._EdgesOfPrename != nil {
		edges = append(edges, doctorinfo.EdgeEdgesOfPrename)
	}
	if m._EdgesOfDoctor != nil {
		edges = append(edges, doctorinfo.EdgeEdgesOfDoctor)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DoctorinfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case doctorinfo.EdgeEdgesOfDepartment:
		if id := m._EdgesOfDepartment; id != nil {
			return []ent.Value{*id}
		}
	case doctorinfo.EdgeEdgesOfEducationlevel:
		if id := m._EdgesOfEducationlevel; id != nil {
			return []ent.Value{*id}
		}
	case doctorinfo.EdgeEdgesOfOfficeroom:
		if id := m._EdgesOfOfficeroom; id != nil {
			return []ent.Value{*id}
		}
	case doctorinfo.EdgeEdgesOfPrename:
		if id := m._EdgesOfPrename; id != nil {
			return []ent.Value{*id}
		}
	case doctorinfo.EdgeEdgesOfDoctor:
		if id := m._EdgesOfDoctor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DoctorinfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DoctorinfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DoctorinfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleared_EdgesOfDepartment {
		edges = append(edges, doctorinfo.EdgeEdgesOfDepartment)
	}
	if m.cleared_EdgesOfEducationlevel {
		edges = append(edges, doctorinfo.EdgeEdgesOfEducationlevel)
	}
	if m.cleared_EdgesOfOfficeroom {
		edges = append(edges, doctorinfo.EdgeEdgesOfOfficeroom)
	}
	if m.cleared_EdgesOfPrename {
		edges = append(edges, doctorinfo.EdgeEdgesOfPrename)
	}
	if m.cleared_EdgesOfDoctor {
		edges = append(edges, doctorinfo.EdgeEdgesOfDoctor)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DoctorinfoMutation) EdgeCleared(name string) bool {
	switch name {
	case doctorinfo.EdgeEdgesOfDepartment:
		return m.cleared_EdgesOfDepartment
	case doctorinfo.EdgeEdgesOfEducationlevel:
		return m.cleared_EdgesOfEducationlevel
	case doctorinfo.EdgeEdgesOfOfficeroom:
		return m.cleared_EdgesOfOfficeroom
	case doctorinfo.EdgeEdgesOfPrename:
		return m.cleared_EdgesOfPrename
	case doctorinfo.EdgeEdgesOfDoctor:
		return m.cleared_EdgesOfDoctor
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DoctorinfoMutation) ClearEdge(name string) error {
	switch name {
	case doctorinfo.EdgeEdgesOfDepartment:
		m.ClearEdgesOfDepartment()
		return nil
	case doctorinfo.EdgeEdgesOfEducationlevel:
		m.ClearEdgesOfEducationlevel()
		return nil
	case doctorinfo.EdgeEdgesOfOfficeroom:
		m.ClearEdgesOfOfficeroom()
		return nil
	case doctorinfo.EdgeEdgesOfPrename:
		m.ClearEdgesOfPrename()
		return nil
	case doctorinfo.EdgeEdgesOfDoctor:
		m.ClearEdgesOfDoctor()
		return nil
	}
	return fmt.Errorf("unknown Doctorinfo unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DoctorinfoMutation) ResetEdge(name string) error {
	switch name {
	case doctorinfo.EdgeEdgesOfDepartment:
		m.ResetEdgesOfDepartment()
		return nil
	case doctorinfo.EdgeEdgesOfEducationlevel:
		m.ResetEdgesOfEducationlevel()
		return nil
	case doctorinfo.EdgeEdgesOfOfficeroom:
		m.ResetEdgesOfOfficeroom()
		return nil
	case doctorinfo.EdgeEdgesOfPrename:
		m.ResetEdgesOfPrename()
		return nil
	case doctorinfo.EdgeEdgesOfDoctor:
		m.ResetEdgesOfDoctor()
		return nil
	}
	return fmt.Errorf("unknown Doctorinfo edge %s", name)
}

// EducationlevelMutation represents an operation that mutate the Educationlevels
// nodes in the graph.
type EducationlevelMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *int
	level                                    *string
	clearedFields                            map[string]struct{}
	_EdgesOfEducationlevel2doctorinfo        map[int]struct{}
	removed_EdgesOfEducationlevel2doctorinfo map[int]struct{}
	done                                     bool
	oldValue                                 func(context.Context) (*Educationlevel, error)
}

var _ ent.Mutation = (*EducationlevelMutation)(nil)

// educationlevelOption allows to manage the mutation configuration using functional options.
type educationlevelOption func(*EducationlevelMutation)

// newEducationlevelMutation creates new mutation for $n.Name.
func newEducationlevelMutation(c config, op Op, opts ...educationlevelOption) *EducationlevelMutation {
	m := &EducationlevelMutation{
		config:        c,
		op:            op,
		typ:           TypeEducationlevel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEducationlevelID sets the id field of the mutation.
func withEducationlevelID(id int) educationlevelOption {
	return func(m *EducationlevelMutation) {
		var (
			err   error
			once  sync.Once
			value *Educationlevel
		)
		m.oldValue = func(ctx context.Context) (*Educationlevel, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Educationlevel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEducationlevel sets the old Educationlevel of the mutation.
func withEducationlevel(node *Educationlevel) educationlevelOption {
	return func(m *EducationlevelMutation) {
		m.oldValue = func(context.Context) (*Educationlevel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EducationlevelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EducationlevelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EducationlevelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLevel sets the level field.
func (m *EducationlevelMutation) SetLevel(s string) {
	m.level = &s
}

// Level returns the level value in the mutation.
func (m *EducationlevelMutation) Level() (r string, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old level value of the Educationlevel.
// If the Educationlevel object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EducationlevelMutation) OldLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLevel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel reset all changes of the "level" field.
func (m *EducationlevelMutation) ResetLevel() {
	m.level = nil
}

// AddEdgesOfEducationlevel2doctorinfoIDs adds the EdgesOfEducationlevel2doctorinfo edge to Doctorinfo by ids.
func (m *EducationlevelMutation) AddEdgesOfEducationlevel2doctorinfoIDs(ids ...int) {
	if m._EdgesOfEducationlevel2doctorinfo == nil {
		m._EdgesOfEducationlevel2doctorinfo = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfEducationlevel2doctorinfo[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfEducationlevel2doctorinfoIDs removes the EdgesOfEducationlevel2doctorinfo edge to Doctorinfo by ids.
func (m *EducationlevelMutation) RemoveEdgesOfEducationlevel2doctorinfoIDs(ids ...int) {
	if m.removed_EdgesOfEducationlevel2doctorinfo == nil {
		m.removed_EdgesOfEducationlevel2doctorinfo = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfEducationlevel2doctorinfo[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfEducationlevel2doctorinfo returns the removed ids of EdgesOfEducationlevel2doctorinfo.
func (m *EducationlevelMutation) RemovedEdgesOfEducationlevel2doctorinfoIDs() (ids []int) {
	for id := range m.removed_EdgesOfEducationlevel2doctorinfo {
		ids = append(ids, id)
	}
	return
}

// EdgesOfEducationlevel2doctorinfoIDs returns the EdgesOfEducationlevel2doctorinfo ids in the mutation.
func (m *EducationlevelMutation) EdgesOfEducationlevel2doctorinfoIDs() (ids []int) {
	for id := range m._EdgesOfEducationlevel2doctorinfo {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfEducationlevel2doctorinfo reset all changes of the "EdgesOfEducationlevel2doctorinfo" edge.
func (m *EducationlevelMutation) ResetEdgesOfEducationlevel2doctorinfo() {
	m._EdgesOfEducationlevel2doctorinfo = nil
	m.removed_EdgesOfEducationlevel2doctorinfo = nil
}

// Op returns the operation name.
func (m *EducationlevelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Educationlevel).
func (m *EducationlevelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EducationlevelMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.level != nil {
		fields = append(fields, educationlevel.FieldLevel)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EducationlevelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case educationlevel.FieldLevel:
		return m.Level()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EducationlevelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case educationlevel.FieldLevel:
		return m.OldLevel(ctx)
	}
	return nil, fmt.Errorf("unknown Educationlevel field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EducationlevelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case educationlevel.FieldLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Educationlevel field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EducationlevelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EducationlevelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EducationlevelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Educationlevel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EducationlevelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EducationlevelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EducationlevelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Educationlevel nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EducationlevelMutation) ResetField(name string) error {
	switch name {
	case educationlevel.FieldLevel:
		m.ResetLevel()
		return nil
	}
	return fmt.Errorf("unknown Educationlevel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EducationlevelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._EdgesOfEducationlevel2doctorinfo != nil {
		edges = append(edges, educationlevel.EdgeEdgesOfEducationlevel2doctorinfo)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EducationlevelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case educationlevel.EdgeEdgesOfEducationlevel2doctorinfo:
		ids := make([]ent.Value, 0, len(m._EdgesOfEducationlevel2doctorinfo))
		for id := range m._EdgesOfEducationlevel2doctorinfo {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EducationlevelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_EdgesOfEducationlevel2doctorinfo != nil {
		edges = append(edges, educationlevel.EdgeEdgesOfEducationlevel2doctorinfo)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EducationlevelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case educationlevel.EdgeEdgesOfEducationlevel2doctorinfo:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfEducationlevel2doctorinfo))
		for id := range m.removed_EdgesOfEducationlevel2doctorinfo {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EducationlevelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EducationlevelMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EducationlevelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Educationlevel unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EducationlevelMutation) ResetEdge(name string) error {
	switch name {
	case educationlevel.EdgeEdgesOfEducationlevel2doctorinfo:
		m.ResetEdgesOfEducationlevel2doctorinfo()
		return nil
	}
	return fmt.Errorf("unknown Educationlevel edge %s", name)
}

// FinancierMutation represents an operation that mutate the Financiers
// nodes in the graph.
type FinancierMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	clearedFields        map[string]struct{}
	_EdgesOfBills        map[int]struct{}
	removed_EdgesOfBills map[int]struct{}
	_EdgesOfUser         *int
	cleared_EdgesOfUser  bool
	done                 bool
	oldValue             func(context.Context) (*Financier, error)
}

var _ ent.Mutation = (*FinancierMutation)(nil)

// financierOption allows to manage the mutation configuration using functional options.
type financierOption func(*FinancierMutation)

// newFinancierMutation creates new mutation for $n.Name.
func newFinancierMutation(c config, op Op, opts ...financierOption) *FinancierMutation {
	m := &FinancierMutation{
		config:        c,
		op:            op,
		typ:           TypeFinancier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFinancierID sets the id field of the mutation.
func withFinancierID(id int) financierOption {
	return func(m *FinancierMutation) {
		var (
			err   error
			once  sync.Once
			value *Financier
		)
		m.oldValue = func(ctx context.Context) (*Financier, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Financier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFinancier sets the old Financier of the mutation.
func withFinancier(node *Financier) financierOption {
	return func(m *FinancierMutation) {
		m.oldValue = func(context.Context) (*Financier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FinancierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FinancierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FinancierMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *FinancierMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *FinancierMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Financier.
// If the Financier object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FinancierMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *FinancierMutation) ResetName() {
	m.name = nil
}

// AddEdgesOfBillIDs adds the EdgesOfBills edge to Bill by ids.
func (m *FinancierMutation) AddEdgesOfBillIDs(ids ...int) {
	if m._EdgesOfBills == nil {
		m._EdgesOfBills = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfBills[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfBillIDs removes the EdgesOfBills edge to Bill by ids.
func (m *FinancierMutation) RemoveEdgesOfBillIDs(ids ...int) {
	if m.removed_EdgesOfBills == nil {
		m.removed_EdgesOfBills = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfBills[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfBills returns the removed ids of EdgesOfBills.
func (m *FinancierMutation) RemovedEdgesOfBillsIDs() (ids []int) {
	for id := range m.removed_EdgesOfBills {
		ids = append(ids, id)
	}
	return
}

// EdgesOfBillsIDs returns the EdgesOfBills ids in the mutation.
func (m *FinancierMutation) EdgesOfBillsIDs() (ids []int) {
	for id := range m._EdgesOfBills {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfBills reset all changes of the "EdgesOfBills" edge.
func (m *FinancierMutation) ResetEdgesOfBills() {
	m._EdgesOfBills = nil
	m.removed_EdgesOfBills = nil
}

// SetEdgesOfUserID sets the EdgesOfUser edge to User by id.
func (m *FinancierMutation) SetEdgesOfUserID(id int) {
	m._EdgesOfUser = &id
}

// ClearEdgesOfUser clears the EdgesOfUser edge to User.
func (m *FinancierMutation) ClearEdgesOfUser() {
	m.cleared_EdgesOfUser = true
}

// EdgesOfUserCleared returns if the edge EdgesOfUser was cleared.
func (m *FinancierMutation) EdgesOfUserCleared() bool {
	return m.cleared_EdgesOfUser
}

// EdgesOfUserID returns the EdgesOfUser id in the mutation.
func (m *FinancierMutation) EdgesOfUserID() (id int, exists bool) {
	if m._EdgesOfUser != nil {
		return *m._EdgesOfUser, true
	}
	return
}

// EdgesOfUserIDs returns the EdgesOfUser ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfUserID instead. It exists only for internal usage by the builders.
func (m *FinancierMutation) EdgesOfUserIDs() (ids []int) {
	if id := m._EdgesOfUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfUser reset all changes of the "EdgesOfUser" edge.
func (m *FinancierMutation) ResetEdgesOfUser() {
	m._EdgesOfUser = nil
	m.cleared_EdgesOfUser = false
}

// Op returns the operation name.
func (m *FinancierMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Financier).
func (m *FinancierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FinancierMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, financier.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FinancierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case financier.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FinancierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case financier.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Financier field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FinancierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case financier.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Financier field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FinancierMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FinancierMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FinancierMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Financier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FinancierMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FinancierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FinancierMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Financier nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FinancierMutation) ResetField(name string) error {
	switch name {
	case financier.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Financier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FinancierMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._EdgesOfBills != nil {
		edges = append(edges, financier.EdgeEdgesOfBills)
	}
	if m._EdgesOfUser != nil {
		edges = append(edges, financier.EdgeEdgesOfUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FinancierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case financier.EdgeEdgesOfBills:
		ids := make([]ent.Value, 0, len(m._EdgesOfBills))
		for id := range m._EdgesOfBills {
			ids = append(ids, id)
		}
		return ids
	case financier.EdgeEdgesOfUser:
		if id := m._EdgesOfUser; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FinancierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_EdgesOfBills != nil {
		edges = append(edges, financier.EdgeEdgesOfBills)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FinancierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case financier.EdgeEdgesOfBills:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfBills))
		for id := range m.removed_EdgesOfBills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FinancierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_EdgesOfUser {
		edges = append(edges, financier.EdgeEdgesOfUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FinancierMutation) EdgeCleared(name string) bool {
	switch name {
	case financier.EdgeEdgesOfUser:
		return m.cleared_EdgesOfUser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FinancierMutation) ClearEdge(name string) error {
	switch name {
	case financier.EdgeEdgesOfUser:
		m.ClearEdgesOfUser()
		return nil
	}
	return fmt.Errorf("unknown Financier unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FinancierMutation) ResetEdge(name string) error {
	switch name {
	case financier.EdgeEdgesOfBills:
		m.ResetEdgesOfBills()
		return nil
	case financier.EdgeEdgesOfUser:
		m.ResetEdgesOfUser()
		return nil
	}
	return fmt.Errorf("unknown Financier edge %s", name)
}

// GenderMutation represents an operation that mutate the Genders
// nodes in the graph.
type GenderMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	_Genderstatus                *string
	clearedFields                map[string]struct{}
	_EdgesOfPatientrecord        map[int]struct{}
	removed_EdgesOfPatientrecord map[int]struct{}
	done                         bool
	oldValue                     func(context.Context) (*Gender, error)
}

var _ ent.Mutation = (*GenderMutation)(nil)

// genderOption allows to manage the mutation configuration using functional options.
type genderOption func(*GenderMutation)

// newGenderMutation creates new mutation for $n.Name.
func newGenderMutation(c config, op Op, opts ...genderOption) *GenderMutation {
	m := &GenderMutation{
		config:        c,
		op:            op,
		typ:           TypeGender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenderID sets the id field of the mutation.
func withGenderID(id int) genderOption {
	return func(m *GenderMutation) {
		var (
			err   error
			once  sync.Once
			value *Gender
		)
		m.oldValue = func(ctx context.Context) (*Gender, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGender sets the old Gender of the mutation.
func withGender(node *Gender) genderOption {
	return func(m *GenderMutation) {
		m.oldValue = func(context.Context) (*Gender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *GenderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGenderstatus sets the Genderstatus field.
func (m *GenderMutation) SetGenderstatus(s string) {
	m._Genderstatus = &s
}

// Genderstatus returns the Genderstatus value in the mutation.
func (m *GenderMutation) Genderstatus() (r string, exists bool) {
	v := m._Genderstatus
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderstatus returns the old Genderstatus value of the Gender.
// If the Gender object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *GenderMutation) OldGenderstatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGenderstatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGenderstatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderstatus: %w", err)
	}
	return oldValue.Genderstatus, nil
}

// ResetGenderstatus reset all changes of the "Genderstatus" field.
func (m *GenderMutation) ResetGenderstatus() {
	m._Genderstatus = nil
}

// AddEdgesOfPatientrecordIDs adds the EdgesOfPatientrecord edge to Patientrecord by ids.
func (m *GenderMutation) AddEdgesOfPatientrecordIDs(ids ...int) {
	if m._EdgesOfPatientrecord == nil {
		m._EdgesOfPatientrecord = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfPatientrecord[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfPatientrecordIDs removes the EdgesOfPatientrecord edge to Patientrecord by ids.
func (m *GenderMutation) RemoveEdgesOfPatientrecordIDs(ids ...int) {
	if m.removed_EdgesOfPatientrecord == nil {
		m.removed_EdgesOfPatientrecord = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfPatientrecord[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfPatientrecord returns the removed ids of EdgesOfPatientrecord.
func (m *GenderMutation) RemovedEdgesOfPatientrecordIDs() (ids []int) {
	for id := range m.removed_EdgesOfPatientrecord {
		ids = append(ids, id)
	}
	return
}

// EdgesOfPatientrecordIDs returns the EdgesOfPatientrecord ids in the mutation.
func (m *GenderMutation) EdgesOfPatientrecordIDs() (ids []int) {
	for id := range m._EdgesOfPatientrecord {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfPatientrecord reset all changes of the "EdgesOfPatientrecord" edge.
func (m *GenderMutation) ResetEdgesOfPatientrecord() {
	m._EdgesOfPatientrecord = nil
	m.removed_EdgesOfPatientrecord = nil
}

// Op returns the operation name.
func (m *GenderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Gender).
func (m *GenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *GenderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Genderstatus != nil {
		fields = append(fields, gender.FieldGenderstatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *GenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gender.FieldGenderstatus:
		return m.Genderstatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *GenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gender.FieldGenderstatus:
		return m.OldGenderstatus(ctx)
	}
	return nil, fmt.Errorf("unknown Gender field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gender.FieldGenderstatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderstatus(v)
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *GenderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *GenderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *GenderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *GenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Gender nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *GenderMutation) ResetField(name string) error {
	switch name {
	case gender.FieldGenderstatus:
		m.ResetGenderstatus()
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *GenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._EdgesOfPatientrecord != nil {
		edges = append(edges, gender.EdgeEdgesOfPatientrecord)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *GenderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgeEdgesOfPatientrecord:
		ids := make([]ent.Value, 0, len(m._EdgesOfPatientrecord))
		for id := range m._EdgesOfPatientrecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *GenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_EdgesOfPatientrecord != nil {
		edges = append(edges, gender.EdgeEdgesOfPatientrecord)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *GenderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgeEdgesOfPatientrecord:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfPatientrecord))
		for id := range m.removed_EdgesOfPatientrecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *GenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *GenderMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *GenderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *GenderMutation) ResetEdge(name string) error {
	switch name {
	case gender.EdgeEdgesOfPatientrecord:
		m.ResetEdgesOfPatientrecord()
		return nil
	}
	return fmt.Errorf("unknown Gender edge %s", name)
}

// HistorytakingMutation represents an operation that mutate the Historytakings
// nodes in the graph.
type HistorytakingMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	hight                          *float32
	addhight                       *float32
	weight                         *float32
	addweight                      *float32
	temp                           *float32
	addtemp                        *float32
	pulse                          *int
	addpulse                       *int
	respiration                    *int
	addrespiration                 *int
	bp                             *int
	addbp                          *int
	oxygen                         *string
	symptom                        *string
	datetime                       *time.Time
	clearedFields                  map[string]struct{}
	_EdgesOfNurse                  *int
	cleared_EdgesOfNurse           bool
	_EdgesOfDepartment             *int
	cleared_EdgesOfDepartment      bool
	_EdgesOfSymptomseverity        *int
	cleared_EdgesOfSymptomseverity bool
	_EdgesOfPatientrecord          *int
	cleared_EdgesOfPatientrecord   bool
	done                           bool
	oldValue                       func(context.Context) (*Historytaking, error)
}

var _ ent.Mutation = (*HistorytakingMutation)(nil)

// historytakingOption allows to manage the mutation configuration using functional options.
type historytakingOption func(*HistorytakingMutation)

// newHistorytakingMutation creates new mutation for $n.Name.
func newHistorytakingMutation(c config, op Op, opts ...historytakingOption) *HistorytakingMutation {
	m := &HistorytakingMutation{
		config:        c,
		op:            op,
		typ:           TypeHistorytaking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHistorytakingID sets the id field of the mutation.
func withHistorytakingID(id int) historytakingOption {
	return func(m *HistorytakingMutation) {
		var (
			err   error
			once  sync.Once
			value *Historytaking
		)
		m.oldValue = func(ctx context.Context) (*Historytaking, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Historytaking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHistorytaking sets the old Historytaking of the mutation.
func withHistorytaking(node *Historytaking) historytakingOption {
	return func(m *HistorytakingMutation) {
		m.oldValue = func(context.Context) (*Historytaking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HistorytakingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HistorytakingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *HistorytakingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHight sets the hight field.
func (m *HistorytakingMutation) SetHight(f float32) {
	m.hight = &f
	m.addhight = nil
}

// Hight returns the hight value in the mutation.
func (m *HistorytakingMutation) Hight() (r float32, exists bool) {
	v := m.hight
	if v == nil {
		return
	}
	return *v, true
}

// OldHight returns the old hight value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldHight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHight: %w", err)
	}
	return oldValue.Hight, nil
}

// AddHight adds f to hight.
func (m *HistorytakingMutation) AddHight(f float32) {
	if m.addhight != nil {
		*m.addhight += f
	} else {
		m.addhight = &f
	}
}

// AddedHight returns the value that was added to the hight field in this mutation.
func (m *HistorytakingMutation) AddedHight() (r float32, exists bool) {
	v := m.addhight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHight reset all changes of the "hight" field.
func (m *HistorytakingMutation) ResetHight() {
	m.hight = nil
	m.addhight = nil
}

// SetWeight sets the weight field.
func (m *HistorytakingMutation) SetWeight(f float32) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the weight value in the mutation.
func (m *HistorytakingMutation) Weight() (r float32, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old weight value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to weight.
func (m *HistorytakingMutation) AddWeight(f float32) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the weight field in this mutation.
func (m *HistorytakingMutation) AddedWeight() (r float32, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight reset all changes of the "weight" field.
func (m *HistorytakingMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetTemp sets the temp field.
func (m *HistorytakingMutation) SetTemp(f float32) {
	m.temp = &f
	m.addtemp = nil
}

// Temp returns the temp value in the mutation.
func (m *HistorytakingMutation) Temp() (r float32, exists bool) {
	v := m.temp
	if v == nil {
		return
	}
	return *v, true
}

// OldTemp returns the old temp value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldTemp(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTemp is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemp: %w", err)
	}
	return oldValue.Temp, nil
}

// AddTemp adds f to temp.
func (m *HistorytakingMutation) AddTemp(f float32) {
	if m.addtemp != nil {
		*m.addtemp += f
	} else {
		m.addtemp = &f
	}
}

// AddedTemp returns the value that was added to the temp field in this mutation.
func (m *HistorytakingMutation) AddedTemp() (r float32, exists bool) {
	v := m.addtemp
	if v == nil {
		return
	}
	return *v, true
}

// ResetTemp reset all changes of the "temp" field.
func (m *HistorytakingMutation) ResetTemp() {
	m.temp = nil
	m.addtemp = nil
}

// SetPulse sets the pulse field.
func (m *HistorytakingMutation) SetPulse(i int) {
	m.pulse = &i
	m.addpulse = nil
}

// Pulse returns the pulse value in the mutation.
func (m *HistorytakingMutation) Pulse() (r int, exists bool) {
	v := m.pulse
	if v == nil {
		return
	}
	return *v, true
}

// OldPulse returns the old pulse value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldPulse(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPulse is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPulse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPulse: %w", err)
	}
	return oldValue.Pulse, nil
}

// AddPulse adds i to pulse.
func (m *HistorytakingMutation) AddPulse(i int) {
	if m.addpulse != nil {
		*m.addpulse += i
	} else {
		m.addpulse = &i
	}
}

// AddedPulse returns the value that was added to the pulse field in this mutation.
func (m *HistorytakingMutation) AddedPulse() (r int, exists bool) {
	v := m.addpulse
	if v == nil {
		return
	}
	return *v, true
}

// ResetPulse reset all changes of the "pulse" field.
func (m *HistorytakingMutation) ResetPulse() {
	m.pulse = nil
	m.addpulse = nil
}

// SetRespiration sets the respiration field.
func (m *HistorytakingMutation) SetRespiration(i int) {
	m.respiration = &i
	m.addrespiration = nil
}

// Respiration returns the respiration value in the mutation.
func (m *HistorytakingMutation) Respiration() (r int, exists bool) {
	v := m.respiration
	if v == nil {
		return
	}
	return *v, true
}

// OldRespiration returns the old respiration value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldRespiration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRespiration is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRespiration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespiration: %w", err)
	}
	return oldValue.Respiration, nil
}

// AddRespiration adds i to respiration.
func (m *HistorytakingMutation) AddRespiration(i int) {
	if m.addrespiration != nil {
		*m.addrespiration += i
	} else {
		m.addrespiration = &i
	}
}

// AddedRespiration returns the value that was added to the respiration field in this mutation.
func (m *HistorytakingMutation) AddedRespiration() (r int, exists bool) {
	v := m.addrespiration
	if v == nil {
		return
	}
	return *v, true
}

// ResetRespiration reset all changes of the "respiration" field.
func (m *HistorytakingMutation) ResetRespiration() {
	m.respiration = nil
	m.addrespiration = nil
}

// SetBp sets the bp field.
func (m *HistorytakingMutation) SetBp(i int) {
	m.bp = &i
	m.addbp = nil
}

// Bp returns the bp value in the mutation.
func (m *HistorytakingMutation) Bp() (r int, exists bool) {
	v := m.bp
	if v == nil {
		return
	}
	return *v, true
}

// OldBp returns the old bp value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldBp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBp is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBp: %w", err)
	}
	return oldValue.Bp, nil
}

// AddBp adds i to bp.
func (m *HistorytakingMutation) AddBp(i int) {
	if m.addbp != nil {
		*m.addbp += i
	} else {
		m.addbp = &i
	}
}

// AddedBp returns the value that was added to the bp field in this mutation.
func (m *HistorytakingMutation) AddedBp() (r int, exists bool) {
	v := m.addbp
	if v == nil {
		return
	}
	return *v, true
}

// ResetBp reset all changes of the "bp" field.
func (m *HistorytakingMutation) ResetBp() {
	m.bp = nil
	m.addbp = nil
}

// SetOxygen sets the oxygen field.
func (m *HistorytakingMutation) SetOxygen(s string) {
	m.oxygen = &s
}

// Oxygen returns the oxygen value in the mutation.
func (m *HistorytakingMutation) Oxygen() (r string, exists bool) {
	v := m.oxygen
	if v == nil {
		return
	}
	return *v, true
}

// OldOxygen returns the old oxygen value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldOxygen(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOxygen is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOxygen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOxygen: %w", err)
	}
	return oldValue.Oxygen, nil
}

// ResetOxygen reset all changes of the "oxygen" field.
func (m *HistorytakingMutation) ResetOxygen() {
	m.oxygen = nil
}

// SetSymptom sets the symptom field.
func (m *HistorytakingMutation) SetSymptom(s string) {
	m.symptom = &s
}

// Symptom returns the symptom value in the mutation.
func (m *HistorytakingMutation) Symptom() (r string, exists bool) {
	v := m.symptom
	if v == nil {
		return
	}
	return *v, true
}

// OldSymptom returns the old symptom value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldSymptom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSymptom is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSymptom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymptom: %w", err)
	}
	return oldValue.Symptom, nil
}

// ResetSymptom reset all changes of the "symptom" field.
func (m *HistorytakingMutation) ResetSymptom() {
	m.symptom = nil
}

// SetDatetime sets the datetime field.
func (m *HistorytakingMutation) SetDatetime(t time.Time) {
	m.datetime = &t
}

// Datetime returns the datetime value in the mutation.
func (m *HistorytakingMutation) Datetime() (r time.Time, exists bool) {
	v := m.datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetime returns the old datetime value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDatetime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetime: %w", err)
	}
	return oldValue.Datetime, nil
}

// ResetDatetime reset all changes of the "datetime" field.
func (m *HistorytakingMutation) ResetDatetime() {
	m.datetime = nil
}

// SetEdgesOfNurseID sets the EdgesOfNurse edge to Nurse by id.
func (m *HistorytakingMutation) SetEdgesOfNurseID(id int) {
	m._EdgesOfNurse = &id
}

// ClearEdgesOfNurse clears the EdgesOfNurse edge to Nurse.
func (m *HistorytakingMutation) ClearEdgesOfNurse() {
	m.cleared_EdgesOfNurse = true
}

// EdgesOfNurseCleared returns if the edge EdgesOfNurse was cleared.
func (m *HistorytakingMutation) EdgesOfNurseCleared() bool {
	return m.cleared_EdgesOfNurse
}

// EdgesOfNurseID returns the EdgesOfNurse id in the mutation.
func (m *HistorytakingMutation) EdgesOfNurseID() (id int, exists bool) {
	if m._EdgesOfNurse != nil {
		return *m._EdgesOfNurse, true
	}
	return
}

// EdgesOfNurseIDs returns the EdgesOfNurse ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfNurseID instead. It exists only for internal usage by the builders.
func (m *HistorytakingMutation) EdgesOfNurseIDs() (ids []int) {
	if id := m._EdgesOfNurse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfNurse reset all changes of the "EdgesOfNurse" edge.
func (m *HistorytakingMutation) ResetEdgesOfNurse() {
	m._EdgesOfNurse = nil
	m.cleared_EdgesOfNurse = false
}

// SetEdgesOfDepartmentID sets the EdgesOfDepartment edge to Department by id.
func (m *HistorytakingMutation) SetEdgesOfDepartmentID(id int) {
	m._EdgesOfDepartment = &id
}

// ClearEdgesOfDepartment clears the EdgesOfDepartment edge to Department.
func (m *HistorytakingMutation) ClearEdgesOfDepartment() {
	m.cleared_EdgesOfDepartment = true
}

// EdgesOfDepartmentCleared returns if the edge EdgesOfDepartment was cleared.
func (m *HistorytakingMutation) EdgesOfDepartmentCleared() bool {
	return m.cleared_EdgesOfDepartment
}

// EdgesOfDepartmentID returns the EdgesOfDepartment id in the mutation.
func (m *HistorytakingMutation) EdgesOfDepartmentID() (id int, exists bool) {
	if m._EdgesOfDepartment != nil {
		return *m._EdgesOfDepartment, true
	}
	return
}

// EdgesOfDepartmentIDs returns the EdgesOfDepartment ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfDepartmentID instead. It exists only for internal usage by the builders.
func (m *HistorytakingMutation) EdgesOfDepartmentIDs() (ids []int) {
	if id := m._EdgesOfDepartment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfDepartment reset all changes of the "EdgesOfDepartment" edge.
func (m *HistorytakingMutation) ResetEdgesOfDepartment() {
	m._EdgesOfDepartment = nil
	m.cleared_EdgesOfDepartment = false
}

// SetEdgesOfSymptomseverityID sets the EdgesOfSymptomseverity edge to Symptomseverity by id.
func (m *HistorytakingMutation) SetEdgesOfSymptomseverityID(id int) {
	m._EdgesOfSymptomseverity = &id
}

// ClearEdgesOfSymptomseverity clears the EdgesOfSymptomseverity edge to Symptomseverity.
func (m *HistorytakingMutation) ClearEdgesOfSymptomseverity() {
	m.cleared_EdgesOfSymptomseverity = true
}

// EdgesOfSymptomseverityCleared returns if the edge EdgesOfSymptomseverity was cleared.
func (m *HistorytakingMutation) EdgesOfSymptomseverityCleared() bool {
	return m.cleared_EdgesOfSymptomseverity
}

// EdgesOfSymptomseverityID returns the EdgesOfSymptomseverity id in the mutation.
func (m *HistorytakingMutation) EdgesOfSymptomseverityID() (id int, exists bool) {
	if m._EdgesOfSymptomseverity != nil {
		return *m._EdgesOfSymptomseverity, true
	}
	return
}

// EdgesOfSymptomseverityIDs returns the EdgesOfSymptomseverity ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfSymptomseverityID instead. It exists only for internal usage by the builders.
func (m *HistorytakingMutation) EdgesOfSymptomseverityIDs() (ids []int) {
	if id := m._EdgesOfSymptomseverity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfSymptomseverity reset all changes of the "EdgesOfSymptomseverity" edge.
func (m *HistorytakingMutation) ResetEdgesOfSymptomseverity() {
	m._EdgesOfSymptomseverity = nil
	m.cleared_EdgesOfSymptomseverity = false
}

// SetEdgesOfPatientrecordID sets the EdgesOfPatientrecord edge to Patientrecord by id.
func (m *HistorytakingMutation) SetEdgesOfPatientrecordID(id int) {
	m._EdgesOfPatientrecord = &id
}

// ClearEdgesOfPatientrecord clears the EdgesOfPatientrecord edge to Patientrecord.
func (m *HistorytakingMutation) ClearEdgesOfPatientrecord() {
	m.cleared_EdgesOfPatientrecord = true
}

// EdgesOfPatientrecordCleared returns if the edge EdgesOfPatientrecord was cleared.
func (m *HistorytakingMutation) EdgesOfPatientrecordCleared() bool {
	return m.cleared_EdgesOfPatientrecord
}

// EdgesOfPatientrecordID returns the EdgesOfPatientrecord id in the mutation.
func (m *HistorytakingMutation) EdgesOfPatientrecordID() (id int, exists bool) {
	if m._EdgesOfPatientrecord != nil {
		return *m._EdgesOfPatientrecord, true
	}
	return
}

// EdgesOfPatientrecordIDs returns the EdgesOfPatientrecord ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfPatientrecordID instead. It exists only for internal usage by the builders.
func (m *HistorytakingMutation) EdgesOfPatientrecordIDs() (ids []int) {
	if id := m._EdgesOfPatientrecord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfPatientrecord reset all changes of the "EdgesOfPatientrecord" edge.
func (m *HistorytakingMutation) ResetEdgesOfPatientrecord() {
	m._EdgesOfPatientrecord = nil
	m.cleared_EdgesOfPatientrecord = false
}

// Op returns the operation name.
func (m *HistorytakingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Historytaking).
func (m *HistorytakingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *HistorytakingMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.hight != nil {
		fields = append(fields, historytaking.FieldHight)
	}
	if m.weight != nil {
		fields = append(fields, historytaking.FieldWeight)
	}
	if m.temp != nil {
		fields = append(fields, historytaking.FieldTemp)
	}
	if m.pulse != nil {
		fields = append(fields, historytaking.FieldPulse)
	}
	if m.respiration != nil {
		fields = append(fields, historytaking.FieldRespiration)
	}
	if m.bp != nil {
		fields = append(fields, historytaking.FieldBp)
	}
	if m.oxygen != nil {
		fields = append(fields, historytaking.FieldOxygen)
	}
	if m.symptom != nil {
		fields = append(fields, historytaking.FieldSymptom)
	}
	if m.datetime != nil {
		fields = append(fields, historytaking.FieldDatetime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *HistorytakingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case historytaking.FieldHight:
		return m.Hight()
	case historytaking.FieldWeight:
		return m.Weight()
	case historytaking.FieldTemp:
		return m.Temp()
	case historytaking.FieldPulse:
		return m.Pulse()
	case historytaking.FieldRespiration:
		return m.Respiration()
	case historytaking.FieldBp:
		return m.Bp()
	case historytaking.FieldOxygen:
		return m.Oxygen()
	case historytaking.FieldSymptom:
		return m.Symptom()
	case historytaking.FieldDatetime:
		return m.Datetime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *HistorytakingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case historytaking.FieldHight:
		return m.OldHight(ctx)
	case historytaking.FieldWeight:
		return m.OldWeight(ctx)
	case historytaking.FieldTemp:
		return m.OldTemp(ctx)
	case historytaking.FieldPulse:
		return m.OldPulse(ctx)
	case historytaking.FieldRespiration:
		return m.OldRespiration(ctx)
	case historytaking.FieldBp:
		return m.OldBp(ctx)
	case historytaking.FieldOxygen:
		return m.OldOxygen(ctx)
	case historytaking.FieldSymptom:
		return m.OldSymptom(ctx)
	case historytaking.FieldDatetime:
		return m.OldDatetime(ctx)
	}
	return nil, fmt.Errorf("unknown Historytaking field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HistorytakingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case historytaking.FieldHight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHight(v)
		return nil
	case historytaking.FieldWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case historytaking.FieldTemp:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemp(v)
		return nil
	case historytaking.FieldPulse:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPulse(v)
		return nil
	case historytaking.FieldRespiration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespiration(v)
		return nil
	case historytaking.FieldBp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBp(v)
		return nil
	case historytaking.FieldOxygen:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOxygen(v)
		return nil
	case historytaking.FieldSymptom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymptom(v)
		return nil
	case historytaking.FieldDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetime(v)
		return nil
	}
	return fmt.Errorf("unknown Historytaking field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *HistorytakingMutation) AddedFields() []string {
	var fields []string
	if m.addhight != nil {
		fields = append(fields, historytaking.FieldHight)
	}
	if m.addweight != nil {
		fields = append(fields, historytaking.FieldWeight)
	}
	if m.addtemp != nil {
		fields = append(fields, historytaking.FieldTemp)
	}
	if m.addpulse != nil {
		fields = append(fields, historytaking.FieldPulse)
	}
	if m.addrespiration != nil {
		fields = append(fields, historytaking.FieldRespiration)
	}
	if m.addbp != nil {
		fields = append(fields, historytaking.FieldBp)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *HistorytakingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case historytaking.FieldHight:
		return m.AddedHight()
	case historytaking.FieldWeight:
		return m.AddedWeight()
	case historytaking.FieldTemp:
		return m.AddedTemp()
	case historytaking.FieldPulse:
		return m.AddedPulse()
	case historytaking.FieldRespiration:
		return m.AddedRespiration()
	case historytaking.FieldBp:
		return m.AddedBp()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HistorytakingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case historytaking.FieldHight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHight(v)
		return nil
	case historytaking.FieldWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case historytaking.FieldTemp:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTemp(v)
		return nil
	case historytaking.FieldPulse:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPulse(v)
		return nil
	case historytaking.FieldRespiration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRespiration(v)
		return nil
	case historytaking.FieldBp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBp(v)
		return nil
	}
	return fmt.Errorf("unknown Historytaking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *HistorytakingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *HistorytakingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *HistorytakingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Historytaking nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *HistorytakingMutation) ResetField(name string) error {
	switch name {
	case historytaking.FieldHight:
		m.ResetHight()
		return nil
	case historytaking.FieldWeight:
		m.ResetWeight()
		return nil
	case historytaking.FieldTemp:
		m.ResetTemp()
		return nil
	case historytaking.FieldPulse:
		m.ResetPulse()
		return nil
	case historytaking.FieldRespiration:
		m.ResetRespiration()
		return nil
	case historytaking.FieldBp:
		m.ResetBp()
		return nil
	case historytaking.FieldOxygen:
		m.ResetOxygen()
		return nil
	case historytaking.FieldSymptom:
		m.ResetSymptom()
		return nil
	case historytaking.FieldDatetime:
		m.ResetDatetime()
		return nil
	}
	return fmt.Errorf("unknown Historytaking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *HistorytakingMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._EdgesOfNurse != nil {
		edges = append(edges, historytaking.EdgeEdgesOfNurse)
	}
	if m._EdgesOfDepartment != nil {
		edges = append(edges, historytaking.EdgeEdgesOfDepartment)
	}
	if m._EdgesOfSymptomseverity != nil {
		edges = append(edges, historytaking.EdgeEdgesOfSymptomseverity)
	}
	if m._EdgesOfPatientrecord != nil {
		edges = append(edges, historytaking.EdgeEdgesOfPatientrecord)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *HistorytakingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case historytaking.EdgeEdgesOfNurse:
		if id := m._EdgesOfNurse; id != nil {
			return []ent.Value{*id}
		}
	case historytaking.EdgeEdgesOfDepartment:
		if id := m._EdgesOfDepartment; id != nil {
			return []ent.Value{*id}
		}
	case historytaking.EdgeEdgesOfSymptomseverity:
		if id := m._EdgesOfSymptomseverity; id != nil {
			return []ent.Value{*id}
		}
	case historytaking.EdgeEdgesOfPatientrecord:
		if id := m._EdgesOfPatientrecord; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *HistorytakingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *HistorytakingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *HistorytakingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_EdgesOfNurse {
		edges = append(edges, historytaking.EdgeEdgesOfNurse)
	}
	if m.cleared_EdgesOfDepartment {
		edges = append(edges, historytaking.EdgeEdgesOfDepartment)
	}
	if m.cleared_EdgesOfSymptomseverity {
		edges = append(edges, historytaking.EdgeEdgesOfSymptomseverity)
	}
	if m.cleared_EdgesOfPatientrecord {
		edges = append(edges, historytaking.EdgeEdgesOfPatientrecord)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *HistorytakingMutation) EdgeCleared(name string) bool {
	switch name {
	case historytaking.EdgeEdgesOfNurse:
		return m.cleared_EdgesOfNurse
	case historytaking.EdgeEdgesOfDepartment:
		return m.cleared_EdgesOfDepartment
	case historytaking.EdgeEdgesOfSymptomseverity:
		return m.cleared_EdgesOfSymptomseverity
	case historytaking.EdgeEdgesOfPatientrecord:
		return m.cleared_EdgesOfPatientrecord
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *HistorytakingMutation) ClearEdge(name string) error {
	switch name {
	case historytaking.EdgeEdgesOfNurse:
		m.ClearEdgesOfNurse()
		return nil
	case historytaking.EdgeEdgesOfDepartment:
		m.ClearEdgesOfDepartment()
		return nil
	case historytaking.EdgeEdgesOfSymptomseverity:
		m.ClearEdgesOfSymptomseverity()
		return nil
	case historytaking.EdgeEdgesOfPatientrecord:
		m.ClearEdgesOfPatientrecord()
		return nil
	}
	return fmt.Errorf("unknown Historytaking unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *HistorytakingMutation) ResetEdge(name string) error {
	switch name {
	case historytaking.EdgeEdgesOfNurse:
		m.ResetEdgesOfNurse()
		return nil
	case historytaking.EdgeEdgesOfDepartment:
		m.ResetEdgesOfDepartment()
		return nil
	case historytaking.EdgeEdgesOfSymptomseverity:
		m.ResetEdgesOfSymptomseverity()
		return nil
	case historytaking.EdgeEdgesOfPatientrecord:
		m.ResetEdgesOfPatientrecord()
		return nil
	}
	return fmt.Errorf("unknown Historytaking edge %s", name)
}

// InsuranceMutation represents an operation that mutate the Insurances
// nodes in the graph.
type InsuranceMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *int
	_Insurancecompany                     *string
	clearedFields                         map[string]struct{}
	_EdgesOfInsurancePatientrights        map[int]struct{}
	removed_EdgesOfInsurancePatientrights map[int]struct{}
	done                                  bool
	oldValue                              func(context.Context) (*Insurance, error)
}

var _ ent.Mutation = (*InsuranceMutation)(nil)

// insuranceOption allows to manage the mutation configuration using functional options.
type insuranceOption func(*InsuranceMutation)

// newInsuranceMutation creates new mutation for $n.Name.
func newInsuranceMutation(c config, op Op, opts ...insuranceOption) *InsuranceMutation {
	m := &InsuranceMutation{
		config:        c,
		op:            op,
		typ:           TypeInsurance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInsuranceID sets the id field of the mutation.
func withInsuranceID(id int) insuranceOption {
	return func(m *InsuranceMutation) {
		var (
			err   error
			once  sync.Once
			value *Insurance
		)
		m.oldValue = func(ctx context.Context) (*Insurance, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Insurance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInsurance sets the old Insurance of the mutation.
func withInsurance(node *Insurance) insuranceOption {
	return func(m *InsuranceMutation) {
		m.oldValue = func(context.Context) (*Insurance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InsuranceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InsuranceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InsuranceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetInsurancecompany sets the Insurancecompany field.
func (m *InsuranceMutation) SetInsurancecompany(s string) {
	m._Insurancecompany = &s
}

// Insurancecompany returns the Insurancecompany value in the mutation.
func (m *InsuranceMutation) Insurancecompany() (r string, exists bool) {
	v := m._Insurancecompany
	if v == nil {
		return
	}
	return *v, true
}

// OldInsurancecompany returns the old Insurancecompany value of the Insurance.
// If the Insurance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InsuranceMutation) OldInsurancecompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInsurancecompany is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInsurancecompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInsurancecompany: %w", err)
	}
	return oldValue.Insurancecompany, nil
}

// ResetInsurancecompany reset all changes of the "Insurancecompany" field.
func (m *InsuranceMutation) ResetInsurancecompany() {
	m._Insurancecompany = nil
}

// AddEdgesOfInsurancePatientrightIDs adds the EdgesOfInsurancePatientrights edge to Patientrights by ids.
func (m *InsuranceMutation) AddEdgesOfInsurancePatientrightIDs(ids ...int) {
	if m._EdgesOfInsurancePatientrights == nil {
		m._EdgesOfInsurancePatientrights = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfInsurancePatientrights[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfInsurancePatientrightIDs removes the EdgesOfInsurancePatientrights edge to Patientrights by ids.
func (m *InsuranceMutation) RemoveEdgesOfInsurancePatientrightIDs(ids ...int) {
	if m.removed_EdgesOfInsurancePatientrights == nil {
		m.removed_EdgesOfInsurancePatientrights = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfInsurancePatientrights[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfInsurancePatientrights returns the removed ids of EdgesOfInsurancePatientrights.
func (m *InsuranceMutation) RemovedEdgesOfInsurancePatientrightsIDs() (ids []int) {
	for id := range m.removed_EdgesOfInsurancePatientrights {
		ids = append(ids, id)
	}
	return
}

// EdgesOfInsurancePatientrightsIDs returns the EdgesOfInsurancePatientrights ids in the mutation.
func (m *InsuranceMutation) EdgesOfInsurancePatientrightsIDs() (ids []int) {
	for id := range m._EdgesOfInsurancePatientrights {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfInsurancePatientrights reset all changes of the "EdgesOfInsurancePatientrights" edge.
func (m *InsuranceMutation) ResetEdgesOfInsurancePatientrights() {
	m._EdgesOfInsurancePatientrights = nil
	m.removed_EdgesOfInsurancePatientrights = nil
}

// Op returns the operation name.
func (m *InsuranceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Insurance).
func (m *InsuranceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InsuranceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Insurancecompany != nil {
		fields = append(fields, insurance.FieldInsurancecompany)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InsuranceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case insurance.FieldInsurancecompany:
		return m.Insurancecompany()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *InsuranceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case insurance.FieldInsurancecompany:
		return m.OldInsurancecompany(ctx)
	}
	return nil, fmt.Errorf("unknown Insurance field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InsuranceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case insurance.FieldInsurancecompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInsurancecompany(v)
		return nil
	}
	return fmt.Errorf("unknown Insurance field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InsuranceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InsuranceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InsuranceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Insurance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InsuranceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InsuranceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InsuranceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Insurance nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InsuranceMutation) ResetField(name string) error {
	switch name {
	case insurance.FieldInsurancecompany:
		m.ResetInsurancecompany()
		return nil
	}
	return fmt.Errorf("unknown Insurance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InsuranceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._EdgesOfInsurancePatientrights != nil {
		edges = append(edges, insurance.EdgeEdgesOfInsurancePatientrights)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InsuranceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case insurance.EdgeEdgesOfInsurancePatientrights:
		ids := make([]ent.Value, 0, len(m._EdgesOfInsurancePatientrights))
		for id := range m._EdgesOfInsurancePatientrights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InsuranceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_EdgesOfInsurancePatientrights != nil {
		edges = append(edges, insurance.EdgeEdgesOfInsurancePatientrights)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InsuranceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case insurance.EdgeEdgesOfInsurancePatientrights:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfInsurancePatientrights))
		for id := range m.removed_EdgesOfInsurancePatientrights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InsuranceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InsuranceMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InsuranceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Insurance unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InsuranceMutation) ResetEdge(name string) error {
	switch name {
	case insurance.EdgeEdgesOfInsurancePatientrights:
		m.ResetEdgesOfInsurancePatientrights()
		return nil
	}
	return fmt.Errorf("unknown Insurance edge %s", name)
}

// MedicalrecordstaffMutation represents an operation that mutate the Medicalrecordstaffs
// nodes in the graph.
type MedicalrecordstaffMutation struct {
	config
	op                                             Op
	typ                                            string
	id                                             *int
	_Name                                          *string
	clearedFields                                  map[string]struct{}
	_EdgesOfPatientrecord                          map[int]struct{}
	removed_EdgesOfPatientrecord                   map[int]struct{}
	_EdgesOfMedicalrecordstaffPatientrights        map[int]struct{}
	removed_EdgesOfMedicalrecordstaffPatientrights map[int]struct{}
	_EdgesOfUser                                   *int
	cleared_EdgesOfUser                            bool
	done                                           bool
	oldValue                                       func(context.Context) (*Medicalrecordstaff, error)
}

var _ ent.Mutation = (*MedicalrecordstaffMutation)(nil)

// medicalrecordstaffOption allows to manage the mutation configuration using functional options.
type medicalrecordstaffOption func(*MedicalrecordstaffMutation)

// newMedicalrecordstaffMutation creates new mutation for $n.Name.
func newMedicalrecordstaffMutation(c config, op Op, opts ...medicalrecordstaffOption) *MedicalrecordstaffMutation {
	m := &MedicalrecordstaffMutation{
		config:        c,
		op:            op,
		typ:           TypeMedicalrecordstaff,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicalrecordstaffID sets the id field of the mutation.
func withMedicalrecordstaffID(id int) medicalrecordstaffOption {
	return func(m *MedicalrecordstaffMutation) {
		var (
			err   error
			once  sync.Once
			value *Medicalrecordstaff
		)
		m.oldValue = func(ctx context.Context) (*Medicalrecordstaff, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Medicalrecordstaff.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedicalrecordstaff sets the old Medicalrecordstaff of the mutation.
func withMedicalrecordstaff(node *Medicalrecordstaff) medicalrecordstaffOption {
	return func(m *MedicalrecordstaffMutation) {
		m.oldValue = func(context.Context) (*Medicalrecordstaff, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicalrecordstaffMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicalrecordstaffMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MedicalrecordstaffMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the Name field.
func (m *MedicalrecordstaffMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the Name value in the mutation.
func (m *MedicalrecordstaffMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old Name value of the Medicalrecordstaff.
// If the Medicalrecordstaff object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicalrecordstaffMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "Name" field.
func (m *MedicalrecordstaffMutation) ResetName() {
	m._Name = nil
}

// AddEdgesOfPatientrecordIDs adds the EdgesOfPatientrecord edge to Patientrecord by ids.
func (m *MedicalrecordstaffMutation) AddEdgesOfPatientrecordIDs(ids ...int) {
	if m._EdgesOfPatientrecord == nil {
		m._EdgesOfPatientrecord = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfPatientrecord[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfPatientrecordIDs removes the EdgesOfPatientrecord edge to Patientrecord by ids.
func (m *MedicalrecordstaffMutation) RemoveEdgesOfPatientrecordIDs(ids ...int) {
	if m.removed_EdgesOfPatientrecord == nil {
		m.removed_EdgesOfPatientrecord = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfPatientrecord[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfPatientrecord returns the removed ids of EdgesOfPatientrecord.
func (m *MedicalrecordstaffMutation) RemovedEdgesOfPatientrecordIDs() (ids []int) {
	for id := range m.removed_EdgesOfPatientrecord {
		ids = append(ids, id)
	}
	return
}

// EdgesOfPatientrecordIDs returns the EdgesOfPatientrecord ids in the mutation.
func (m *MedicalrecordstaffMutation) EdgesOfPatientrecordIDs() (ids []int) {
	for id := range m._EdgesOfPatientrecord {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfPatientrecord reset all changes of the "EdgesOfPatientrecord" edge.
func (m *MedicalrecordstaffMutation) ResetEdgesOfPatientrecord() {
	m._EdgesOfPatientrecord = nil
	m.removed_EdgesOfPatientrecord = nil
}

// AddEdgesOfMedicalrecordstaffPatientrightIDs adds the EdgesOfMedicalrecordstaffPatientrights edge to Patientrights by ids.
func (m *MedicalrecordstaffMutation) AddEdgesOfMedicalrecordstaffPatientrightIDs(ids ...int) {
	if m._EdgesOfMedicalrecordstaffPatientrights == nil {
		m._EdgesOfMedicalrecordstaffPatientrights = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfMedicalrecordstaffPatientrights[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfMedicalrecordstaffPatientrightIDs removes the EdgesOfMedicalrecordstaffPatientrights edge to Patientrights by ids.
func (m *MedicalrecordstaffMutation) RemoveEdgesOfMedicalrecordstaffPatientrightIDs(ids ...int) {
	if m.removed_EdgesOfMedicalrecordstaffPatientrights == nil {
		m.removed_EdgesOfMedicalrecordstaffPatientrights = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfMedicalrecordstaffPatientrights[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfMedicalrecordstaffPatientrights returns the removed ids of EdgesOfMedicalrecordstaffPatientrights.
func (m *MedicalrecordstaffMutation) RemovedEdgesOfMedicalrecordstaffPatientrightsIDs() (ids []int) {
	for id := range m.removed_EdgesOfMedicalrecordstaffPatientrights {
		ids = append(ids, id)
	}
	return
}

// EdgesOfMedicalrecordstaffPatientrightsIDs returns the EdgesOfMedicalrecordstaffPatientrights ids in the mutation.
func (m *MedicalrecordstaffMutation) EdgesOfMedicalrecordstaffPatientrightsIDs() (ids []int) {
	for id := range m._EdgesOfMedicalrecordstaffPatientrights {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfMedicalrecordstaffPatientrights reset all changes of the "EdgesOfMedicalrecordstaffPatientrights" edge.
func (m *MedicalrecordstaffMutation) ResetEdgesOfMedicalrecordstaffPatientrights() {
	m._EdgesOfMedicalrecordstaffPatientrights = nil
	m.removed_EdgesOfMedicalrecordstaffPatientrights = nil
}

// SetEdgesOfUserID sets the EdgesOfUser edge to User by id.
func (m *MedicalrecordstaffMutation) SetEdgesOfUserID(id int) {
	m._EdgesOfUser = &id
}

// ClearEdgesOfUser clears the EdgesOfUser edge to User.
func (m *MedicalrecordstaffMutation) ClearEdgesOfUser() {
	m.cleared_EdgesOfUser = true
}

// EdgesOfUserCleared returns if the edge EdgesOfUser was cleared.
func (m *MedicalrecordstaffMutation) EdgesOfUserCleared() bool {
	return m.cleared_EdgesOfUser
}

// EdgesOfUserID returns the EdgesOfUser id in the mutation.
func (m *MedicalrecordstaffMutation) EdgesOfUserID() (id int, exists bool) {
	if m._EdgesOfUser != nil {
		return *m._EdgesOfUser, true
	}
	return
}

// EdgesOfUserIDs returns the EdgesOfUser ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfUserID instead. It exists only for internal usage by the builders.
func (m *MedicalrecordstaffMutation) EdgesOfUserIDs() (ids []int) {
	if id := m._EdgesOfUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfUser reset all changes of the "EdgesOfUser" edge.
func (m *MedicalrecordstaffMutation) ResetEdgesOfUser() {
	m._EdgesOfUser = nil
	m.cleared_EdgesOfUser = false
}

// Op returns the operation name.
func (m *MedicalrecordstaffMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Medicalrecordstaff).
func (m *MedicalrecordstaffMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MedicalrecordstaffMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Name != nil {
		fields = append(fields, medicalrecordstaff.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MedicalrecordstaffMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medicalrecordstaff.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MedicalrecordstaffMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medicalrecordstaff.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Medicalrecordstaff field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MedicalrecordstaffMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medicalrecordstaff.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Medicalrecordstaff field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MedicalrecordstaffMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MedicalrecordstaffMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MedicalrecordstaffMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Medicalrecordstaff numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MedicalrecordstaffMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MedicalrecordstaffMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicalrecordstaffMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Medicalrecordstaff nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MedicalrecordstaffMutation) ResetField(name string) error {
	switch name {
	case medicalrecordstaff.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Medicalrecordstaff field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MedicalrecordstaffMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._EdgesOfPatientrecord != nil {
		edges = append(edges, medicalrecordstaff.EdgeEdgesOfPatientrecord)
	}
	if m._EdgesOfMedicalrecordstaffPatientrights != nil {
		edges = append(edges, medicalrecordstaff.EdgeEdgesOfMedicalrecordstaffPatientrights)
	}
	if m._EdgesOfUser != nil {
		edges = append(edges, medicalrecordstaff.EdgeEdgesOfUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MedicalrecordstaffMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case medicalrecordstaff.EdgeEdgesOfPatientrecord:
		ids := make([]ent.Value, 0, len(m._EdgesOfPatientrecord))
		for id := range m._EdgesOfPatientrecord {
			ids = append(ids, id)
		}
		return ids
	case medicalrecordstaff.EdgeEdgesOfMedicalrecordstaffPatientrights:
		ids := make([]ent.Value, 0, len(m._EdgesOfMedicalrecordstaffPatientrights))
		for id := range m._EdgesOfMedicalrecordstaffPatientrights {
			ids = append(ids, id)
		}
		return ids
	case medicalrecordstaff.EdgeEdgesOfUser:
		if id := m._EdgesOfUser; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MedicalrecordstaffMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_EdgesOfPatientrecord != nil {
		edges = append(edges, medicalrecordstaff.EdgeEdgesOfPatientrecord)
	}
	if m.removed_EdgesOfMedicalrecordstaffPatientrights != nil {
		edges = append(edges, medicalrecordstaff.EdgeEdgesOfMedicalrecordstaffPatientrights)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MedicalrecordstaffMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case medicalrecordstaff.EdgeEdgesOfPatientrecord:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfPatientrecord))
		for id := range m.removed_EdgesOfPatientrecord {
			ids = append(ids, id)
		}
		return ids
	case medicalrecordstaff.EdgeEdgesOfMedicalrecordstaffPatientrights:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfMedicalrecordstaffPatientrights))
		for id := range m.removed_EdgesOfMedicalrecordstaffPatientrights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MedicalrecordstaffMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_EdgesOfUser {
		edges = append(edges, medicalrecordstaff.EdgeEdgesOfUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MedicalrecordstaffMutation) EdgeCleared(name string) bool {
	switch name {
	case medicalrecordstaff.EdgeEdgesOfUser:
		return m.cleared_EdgesOfUser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MedicalrecordstaffMutation) ClearEdge(name string) error {
	switch name {
	case medicalrecordstaff.EdgeEdgesOfUser:
		m.ClearEdgesOfUser()
		return nil
	}
	return fmt.Errorf("unknown Medicalrecordstaff unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MedicalrecordstaffMutation) ResetEdge(name string) error {
	switch name {
	case medicalrecordstaff.EdgeEdgesOfPatientrecord:
		m.ResetEdgesOfPatientrecord()
		return nil
	case medicalrecordstaff.EdgeEdgesOfMedicalrecordstaffPatientrights:
		m.ResetEdgesOfMedicalrecordstaffPatientrights()
		return nil
	case medicalrecordstaff.EdgeEdgesOfUser:
		m.ResetEdgesOfUser()
		return nil
	}
	return fmt.Errorf("unknown Medicalrecordstaff edge %s", name)
}

// NurseMutation represents an operation that mutate the Nurses
// nodes in the graph.
type NurseMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	name                         *string
	nursinglicense               *string
	position                     *string
	clearedFields                map[string]struct{}
	_EdgesOfHistorytaking        map[int]struct{}
	removed_EdgesOfHistorytaking map[int]struct{}
	_EdgesOfUser                 *int
	cleared_EdgesOfUser          bool
	done                         bool
	oldValue                     func(context.Context) (*Nurse, error)
}

var _ ent.Mutation = (*NurseMutation)(nil)

// nurseOption allows to manage the mutation configuration using functional options.
type nurseOption func(*NurseMutation)

// newNurseMutation creates new mutation for $n.Name.
func newNurseMutation(c config, op Op, opts ...nurseOption) *NurseMutation {
	m := &NurseMutation{
		config:        c,
		op:            op,
		typ:           TypeNurse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNurseID sets the id field of the mutation.
func withNurseID(id int) nurseOption {
	return func(m *NurseMutation) {
		var (
			err   error
			once  sync.Once
			value *Nurse
		)
		m.oldValue = func(ctx context.Context) (*Nurse, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Nurse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNurse sets the old Nurse of the mutation.
func withNurse(node *Nurse) nurseOption {
	return func(m *NurseMutation) {
		m.oldValue = func(context.Context) (*Nurse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NurseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NurseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *NurseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *NurseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *NurseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *NurseMutation) ResetName() {
	m.name = nil
}

// SetNursinglicense sets the nursinglicense field.
func (m *NurseMutation) SetNursinglicense(s string) {
	m.nursinglicense = &s
}

// Nursinglicense returns the nursinglicense value in the mutation.
func (m *NurseMutation) Nursinglicense() (r string, exists bool) {
	v := m.nursinglicense
	if v == nil {
		return
	}
	return *v, true
}

// OldNursinglicense returns the old nursinglicense value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldNursinglicense(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNursinglicense is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNursinglicense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNursinglicense: %w", err)
	}
	return oldValue.Nursinglicense, nil
}

// ResetNursinglicense reset all changes of the "nursinglicense" field.
func (m *NurseMutation) ResetNursinglicense() {
	m.nursinglicense = nil
}

// SetPosition sets the position field.
func (m *NurseMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the position value in the mutation.
func (m *NurseMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old position value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPosition is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition reset all changes of the "position" field.
func (m *NurseMutation) ResetPosition() {
	m.position = nil
}

// AddEdgesOfHistorytakingIDs adds the EdgesOfHistorytaking edge to Historytaking by ids.
func (m *NurseMutation) AddEdgesOfHistorytakingIDs(ids ...int) {
	if m._EdgesOfHistorytaking == nil {
		m._EdgesOfHistorytaking = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfHistorytaking[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfHistorytakingIDs removes the EdgesOfHistorytaking edge to Historytaking by ids.
func (m *NurseMutation) RemoveEdgesOfHistorytakingIDs(ids ...int) {
	if m.removed_EdgesOfHistorytaking == nil {
		m.removed_EdgesOfHistorytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfHistorytaking[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfHistorytaking returns the removed ids of EdgesOfHistorytaking.
func (m *NurseMutation) RemovedEdgesOfHistorytakingIDs() (ids []int) {
	for id := range m.removed_EdgesOfHistorytaking {
		ids = append(ids, id)
	}
	return
}

// EdgesOfHistorytakingIDs returns the EdgesOfHistorytaking ids in the mutation.
func (m *NurseMutation) EdgesOfHistorytakingIDs() (ids []int) {
	for id := range m._EdgesOfHistorytaking {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfHistorytaking reset all changes of the "EdgesOfHistorytaking" edge.
func (m *NurseMutation) ResetEdgesOfHistorytaking() {
	m._EdgesOfHistorytaking = nil
	m.removed_EdgesOfHistorytaking = nil
}

// SetEdgesOfUserID sets the EdgesOfUser edge to User by id.
func (m *NurseMutation) SetEdgesOfUserID(id int) {
	m._EdgesOfUser = &id
}

// ClearEdgesOfUser clears the EdgesOfUser edge to User.
func (m *NurseMutation) ClearEdgesOfUser() {
	m.cleared_EdgesOfUser = true
}

// EdgesOfUserCleared returns if the edge EdgesOfUser was cleared.
func (m *NurseMutation) EdgesOfUserCleared() bool {
	return m.cleared_EdgesOfUser
}

// EdgesOfUserID returns the EdgesOfUser id in the mutation.
func (m *NurseMutation) EdgesOfUserID() (id int, exists bool) {
	if m._EdgesOfUser != nil {
		return *m._EdgesOfUser, true
	}
	return
}

// EdgesOfUserIDs returns the EdgesOfUser ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfUserID instead. It exists only for internal usage by the builders.
func (m *NurseMutation) EdgesOfUserIDs() (ids []int) {
	if id := m._EdgesOfUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfUser reset all changes of the "EdgesOfUser" edge.
func (m *NurseMutation) ResetEdgesOfUser() {
	m._EdgesOfUser = nil
	m.cleared_EdgesOfUser = false
}

// Op returns the operation name.
func (m *NurseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Nurse).
func (m *NurseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *NurseMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, nurse.FieldName)
	}
	if m.nursinglicense != nil {
		fields = append(fields, nurse.FieldNursinglicense)
	}
	if m.position != nil {
		fields = append(fields, nurse.FieldPosition)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *NurseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nurse.FieldName:
		return m.Name()
	case nurse.FieldNursinglicense:
		return m.Nursinglicense()
	case nurse.FieldPosition:
		return m.Position()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *NurseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nurse.FieldName:
		return m.OldName(ctx)
	case nurse.FieldNursinglicense:
		return m.OldNursinglicense(ctx)
	case nurse.FieldPosition:
		return m.OldPosition(ctx)
	}
	return nil, fmt.Errorf("unknown Nurse field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NurseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nurse.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case nurse.FieldNursinglicense:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNursinglicense(v)
		return nil
	case nurse.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	}
	return fmt.Errorf("unknown Nurse field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *NurseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *NurseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NurseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Nurse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *NurseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *NurseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *NurseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Nurse nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *NurseMutation) ResetField(name string) error {
	switch name {
	case nurse.FieldName:
		m.ResetName()
		return nil
	case nurse.FieldNursinglicense:
		m.ResetNursinglicense()
		return nil
	case nurse.FieldPosition:
		m.ResetPosition()
		return nil
	}
	return fmt.Errorf("unknown Nurse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *NurseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._EdgesOfHistorytaking != nil {
		edges = append(edges, nurse.EdgeEdgesOfHistorytaking)
	}
	if m._EdgesOfUser != nil {
		edges = append(edges, nurse.EdgeEdgesOfUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *NurseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nurse.EdgeEdgesOfHistorytaking:
		ids := make([]ent.Value, 0, len(m._EdgesOfHistorytaking))
		for id := range m._EdgesOfHistorytaking {
			ids = append(ids, id)
		}
		return ids
	case nurse.EdgeEdgesOfUser:
		if id := m._EdgesOfUser; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *NurseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_EdgesOfHistorytaking != nil {
		edges = append(edges, nurse.EdgeEdgesOfHistorytaking)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *NurseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nurse.EdgeEdgesOfHistorytaking:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfHistorytaking))
		for id := range m.removed_EdgesOfHistorytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *NurseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_EdgesOfUser {
		edges = append(edges, nurse.EdgeEdgesOfUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *NurseMutation) EdgeCleared(name string) bool {
	switch name {
	case nurse.EdgeEdgesOfUser:
		return m.cleared_EdgesOfUser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *NurseMutation) ClearEdge(name string) error {
	switch name {
	case nurse.EdgeEdgesOfUser:
		m.ClearEdgesOfUser()
		return nil
	}
	return fmt.Errorf("unknown Nurse unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *NurseMutation) ResetEdge(name string) error {
	switch name {
	case nurse.EdgeEdgesOfHistorytaking:
		m.ResetEdgesOfHistorytaking()
		return nil
	case nurse.EdgeEdgesOfUser:
		m.ResetEdgesOfUser()
		return nil
	}
	return fmt.Errorf("unknown Nurse edge %s", name)
}

// OfficeroomMutation represents an operation that mutate the Officerooms
// nodes in the graph.
type OfficeroomMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	roomnumber                           *string
	clearedFields                        map[string]struct{}
	_EdgesOfOfficeroom2doctorinfo        map[int]struct{}
	removed_EdgesOfOfficeroom2doctorinfo map[int]struct{}
	done                                 bool
	oldValue                             func(context.Context) (*Officeroom, error)
}

var _ ent.Mutation = (*OfficeroomMutation)(nil)

// officeroomOption allows to manage the mutation configuration using functional options.
type officeroomOption func(*OfficeroomMutation)

// newOfficeroomMutation creates new mutation for $n.Name.
func newOfficeroomMutation(c config, op Op, opts ...officeroomOption) *OfficeroomMutation {
	m := &OfficeroomMutation{
		config:        c,
		op:            op,
		typ:           TypeOfficeroom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOfficeroomID sets the id field of the mutation.
func withOfficeroomID(id int) officeroomOption {
	return func(m *OfficeroomMutation) {
		var (
			err   error
			once  sync.Once
			value *Officeroom
		)
		m.oldValue = func(ctx context.Context) (*Officeroom, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Officeroom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOfficeroom sets the old Officeroom of the mutation.
func withOfficeroom(node *Officeroom) officeroomOption {
	return func(m *OfficeroomMutation) {
		m.oldValue = func(context.Context) (*Officeroom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OfficeroomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OfficeroomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OfficeroomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRoomnumber sets the roomnumber field.
func (m *OfficeroomMutation) SetRoomnumber(s string) {
	m.roomnumber = &s
}

// Roomnumber returns the roomnumber value in the mutation.
func (m *OfficeroomMutation) Roomnumber() (r string, exists bool) {
	v := m.roomnumber
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomnumber returns the old roomnumber value of the Officeroom.
// If the Officeroom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OfficeroomMutation) OldRoomnumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomnumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomnumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomnumber: %w", err)
	}
	return oldValue.Roomnumber, nil
}

// ResetRoomnumber reset all changes of the "roomnumber" field.
func (m *OfficeroomMutation) ResetRoomnumber() {
	m.roomnumber = nil
}

// AddEdgesOfOfficeroom2doctorinfoIDs adds the EdgesOfOfficeroom2doctorinfo edge to Doctorinfo by ids.
func (m *OfficeroomMutation) AddEdgesOfOfficeroom2doctorinfoIDs(ids ...int) {
	if m._EdgesOfOfficeroom2doctorinfo == nil {
		m._EdgesOfOfficeroom2doctorinfo = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfOfficeroom2doctorinfo[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfOfficeroom2doctorinfoIDs removes the EdgesOfOfficeroom2doctorinfo edge to Doctorinfo by ids.
func (m *OfficeroomMutation) RemoveEdgesOfOfficeroom2doctorinfoIDs(ids ...int) {
	if m.removed_EdgesOfOfficeroom2doctorinfo == nil {
		m.removed_EdgesOfOfficeroom2doctorinfo = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfOfficeroom2doctorinfo[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfOfficeroom2doctorinfo returns the removed ids of EdgesOfOfficeroom2doctorinfo.
func (m *OfficeroomMutation) RemovedEdgesOfOfficeroom2doctorinfoIDs() (ids []int) {
	for id := range m.removed_EdgesOfOfficeroom2doctorinfo {
		ids = append(ids, id)
	}
	return
}

// EdgesOfOfficeroom2doctorinfoIDs returns the EdgesOfOfficeroom2doctorinfo ids in the mutation.
func (m *OfficeroomMutation) EdgesOfOfficeroom2doctorinfoIDs() (ids []int) {
	for id := range m._EdgesOfOfficeroom2doctorinfo {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfOfficeroom2doctorinfo reset all changes of the "EdgesOfOfficeroom2doctorinfo" edge.
func (m *OfficeroomMutation) ResetEdgesOfOfficeroom2doctorinfo() {
	m._EdgesOfOfficeroom2doctorinfo = nil
	m.removed_EdgesOfOfficeroom2doctorinfo = nil
}

// Op returns the operation name.
func (m *OfficeroomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Officeroom).
func (m *OfficeroomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OfficeroomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.roomnumber != nil {
		fields = append(fields, officeroom.FieldRoomnumber)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OfficeroomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case officeroom.FieldRoomnumber:
		return m.Roomnumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OfficeroomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case officeroom.FieldRoomnumber:
		return m.OldRoomnumber(ctx)
	}
	return nil, fmt.Errorf("unknown Officeroom field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OfficeroomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case officeroom.FieldRoomnumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomnumber(v)
		return nil
	}
	return fmt.Errorf("unknown Officeroom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OfficeroomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OfficeroomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OfficeroomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Officeroom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OfficeroomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OfficeroomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OfficeroomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Officeroom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OfficeroomMutation) ResetField(name string) error {
	switch name {
	case officeroom.FieldRoomnumber:
		m.ResetRoomnumber()
		return nil
	}
	return fmt.Errorf("unknown Officeroom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OfficeroomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._EdgesOfOfficeroom2doctorinfo != nil {
		edges = append(edges, officeroom.EdgeEdgesOfOfficeroom2doctorinfo)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OfficeroomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case officeroom.EdgeEdgesOfOfficeroom2doctorinfo:
		ids := make([]ent.Value, 0, len(m._EdgesOfOfficeroom2doctorinfo))
		for id := range m._EdgesOfOfficeroom2doctorinfo {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OfficeroomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_EdgesOfOfficeroom2doctorinfo != nil {
		edges = append(edges, officeroom.EdgeEdgesOfOfficeroom2doctorinfo)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OfficeroomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case officeroom.EdgeEdgesOfOfficeroom2doctorinfo:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfOfficeroom2doctorinfo))
		for id := range m.removed_EdgesOfOfficeroom2doctorinfo {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OfficeroomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OfficeroomMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OfficeroomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Officeroom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OfficeroomMutation) ResetEdge(name string) error {
	switch name {
	case officeroom.EdgeEdgesOfOfficeroom2doctorinfo:
		m.ResetEdgesOfOfficeroom2doctorinfo()
		return nil
	}
	return fmt.Errorf("unknown Officeroom edge %s", name)
}

// PatientrecordMutation represents an operation that mutate the Patientrecords
// nodes in the graph.
type PatientrecordMutation struct {
	config
	op                                        Op
	typ                                       string
	id                                        *int
	_Name                                     *string
	_Idcardnumber                             *string
	_Age                                      *int
	add_Age                                   *int
	_Disease                                  *string
	_Allergic                                 *string
	_Phonenumber                              *string
	_Email                                    *string
	_Home                                     *string
	_Date                                     *time.Time
	clearedFields                             map[string]struct{}
	_EdgesOfGender                            *int
	cleared_EdgesOfGender                     bool
	_EdgesOfBloodtype                         *int
	cleared_EdgesOfBloodtype                  bool
	_EdgesOfMedicalrecordstaff                *int
	cleared_EdgesOfMedicalrecordstaff         bool
	_EdgesOfPrename                           *int
	cleared_EdgesOfPrename                    bool
	_EdgesOfHistorytaking                     map[int]struct{}
	removed_EdgesOfHistorytaking              map[int]struct{}
	_EdgesOfTreatment                         map[int]struct{}
	removed_EdgesOfTreatment                  map[int]struct{}
	_EdgesOfPatientrecordPatientrights        map[int]struct{}
	removed_EdgesOfPatientrecordPatientrights map[int]struct{}
	done                                      bool
	oldValue                                  func(context.Context) (*Patientrecord, error)
}

var _ ent.Mutation = (*PatientrecordMutation)(nil)

// patientrecordOption allows to manage the mutation configuration using functional options.
type patientrecordOption func(*PatientrecordMutation)

// newPatientrecordMutation creates new mutation for $n.Name.
func newPatientrecordMutation(c config, op Op, opts ...patientrecordOption) *PatientrecordMutation {
	m := &PatientrecordMutation{
		config:        c,
		op:            op,
		typ:           TypePatientrecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientrecordID sets the id field of the mutation.
func withPatientrecordID(id int) patientrecordOption {
	return func(m *PatientrecordMutation) {
		var (
			err   error
			once  sync.Once
			value *Patientrecord
		)
		m.oldValue = func(ctx context.Context) (*Patientrecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patientrecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatientrecord sets the old Patientrecord of the mutation.
func withPatientrecord(node *Patientrecord) patientrecordOption {
	return func(m *PatientrecordMutation) {
		m.oldValue = func(context.Context) (*Patientrecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientrecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientrecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PatientrecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the Name field.
func (m *PatientrecordMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the Name value in the mutation.
func (m *PatientrecordMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old Name value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "Name" field.
func (m *PatientrecordMutation) ResetName() {
	m._Name = nil
}

// SetIdcardnumber sets the Idcardnumber field.
func (m *PatientrecordMutation) SetIdcardnumber(s string) {
	m._Idcardnumber = &s
}

// Idcardnumber returns the Idcardnumber value in the mutation.
func (m *PatientrecordMutation) Idcardnumber() (r string, exists bool) {
	v := m._Idcardnumber
	if v == nil {
		return
	}
	return *v, true
}

// OldIdcardnumber returns the old Idcardnumber value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldIdcardnumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIdcardnumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIdcardnumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdcardnumber: %w", err)
	}
	return oldValue.Idcardnumber, nil
}

// ResetIdcardnumber reset all changes of the "Idcardnumber" field.
func (m *PatientrecordMutation) ResetIdcardnumber() {
	m._Idcardnumber = nil
}

// SetAge sets the Age field.
func (m *PatientrecordMutation) SetAge(i int) {
	m._Age = &i
	m.add_Age = nil
}

// Age returns the Age value in the mutation.
func (m *PatientrecordMutation) Age() (r int, exists bool) {
	v := m._Age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old Age value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAge is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to Age.
func (m *PatientrecordMutation) AddAge(i int) {
	if m.add_Age != nil {
		*m.add_Age += i
	} else {
		m.add_Age = &i
	}
}

// AddedAge returns the value that was added to the Age field in this mutation.
func (m *PatientrecordMutation) AddedAge() (r int, exists bool) {
	v := m.add_Age
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge reset all changes of the "Age" field.
func (m *PatientrecordMutation) ResetAge() {
	m._Age = nil
	m.add_Age = nil
}

// SetDisease sets the Disease field.
func (m *PatientrecordMutation) SetDisease(s string) {
	m._Disease = &s
}

// Disease returns the Disease value in the mutation.
func (m *PatientrecordMutation) Disease() (r string, exists bool) {
	v := m._Disease
	if v == nil {
		return
	}
	return *v, true
}

// OldDisease returns the old Disease value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldDisease(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisease is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisease requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisease: %w", err)
	}
	return oldValue.Disease, nil
}

// ResetDisease reset all changes of the "Disease" field.
func (m *PatientrecordMutation) ResetDisease() {
	m._Disease = nil
}

// SetAllergic sets the Allergic field.
func (m *PatientrecordMutation) SetAllergic(s string) {
	m._Allergic = &s
}

// Allergic returns the Allergic value in the mutation.
func (m *PatientrecordMutation) Allergic() (r string, exists bool) {
	v := m._Allergic
	if v == nil {
		return
	}
	return *v, true
}

// OldAllergic returns the old Allergic value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldAllergic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAllergic is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAllergic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllergic: %w", err)
	}
	return oldValue.Allergic, nil
}

// ResetAllergic reset all changes of the "Allergic" field.
func (m *PatientrecordMutation) ResetAllergic() {
	m._Allergic = nil
}

// SetPhonenumber sets the Phonenumber field.
func (m *PatientrecordMutation) SetPhonenumber(s string) {
	m._Phonenumber = &s
}

// Phonenumber returns the Phonenumber value in the mutation.
func (m *PatientrecordMutation) Phonenumber() (r string, exists bool) {
	v := m._Phonenumber
	if v == nil {
		return
	}
	return *v, true
}

// OldPhonenumber returns the old Phonenumber value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldPhonenumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhonenumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhonenumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhonenumber: %w", err)
	}
	return oldValue.Phonenumber, nil
}

// ResetPhonenumber reset all changes of the "Phonenumber" field.
func (m *PatientrecordMutation) ResetPhonenumber() {
	m._Phonenumber = nil
}

// SetEmail sets the Email field.
func (m *PatientrecordMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the Email value in the mutation.
func (m *PatientrecordMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old Email value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "Email" field.
func (m *PatientrecordMutation) ResetEmail() {
	m._Email = nil
}

// SetHome sets the Home field.
func (m *PatientrecordMutation) SetHome(s string) {
	m._Home = &s
}

// Home returns the Home value in the mutation.
func (m *PatientrecordMutation) Home() (r string, exists bool) {
	v := m._Home
	if v == nil {
		return
	}
	return *v, true
}

// OldHome returns the old Home value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldHome(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHome is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHome: %w", err)
	}
	return oldValue.Home, nil
}

// ResetHome reset all changes of the "Home" field.
func (m *PatientrecordMutation) ResetHome() {
	m._Home = nil
}

// SetDate sets the Date field.
func (m *PatientrecordMutation) SetDate(t time.Time) {
	m._Date = &t
}

// Date returns the Date value in the mutation.
func (m *PatientrecordMutation) Date() (r time.Time, exists bool) {
	v := m._Date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old Date value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate reset all changes of the "Date" field.
func (m *PatientrecordMutation) ResetDate() {
	m._Date = nil
}

// SetEdgesOfGenderID sets the EdgesOfGender edge to Gender by id.
func (m *PatientrecordMutation) SetEdgesOfGenderID(id int) {
	m._EdgesOfGender = &id
}

// ClearEdgesOfGender clears the EdgesOfGender edge to Gender.
func (m *PatientrecordMutation) ClearEdgesOfGender() {
	m.cleared_EdgesOfGender = true
}

// EdgesOfGenderCleared returns if the edge EdgesOfGender was cleared.
func (m *PatientrecordMutation) EdgesOfGenderCleared() bool {
	return m.cleared_EdgesOfGender
}

// EdgesOfGenderID returns the EdgesOfGender id in the mutation.
func (m *PatientrecordMutation) EdgesOfGenderID() (id int, exists bool) {
	if m._EdgesOfGender != nil {
		return *m._EdgesOfGender, true
	}
	return
}

// EdgesOfGenderIDs returns the EdgesOfGender ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfGenderID instead. It exists only for internal usage by the builders.
func (m *PatientrecordMutation) EdgesOfGenderIDs() (ids []int) {
	if id := m._EdgesOfGender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfGender reset all changes of the "EdgesOfGender" edge.
func (m *PatientrecordMutation) ResetEdgesOfGender() {
	m._EdgesOfGender = nil
	m.cleared_EdgesOfGender = false
}

// SetEdgesOfBloodtypeID sets the EdgesOfBloodtype edge to Bloodtype by id.
func (m *PatientrecordMutation) SetEdgesOfBloodtypeID(id int) {
	m._EdgesOfBloodtype = &id
}

// ClearEdgesOfBloodtype clears the EdgesOfBloodtype edge to Bloodtype.
func (m *PatientrecordMutation) ClearEdgesOfBloodtype() {
	m.cleared_EdgesOfBloodtype = true
}

// EdgesOfBloodtypeCleared returns if the edge EdgesOfBloodtype was cleared.
func (m *PatientrecordMutation) EdgesOfBloodtypeCleared() bool {
	return m.cleared_EdgesOfBloodtype
}

// EdgesOfBloodtypeID returns the EdgesOfBloodtype id in the mutation.
func (m *PatientrecordMutation) EdgesOfBloodtypeID() (id int, exists bool) {
	if m._EdgesOfBloodtype != nil {
		return *m._EdgesOfBloodtype, true
	}
	return
}

// EdgesOfBloodtypeIDs returns the EdgesOfBloodtype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfBloodtypeID instead. It exists only for internal usage by the builders.
func (m *PatientrecordMutation) EdgesOfBloodtypeIDs() (ids []int) {
	if id := m._EdgesOfBloodtype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfBloodtype reset all changes of the "EdgesOfBloodtype" edge.
func (m *PatientrecordMutation) ResetEdgesOfBloodtype() {
	m._EdgesOfBloodtype = nil
	m.cleared_EdgesOfBloodtype = false
}

// SetEdgesOfMedicalrecordstaffID sets the EdgesOfMedicalrecordstaff edge to Medicalrecordstaff by id.
func (m *PatientrecordMutation) SetEdgesOfMedicalrecordstaffID(id int) {
	m._EdgesOfMedicalrecordstaff = &id
}

// ClearEdgesOfMedicalrecordstaff clears the EdgesOfMedicalrecordstaff edge to Medicalrecordstaff.
func (m *PatientrecordMutation) ClearEdgesOfMedicalrecordstaff() {
	m.cleared_EdgesOfMedicalrecordstaff = true
}

// EdgesOfMedicalrecordstaffCleared returns if the edge EdgesOfMedicalrecordstaff was cleared.
func (m *PatientrecordMutation) EdgesOfMedicalrecordstaffCleared() bool {
	return m.cleared_EdgesOfMedicalrecordstaff
}

// EdgesOfMedicalrecordstaffID returns the EdgesOfMedicalrecordstaff id in the mutation.
func (m *PatientrecordMutation) EdgesOfMedicalrecordstaffID() (id int, exists bool) {
	if m._EdgesOfMedicalrecordstaff != nil {
		return *m._EdgesOfMedicalrecordstaff, true
	}
	return
}

// EdgesOfMedicalrecordstaffIDs returns the EdgesOfMedicalrecordstaff ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfMedicalrecordstaffID instead. It exists only for internal usage by the builders.
func (m *PatientrecordMutation) EdgesOfMedicalrecordstaffIDs() (ids []int) {
	if id := m._EdgesOfMedicalrecordstaff; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfMedicalrecordstaff reset all changes of the "EdgesOfMedicalrecordstaff" edge.
func (m *PatientrecordMutation) ResetEdgesOfMedicalrecordstaff() {
	m._EdgesOfMedicalrecordstaff = nil
	m.cleared_EdgesOfMedicalrecordstaff = false
}

// SetEdgesOfPrenameID sets the EdgesOfPrename edge to Prename by id.
func (m *PatientrecordMutation) SetEdgesOfPrenameID(id int) {
	m._EdgesOfPrename = &id
}

// ClearEdgesOfPrename clears the EdgesOfPrename edge to Prename.
func (m *PatientrecordMutation) ClearEdgesOfPrename() {
	m.cleared_EdgesOfPrename = true
}

// EdgesOfPrenameCleared returns if the edge EdgesOfPrename was cleared.
func (m *PatientrecordMutation) EdgesOfPrenameCleared() bool {
	return m.cleared_EdgesOfPrename
}

// EdgesOfPrenameID returns the EdgesOfPrename id in the mutation.
func (m *PatientrecordMutation) EdgesOfPrenameID() (id int, exists bool) {
	if m._EdgesOfPrename != nil {
		return *m._EdgesOfPrename, true
	}
	return
}

// EdgesOfPrenameIDs returns the EdgesOfPrename ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfPrenameID instead. It exists only for internal usage by the builders.
func (m *PatientrecordMutation) EdgesOfPrenameIDs() (ids []int) {
	if id := m._EdgesOfPrename; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfPrename reset all changes of the "EdgesOfPrename" edge.
func (m *PatientrecordMutation) ResetEdgesOfPrename() {
	m._EdgesOfPrename = nil
	m.cleared_EdgesOfPrename = false
}

// AddEdgesOfHistorytakingIDs adds the EdgesOfHistorytaking edge to Historytaking by ids.
func (m *PatientrecordMutation) AddEdgesOfHistorytakingIDs(ids ...int) {
	if m._EdgesOfHistorytaking == nil {
		m._EdgesOfHistorytaking = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfHistorytaking[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfHistorytakingIDs removes the EdgesOfHistorytaking edge to Historytaking by ids.
func (m *PatientrecordMutation) RemoveEdgesOfHistorytakingIDs(ids ...int) {
	if m.removed_EdgesOfHistorytaking == nil {
		m.removed_EdgesOfHistorytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfHistorytaking[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfHistorytaking returns the removed ids of EdgesOfHistorytaking.
func (m *PatientrecordMutation) RemovedEdgesOfHistorytakingIDs() (ids []int) {
	for id := range m.removed_EdgesOfHistorytaking {
		ids = append(ids, id)
	}
	return
}

// EdgesOfHistorytakingIDs returns the EdgesOfHistorytaking ids in the mutation.
func (m *PatientrecordMutation) EdgesOfHistorytakingIDs() (ids []int) {
	for id := range m._EdgesOfHistorytaking {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfHistorytaking reset all changes of the "EdgesOfHistorytaking" edge.
func (m *PatientrecordMutation) ResetEdgesOfHistorytaking() {
	m._EdgesOfHistorytaking = nil
	m.removed_EdgesOfHistorytaking = nil
}

// AddEdgesOfTreatmentIDs adds the EdgesOfTreatment edge to Treatment by ids.
func (m *PatientrecordMutation) AddEdgesOfTreatmentIDs(ids ...int) {
	if m._EdgesOfTreatment == nil {
		m._EdgesOfTreatment = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfTreatment[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfTreatmentIDs removes the EdgesOfTreatment edge to Treatment by ids.
func (m *PatientrecordMutation) RemoveEdgesOfTreatmentIDs(ids ...int) {
	if m.removed_EdgesOfTreatment == nil {
		m.removed_EdgesOfTreatment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfTreatment[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfTreatment returns the removed ids of EdgesOfTreatment.
func (m *PatientrecordMutation) RemovedEdgesOfTreatmentIDs() (ids []int) {
	for id := range m.removed_EdgesOfTreatment {
		ids = append(ids, id)
	}
	return
}

// EdgesOfTreatmentIDs returns the EdgesOfTreatment ids in the mutation.
func (m *PatientrecordMutation) EdgesOfTreatmentIDs() (ids []int) {
	for id := range m._EdgesOfTreatment {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfTreatment reset all changes of the "EdgesOfTreatment" edge.
func (m *PatientrecordMutation) ResetEdgesOfTreatment() {
	m._EdgesOfTreatment = nil
	m.removed_EdgesOfTreatment = nil
}

// AddEdgesOfPatientrecordPatientrightIDs adds the EdgesOfPatientrecordPatientrights edge to Patientrights by ids.
func (m *PatientrecordMutation) AddEdgesOfPatientrecordPatientrightIDs(ids ...int) {
	if m._EdgesOfPatientrecordPatientrights == nil {
		m._EdgesOfPatientrecordPatientrights = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfPatientrecordPatientrights[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfPatientrecordPatientrightIDs removes the EdgesOfPatientrecordPatientrights edge to Patientrights by ids.
func (m *PatientrecordMutation) RemoveEdgesOfPatientrecordPatientrightIDs(ids ...int) {
	if m.removed_EdgesOfPatientrecordPatientrights == nil {
		m.removed_EdgesOfPatientrecordPatientrights = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfPatientrecordPatientrights[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfPatientrecordPatientrights returns the removed ids of EdgesOfPatientrecordPatientrights.
func (m *PatientrecordMutation) RemovedEdgesOfPatientrecordPatientrightsIDs() (ids []int) {
	for id := range m.removed_EdgesOfPatientrecordPatientrights {
		ids = append(ids, id)
	}
	return
}

// EdgesOfPatientrecordPatientrightsIDs returns the EdgesOfPatientrecordPatientrights ids in the mutation.
func (m *PatientrecordMutation) EdgesOfPatientrecordPatientrightsIDs() (ids []int) {
	for id := range m._EdgesOfPatientrecordPatientrights {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfPatientrecordPatientrights reset all changes of the "EdgesOfPatientrecordPatientrights" edge.
func (m *PatientrecordMutation) ResetEdgesOfPatientrecordPatientrights() {
	m._EdgesOfPatientrecordPatientrights = nil
	m.removed_EdgesOfPatientrecordPatientrights = nil
}

// Op returns the operation name.
func (m *PatientrecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Patientrecord).
func (m *PatientrecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PatientrecordMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._Name != nil {
		fields = append(fields, patientrecord.FieldName)
	}
	if m._Idcardnumber != nil {
		fields = append(fields, patientrecord.FieldIdcardnumber)
	}
	if m._Age != nil {
		fields = append(fields, patientrecord.FieldAge)
	}
	if m._Disease != nil {
		fields = append(fields, patientrecord.FieldDisease)
	}
	if m._Allergic != nil {
		fields = append(fields, patientrecord.FieldAllergic)
	}
	if m._Phonenumber != nil {
		fields = append(fields, patientrecord.FieldPhonenumber)
	}
	if m._Email != nil {
		fields = append(fields, patientrecord.FieldEmail)
	}
	if m._Home != nil {
		fields = append(fields, patientrecord.FieldHome)
	}
	if m._Date != nil {
		fields = append(fields, patientrecord.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PatientrecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patientrecord.FieldName:
		return m.Name()
	case patientrecord.FieldIdcardnumber:
		return m.Idcardnumber()
	case patientrecord.FieldAge:
		return m.Age()
	case patientrecord.FieldDisease:
		return m.Disease()
	case patientrecord.FieldAllergic:
		return m.Allergic()
	case patientrecord.FieldPhonenumber:
		return m.Phonenumber()
	case patientrecord.FieldEmail:
		return m.Email()
	case patientrecord.FieldHome:
		return m.Home()
	case patientrecord.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PatientrecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patientrecord.FieldName:
		return m.OldName(ctx)
	case patientrecord.FieldIdcardnumber:
		return m.OldIdcardnumber(ctx)
	case patientrecord.FieldAge:
		return m.OldAge(ctx)
	case patientrecord.FieldDisease:
		return m.OldDisease(ctx)
	case patientrecord.FieldAllergic:
		return m.OldAllergic(ctx)
	case patientrecord.FieldPhonenumber:
		return m.OldPhonenumber(ctx)
	case patientrecord.FieldEmail:
		return m.OldEmail(ctx)
	case patientrecord.FieldHome:
		return m.OldHome(ctx)
	case patientrecord.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown Patientrecord field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientrecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patientrecord.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case patientrecord.FieldIdcardnumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdcardnumber(v)
		return nil
	case patientrecord.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case patientrecord.FieldDisease:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisease(v)
		return nil
	case patientrecord.FieldAllergic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllergic(v)
		return nil
	case patientrecord.FieldPhonenumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhonenumber(v)
		return nil
	case patientrecord.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case patientrecord.FieldHome:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHome(v)
		return nil
	case patientrecord.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown Patientrecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PatientrecordMutation) AddedFields() []string {
	var fields []string
	if m.add_Age != nil {
		fields = append(fields, patientrecord.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PatientrecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case patientrecord.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientrecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case patientrecord.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown Patientrecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PatientrecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PatientrecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientrecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Patientrecord nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PatientrecordMutation) ResetField(name string) error {
	switch name {
	case patientrecord.FieldName:
		m.ResetName()
		return nil
	case patientrecord.FieldIdcardnumber:
		m.ResetIdcardnumber()
		return nil
	case patientrecord.FieldAge:
		m.ResetAge()
		return nil
	case patientrecord.FieldDisease:
		m.ResetDisease()
		return nil
	case patientrecord.FieldAllergic:
		m.ResetAllergic()
		return nil
	case patientrecord.FieldPhonenumber:
		m.ResetPhonenumber()
		return nil
	case patientrecord.FieldEmail:
		m.ResetEmail()
		return nil
	case patientrecord.FieldHome:
		m.ResetHome()
		return nil
	case patientrecord.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown Patientrecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PatientrecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m._EdgesOfGender != nil {
		edges = append(edges, patientrecord.EdgeEdgesOfGender)
	}
	if m._EdgesOfBloodtype != nil {
		edges = append(edges, patientrecord.EdgeEdgesOfBloodtype)
	}
	if m._EdgesOfMedicalrecordstaff != nil {
		edges = append(edges, patientrecord.EdgeEdgesOfMedicalrecordstaff)
	}
	if m._EdgesOfPrename != nil {
		edges = append(edges, patientrecord.EdgeEdgesOfPrename)
	}
	if m._EdgesOfHistorytaking != nil {
		edges = append(edges, patientrecord.EdgeEdgesOfHistorytaking)
	}
	if m._EdgesOfTreatment != nil {
		edges = append(edges, patientrecord.EdgeEdgesOfTreatment)
	}
	if m._EdgesOfPatientrecordPatientrights != nil {
		edges = append(edges, patientrecord.EdgeEdgesOfPatientrecordPatientrights)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PatientrecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patientrecord.EdgeEdgesOfGender:
		if id := m._EdgesOfGender; id != nil {
			return []ent.Value{*id}
		}
	case patientrecord.EdgeEdgesOfBloodtype:
		if id := m._EdgesOfBloodtype; id != nil {
			return []ent.Value{*id}
		}
	case patientrecord.EdgeEdgesOfMedicalrecordstaff:
		if id := m._EdgesOfMedicalrecordstaff; id != nil {
			return []ent.Value{*id}
		}
	case patientrecord.EdgeEdgesOfPrename:
		if id := m._EdgesOfPrename; id != nil {
			return []ent.Value{*id}
		}
	case patientrecord.EdgeEdgesOfHistorytaking:
		ids := make([]ent.Value, 0, len(m._EdgesOfHistorytaking))
		for id := range m._EdgesOfHistorytaking {
			ids = append(ids, id)
		}
		return ids
	case patientrecord.EdgeEdgesOfTreatment:
		ids := make([]ent.Value, 0, len(m._EdgesOfTreatment))
		for id := range m._EdgesOfTreatment {
			ids = append(ids, id)
		}
		return ids
	case patientrecord.EdgeEdgesOfPatientrecordPatientrights:
		ids := make([]ent.Value, 0, len(m._EdgesOfPatientrecordPatientrights))
		for id := range m._EdgesOfPatientrecordPatientrights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PatientrecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removed_EdgesOfHistorytaking != nil {
		edges = append(edges, patientrecord.EdgeEdgesOfHistorytaking)
	}
	if m.removed_EdgesOfTreatment != nil {
		edges = append(edges, patientrecord.EdgeEdgesOfTreatment)
	}
	if m.removed_EdgesOfPatientrecordPatientrights != nil {
		edges = append(edges, patientrecord.EdgeEdgesOfPatientrecordPatientrights)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PatientrecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patientrecord.EdgeEdgesOfHistorytaking:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfHistorytaking))
		for id := range m.removed_EdgesOfHistorytaking {
			ids = append(ids, id)
		}
		return ids
	case patientrecord.EdgeEdgesOfTreatment:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfTreatment))
		for id := range m.removed_EdgesOfTreatment {
			ids = append(ids, id)
		}
		return ids
	case patientrecord.EdgeEdgesOfPatientrecordPatientrights:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfPatientrecordPatientrights))
		for id := range m.removed_EdgesOfPatientrecordPatientrights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PatientrecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cleared_EdgesOfGender {
		edges = append(edges, patientrecord.EdgeEdgesOfGender)
	}
	if m.cleared_EdgesOfBloodtype {
		edges = append(edges, patientrecord.EdgeEdgesOfBloodtype)
	}
	if m.cleared_EdgesOfMedicalrecordstaff {
		edges = append(edges, patientrecord.EdgeEdgesOfMedicalrecordstaff)
	}
	if m.cleared_EdgesOfPrename {
		edges = append(edges, patientrecord.EdgeEdgesOfPrename)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PatientrecordMutation) EdgeCleared(name string) bool {
	switch name {
	case patientrecord.EdgeEdgesOfGender:
		return m.cleared_EdgesOfGender
	case patientrecord.EdgeEdgesOfBloodtype:
		return m.cleared_EdgesOfBloodtype
	case patientrecord.EdgeEdgesOfMedicalrecordstaff:
		return m.cleared_EdgesOfMedicalrecordstaff
	case patientrecord.EdgeEdgesOfPrename:
		return m.cleared_EdgesOfPrename
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PatientrecordMutation) ClearEdge(name string) error {
	switch name {
	case patientrecord.EdgeEdgesOfGender:
		m.ClearEdgesOfGender()
		return nil
	case patientrecord.EdgeEdgesOfBloodtype:
		m.ClearEdgesOfBloodtype()
		return nil
	case patientrecord.EdgeEdgesOfMedicalrecordstaff:
		m.ClearEdgesOfMedicalrecordstaff()
		return nil
	case patientrecord.EdgeEdgesOfPrename:
		m.ClearEdgesOfPrename()
		return nil
	}
	return fmt.Errorf("unknown Patientrecord unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PatientrecordMutation) ResetEdge(name string) error {
	switch name {
	case patientrecord.EdgeEdgesOfGender:
		m.ResetEdgesOfGender()
		return nil
	case patientrecord.EdgeEdgesOfBloodtype:
		m.ResetEdgesOfBloodtype()
		return nil
	case patientrecord.EdgeEdgesOfMedicalrecordstaff:
		m.ResetEdgesOfMedicalrecordstaff()
		return nil
	case patientrecord.EdgeEdgesOfPrename:
		m.ResetEdgesOfPrename()
		return nil
	case patientrecord.EdgeEdgesOfHistorytaking:
		m.ResetEdgesOfHistorytaking()
		return nil
	case patientrecord.EdgeEdgesOfTreatment:
		m.ResetEdgesOfTreatment()
		return nil
	case patientrecord.EdgeEdgesOfPatientrecordPatientrights:
		m.ResetEdgesOfPatientrecordPatientrights()
		return nil
	}
	return fmt.Errorf("unknown Patientrecord edge %s", name)
}

// PatientrightsMutation represents an operation that mutate the PatientrightsSlice
// nodes in the graph.
type PatientrightsMutation struct {
	config
	op                                               Op
	typ                                              string
	id                                               *int
	_PermissionDate                                  *time.Time
	_Permission                                      *string
	_PermissionArea                                  *string
	_Responsible                                     *string
	clearedFields                                    map[string]struct{}
	_EdgesOfPatientrightsAbilitypatientrights        *int
	cleared_EdgesOfPatientrightsAbilitypatientrights bool
	_EdgesOfPatientrightsInsurance                   *int
	cleared_EdgesOfPatientrightsInsurance            bool
	_EdgesOfPatientrightsPatientrecord               *int
	cleared_EdgesOfPatientrightsPatientrecord        bool
	_EdgesOfPatientrightsMedicalrecordstaff          *int
	cleared_EdgesOfPatientrightsMedicalrecordstaff   bool
	done                                             bool
	oldValue                                         func(context.Context) (*Patientrights, error)
}

var _ ent.Mutation = (*PatientrightsMutation)(nil)

// patientrightsOption allows to manage the mutation configuration using functional options.
type patientrightsOption func(*PatientrightsMutation)

// newPatientrightsMutation creates new mutation for $n.Name.
func newPatientrightsMutation(c config, op Op, opts ...patientrightsOption) *PatientrightsMutation {
	m := &PatientrightsMutation{
		config:        c,
		op:            op,
		typ:           TypePatientrights,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientrightsID sets the id field of the mutation.
func withPatientrightsID(id int) patientrightsOption {
	return func(m *PatientrightsMutation) {
		var (
			err   error
			once  sync.Once
			value *Patientrights
		)
		m.oldValue = func(ctx context.Context) (*Patientrights, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patientrights.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatientrights sets the old Patientrights of the mutation.
func withPatientrights(node *Patientrights) patientrightsOption {
	return func(m *PatientrightsMutation) {
		m.oldValue = func(context.Context) (*Patientrights, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientrightsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientrightsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PatientrightsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPermissionDate sets the PermissionDate field.
func (m *PatientrightsMutation) SetPermissionDate(t time.Time) {
	m._PermissionDate = &t
}

// PermissionDate returns the PermissionDate value in the mutation.
func (m *PatientrightsMutation) PermissionDate() (r time.Time, exists bool) {
	v := m._PermissionDate
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionDate returns the old PermissionDate value of the Patientrights.
// If the Patientrights object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrightsMutation) OldPermissionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPermissionDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPermissionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionDate: %w", err)
	}
	return oldValue.PermissionDate, nil
}

// ResetPermissionDate reset all changes of the "PermissionDate" field.
func (m *PatientrightsMutation) ResetPermissionDate() {
	m._PermissionDate = nil
}

// SetPermission sets the Permission field.
func (m *PatientrightsMutation) SetPermission(s string) {
	m._Permission = &s
}

// Permission returns the Permission value in the mutation.
func (m *PatientrightsMutation) Permission() (r string, exists bool) {
	v := m._Permission
	if v == nil {
		return
	}
	return *v, true
}

// OldPermission returns the old Permission value of the Patientrights.
// If the Patientrights object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrightsMutation) OldPermission(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPermission is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPermission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermission: %w", err)
	}
	return oldValue.Permission, nil
}

// ResetPermission reset all changes of the "Permission" field.
func (m *PatientrightsMutation) ResetPermission() {
	m._Permission = nil
}

// SetPermissionArea sets the PermissionArea field.
func (m *PatientrightsMutation) SetPermissionArea(s string) {
	m._PermissionArea = &s
}

// PermissionArea returns the PermissionArea value in the mutation.
func (m *PatientrightsMutation) PermissionArea() (r string, exists bool) {
	v := m._PermissionArea
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionArea returns the old PermissionArea value of the Patientrights.
// If the Patientrights object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrightsMutation) OldPermissionArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPermissionArea is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPermissionArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionArea: %w", err)
	}
	return oldValue.PermissionArea, nil
}

// ResetPermissionArea reset all changes of the "PermissionArea" field.
func (m *PatientrightsMutation) ResetPermissionArea() {
	m._PermissionArea = nil
}

// SetResponsible sets the Responsible field.
func (m *PatientrightsMutation) SetResponsible(s string) {
	m._Responsible = &s
}

// Responsible returns the Responsible value in the mutation.
func (m *PatientrightsMutation) Responsible() (r string, exists bool) {
	v := m._Responsible
	if v == nil {
		return
	}
	return *v, true
}

// OldResponsible returns the old Responsible value of the Patientrights.
// If the Patientrights object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrightsMutation) OldResponsible(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResponsible is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResponsible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponsible: %w", err)
	}
	return oldValue.Responsible, nil
}

// ResetResponsible reset all changes of the "Responsible" field.
func (m *PatientrightsMutation) ResetResponsible() {
	m._Responsible = nil
}

// SetEdgesOfPatientrightsAbilitypatientrightsID sets the EdgesOfPatientrightsAbilitypatientrights edge to Abilitypatientrights by id.
func (m *PatientrightsMutation) SetEdgesOfPatientrightsAbilitypatientrightsID(id int) {
	m._EdgesOfPatientrightsAbilitypatientrights = &id
}

// ClearEdgesOfPatientrightsAbilitypatientrights clears the EdgesOfPatientrightsAbilitypatientrights edge to Abilitypatientrights.
func (m *PatientrightsMutation) ClearEdgesOfPatientrightsAbilitypatientrights() {
	m.cleared_EdgesOfPatientrightsAbilitypatientrights = true
}

// EdgesOfPatientrightsAbilitypatientrightsCleared returns if the edge EdgesOfPatientrightsAbilitypatientrights was cleared.
func (m *PatientrightsMutation) EdgesOfPatientrightsAbilitypatientrightsCleared() bool {
	return m.cleared_EdgesOfPatientrightsAbilitypatientrights
}

// EdgesOfPatientrightsAbilitypatientrightsID returns the EdgesOfPatientrightsAbilitypatientrights id in the mutation.
func (m *PatientrightsMutation) EdgesOfPatientrightsAbilitypatientrightsID() (id int, exists bool) {
	if m._EdgesOfPatientrightsAbilitypatientrights != nil {
		return *m._EdgesOfPatientrightsAbilitypatientrights, true
	}
	return
}

// EdgesOfPatientrightsAbilitypatientrightsIDs returns the EdgesOfPatientrightsAbilitypatientrights ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfPatientrightsAbilitypatientrightsID instead. It exists only for internal usage by the builders.
func (m *PatientrightsMutation) EdgesOfPatientrightsAbilitypatientrightsIDs() (ids []int) {
	if id := m._EdgesOfPatientrightsAbilitypatientrights; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfPatientrightsAbilitypatientrights reset all changes of the "EdgesOfPatientrightsAbilitypatientrights" edge.
func (m *PatientrightsMutation) ResetEdgesOfPatientrightsAbilitypatientrights() {
	m._EdgesOfPatientrightsAbilitypatientrights = nil
	m.cleared_EdgesOfPatientrightsAbilitypatientrights = false
}

// SetEdgesOfPatientrightsInsuranceID sets the EdgesOfPatientrightsInsurance edge to Insurance by id.
func (m *PatientrightsMutation) SetEdgesOfPatientrightsInsuranceID(id int) {
	m._EdgesOfPatientrightsInsurance = &id
}

// ClearEdgesOfPatientrightsInsurance clears the EdgesOfPatientrightsInsurance edge to Insurance.
func (m *PatientrightsMutation) ClearEdgesOfPatientrightsInsurance() {
	m.cleared_EdgesOfPatientrightsInsurance = true
}

// EdgesOfPatientrightsInsuranceCleared returns if the edge EdgesOfPatientrightsInsurance was cleared.
func (m *PatientrightsMutation) EdgesOfPatientrightsInsuranceCleared() bool {
	return m.cleared_EdgesOfPatientrightsInsurance
}

// EdgesOfPatientrightsInsuranceID returns the EdgesOfPatientrightsInsurance id in the mutation.
func (m *PatientrightsMutation) EdgesOfPatientrightsInsuranceID() (id int, exists bool) {
	if m._EdgesOfPatientrightsInsurance != nil {
		return *m._EdgesOfPatientrightsInsurance, true
	}
	return
}

// EdgesOfPatientrightsInsuranceIDs returns the EdgesOfPatientrightsInsurance ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfPatientrightsInsuranceID instead. It exists only for internal usage by the builders.
func (m *PatientrightsMutation) EdgesOfPatientrightsInsuranceIDs() (ids []int) {
	if id := m._EdgesOfPatientrightsInsurance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfPatientrightsInsurance reset all changes of the "EdgesOfPatientrightsInsurance" edge.
func (m *PatientrightsMutation) ResetEdgesOfPatientrightsInsurance() {
	m._EdgesOfPatientrightsInsurance = nil
	m.cleared_EdgesOfPatientrightsInsurance = false
}

// SetEdgesOfPatientrightsPatientrecordID sets the EdgesOfPatientrightsPatientrecord edge to Patientrecord by id.
func (m *PatientrightsMutation) SetEdgesOfPatientrightsPatientrecordID(id int) {
	m._EdgesOfPatientrightsPatientrecord = &id
}

// ClearEdgesOfPatientrightsPatientrecord clears the EdgesOfPatientrightsPatientrecord edge to Patientrecord.
func (m *PatientrightsMutation) ClearEdgesOfPatientrightsPatientrecord() {
	m.cleared_EdgesOfPatientrightsPatientrecord = true
}

// EdgesOfPatientrightsPatientrecordCleared returns if the edge EdgesOfPatientrightsPatientrecord was cleared.
func (m *PatientrightsMutation) EdgesOfPatientrightsPatientrecordCleared() bool {
	return m.cleared_EdgesOfPatientrightsPatientrecord
}

// EdgesOfPatientrightsPatientrecordID returns the EdgesOfPatientrightsPatientrecord id in the mutation.
func (m *PatientrightsMutation) EdgesOfPatientrightsPatientrecordID() (id int, exists bool) {
	if m._EdgesOfPatientrightsPatientrecord != nil {
		return *m._EdgesOfPatientrightsPatientrecord, true
	}
	return
}

// EdgesOfPatientrightsPatientrecordIDs returns the EdgesOfPatientrightsPatientrecord ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfPatientrightsPatientrecordID instead. It exists only for internal usage by the builders.
func (m *PatientrightsMutation) EdgesOfPatientrightsPatientrecordIDs() (ids []int) {
	if id := m._EdgesOfPatientrightsPatientrecord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfPatientrightsPatientrecord reset all changes of the "EdgesOfPatientrightsPatientrecord" edge.
func (m *PatientrightsMutation) ResetEdgesOfPatientrightsPatientrecord() {
	m._EdgesOfPatientrightsPatientrecord = nil
	m.cleared_EdgesOfPatientrightsPatientrecord = false
}

// SetEdgesOfPatientrightsMedicalrecordstaffID sets the EdgesOfPatientrightsMedicalrecordstaff edge to Medicalrecordstaff by id.
func (m *PatientrightsMutation) SetEdgesOfPatientrightsMedicalrecordstaffID(id int) {
	m._EdgesOfPatientrightsMedicalrecordstaff = &id
}

// ClearEdgesOfPatientrightsMedicalrecordstaff clears the EdgesOfPatientrightsMedicalrecordstaff edge to Medicalrecordstaff.
func (m *PatientrightsMutation) ClearEdgesOfPatientrightsMedicalrecordstaff() {
	m.cleared_EdgesOfPatientrightsMedicalrecordstaff = true
}

// EdgesOfPatientrightsMedicalrecordstaffCleared returns if the edge EdgesOfPatientrightsMedicalrecordstaff was cleared.
func (m *PatientrightsMutation) EdgesOfPatientrightsMedicalrecordstaffCleared() bool {
	return m.cleared_EdgesOfPatientrightsMedicalrecordstaff
}

// EdgesOfPatientrightsMedicalrecordstaffID returns the EdgesOfPatientrightsMedicalrecordstaff id in the mutation.
func (m *PatientrightsMutation) EdgesOfPatientrightsMedicalrecordstaffID() (id int, exists bool) {
	if m._EdgesOfPatientrightsMedicalrecordstaff != nil {
		return *m._EdgesOfPatientrightsMedicalrecordstaff, true
	}
	return
}

// EdgesOfPatientrightsMedicalrecordstaffIDs returns the EdgesOfPatientrightsMedicalrecordstaff ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfPatientrightsMedicalrecordstaffID instead. It exists only for internal usage by the builders.
func (m *PatientrightsMutation) EdgesOfPatientrightsMedicalrecordstaffIDs() (ids []int) {
	if id := m._EdgesOfPatientrightsMedicalrecordstaff; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfPatientrightsMedicalrecordstaff reset all changes of the "EdgesOfPatientrightsMedicalrecordstaff" edge.
func (m *PatientrightsMutation) ResetEdgesOfPatientrightsMedicalrecordstaff() {
	m._EdgesOfPatientrightsMedicalrecordstaff = nil
	m.cleared_EdgesOfPatientrightsMedicalrecordstaff = false
}

// Op returns the operation name.
func (m *PatientrightsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Patientrights).
func (m *PatientrightsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PatientrightsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._PermissionDate != nil {
		fields = append(fields, patientrights.FieldPermissionDate)
	}
	if m._Permission != nil {
		fields = append(fields, patientrights.FieldPermission)
	}
	if m._PermissionArea != nil {
		fields = append(fields, patientrights.FieldPermissionArea)
	}
	if m._Responsible != nil {
		fields = append(fields, patientrights.FieldResponsible)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PatientrightsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patientrights.FieldPermissionDate:
		return m.PermissionDate()
	case patientrights.FieldPermission:
		return m.Permission()
	case patientrights.FieldPermissionArea:
		return m.PermissionArea()
	case patientrights.FieldResponsible:
		return m.Responsible()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PatientrightsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patientrights.FieldPermissionDate:
		return m.OldPermissionDate(ctx)
	case patientrights.FieldPermission:
		return m.OldPermission(ctx)
	case patientrights.FieldPermissionArea:
		return m.OldPermissionArea(ctx)
	case patientrights.FieldResponsible:
		return m.OldResponsible(ctx)
	}
	return nil, fmt.Errorf("unknown Patientrights field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientrightsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patientrights.FieldPermissionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionDate(v)
		return nil
	case patientrights.FieldPermission:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermission(v)
		return nil
	case patientrights.FieldPermissionArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionArea(v)
		return nil
	case patientrights.FieldResponsible:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponsible(v)
		return nil
	}
	return fmt.Errorf("unknown Patientrights field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PatientrightsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PatientrightsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientrightsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Patientrights numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PatientrightsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PatientrightsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientrightsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Patientrights nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PatientrightsMutation) ResetField(name string) error {
	switch name {
	case patientrights.FieldPermissionDate:
		m.ResetPermissionDate()
		return nil
	case patientrights.FieldPermission:
		m.ResetPermission()
		return nil
	case patientrights.FieldPermissionArea:
		m.ResetPermissionArea()
		return nil
	case patientrights.FieldResponsible:
		m.ResetResponsible()
		return nil
	}
	return fmt.Errorf("unknown Patientrights field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PatientrightsMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._EdgesOfPatientrightsAbilitypatientrights != nil {
		edges = append(edges, patientrights.EdgeEdgesOfPatientrightsAbilitypatientrights)
	}
	if m._EdgesOfPatientrightsInsurance != nil {
		edges = append(edges, patientrights.EdgeEdgesOfPatientrightsInsurance)
	}
	if m._EdgesOfPatientrightsPatientrecord != nil {
		edges = append(edges, patientrights.EdgeEdgesOfPatientrightsPatientrecord)
	}
	if m._EdgesOfPatientrightsMedicalrecordstaff != nil {
		edges = append(edges, patientrights.EdgeEdgesOfPatientrightsMedicalrecordstaff)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PatientrightsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patientrights.EdgeEdgesOfPatientrightsAbilitypatientrights:
		if id := m._EdgesOfPatientrightsAbilitypatientrights; id != nil {
			return []ent.Value{*id}
		}
	case patientrights.EdgeEdgesOfPatientrightsInsurance:
		if id := m._EdgesOfPatientrightsInsurance; id != nil {
			return []ent.Value{*id}
		}
	case patientrights.EdgeEdgesOfPatientrightsPatientrecord:
		if id := m._EdgesOfPatientrightsPatientrecord; id != nil {
			return []ent.Value{*id}
		}
	case patientrights.EdgeEdgesOfPatientrightsMedicalrecordstaff:
		if id := m._EdgesOfPatientrightsMedicalrecordstaff; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PatientrightsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PatientrightsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PatientrightsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_EdgesOfPatientrightsAbilitypatientrights {
		edges = append(edges, patientrights.EdgeEdgesOfPatientrightsAbilitypatientrights)
	}
	if m.cleared_EdgesOfPatientrightsInsurance {
		edges = append(edges, patientrights.EdgeEdgesOfPatientrightsInsurance)
	}
	if m.cleared_EdgesOfPatientrightsPatientrecord {
		edges = append(edges, patientrights.EdgeEdgesOfPatientrightsPatientrecord)
	}
	if m.cleared_EdgesOfPatientrightsMedicalrecordstaff {
		edges = append(edges, patientrights.EdgeEdgesOfPatientrightsMedicalrecordstaff)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PatientrightsMutation) EdgeCleared(name string) bool {
	switch name {
	case patientrights.EdgeEdgesOfPatientrightsAbilitypatientrights:
		return m.cleared_EdgesOfPatientrightsAbilitypatientrights
	case patientrights.EdgeEdgesOfPatientrightsInsurance:
		return m.cleared_EdgesOfPatientrightsInsurance
	case patientrights.EdgeEdgesOfPatientrightsPatientrecord:
		return m.cleared_EdgesOfPatientrightsPatientrecord
	case patientrights.EdgeEdgesOfPatientrightsMedicalrecordstaff:
		return m.cleared_EdgesOfPatientrightsMedicalrecordstaff
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PatientrightsMutation) ClearEdge(name string) error {
	switch name {
	case patientrights.EdgeEdgesOfPatientrightsAbilitypatientrights:
		m.ClearEdgesOfPatientrightsAbilitypatientrights()
		return nil
	case patientrights.EdgeEdgesOfPatientrightsInsurance:
		m.ClearEdgesOfPatientrightsInsurance()
		return nil
	case patientrights.EdgeEdgesOfPatientrightsPatientrecord:
		m.ClearEdgesOfPatientrightsPatientrecord()
		return nil
	case patientrights.EdgeEdgesOfPatientrightsMedicalrecordstaff:
		m.ClearEdgesOfPatientrightsMedicalrecordstaff()
		return nil
	}
	return fmt.Errorf("unknown Patientrights unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PatientrightsMutation) ResetEdge(name string) error {
	switch name {
	case patientrights.EdgeEdgesOfPatientrightsAbilitypatientrights:
		m.ResetEdgesOfPatientrightsAbilitypatientrights()
		return nil
	case patientrights.EdgeEdgesOfPatientrightsInsurance:
		m.ResetEdgesOfPatientrightsInsurance()
		return nil
	case patientrights.EdgeEdgesOfPatientrightsPatientrecord:
		m.ResetEdgesOfPatientrightsPatientrecord()
		return nil
	case patientrights.EdgeEdgesOfPatientrightsMedicalrecordstaff:
		m.ResetEdgesOfPatientrightsMedicalrecordstaff()
		return nil
	}
	return fmt.Errorf("unknown Patientrights edge %s", name)
}

// PaytypeMutation represents an operation that mutate the Paytypes
// nodes in the graph.
type PaytypeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	paytype              *string
	clearedFields        map[string]struct{}
	_EdgesOfBills        map[int]struct{}
	removed_EdgesOfBills map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Paytype, error)
}

var _ ent.Mutation = (*PaytypeMutation)(nil)

// paytypeOption allows to manage the mutation configuration using functional options.
type paytypeOption func(*PaytypeMutation)

// newPaytypeMutation creates new mutation for $n.Name.
func newPaytypeMutation(c config, op Op, opts ...paytypeOption) *PaytypeMutation {
	m := &PaytypeMutation{
		config:        c,
		op:            op,
		typ:           TypePaytype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaytypeID sets the id field of the mutation.
func withPaytypeID(id int) paytypeOption {
	return func(m *PaytypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Paytype
		)
		m.oldValue = func(ctx context.Context) (*Paytype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Paytype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaytype sets the old Paytype of the mutation.
func withPaytype(node *Paytype) paytypeOption {
	return func(m *PaytypeMutation) {
		m.oldValue = func(context.Context) (*Paytype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaytypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaytypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PaytypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPaytype sets the paytype field.
func (m *PaytypeMutation) SetPaytype(s string) {
	m.paytype = &s
}

// Paytype returns the paytype value in the mutation.
func (m *PaytypeMutation) Paytype() (r string, exists bool) {
	v := m.paytype
	if v == nil {
		return
	}
	return *v, true
}

// OldPaytype returns the old paytype value of the Paytype.
// If the Paytype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PaytypeMutation) OldPaytype(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaytype is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaytype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaytype: %w", err)
	}
	return oldValue.Paytype, nil
}

// ResetPaytype reset all changes of the "paytype" field.
func (m *PaytypeMutation) ResetPaytype() {
	m.paytype = nil
}

// AddEdgesOfBillIDs adds the EdgesOfBills edge to Bill by ids.
func (m *PaytypeMutation) AddEdgesOfBillIDs(ids ...int) {
	if m._EdgesOfBills == nil {
		m._EdgesOfBills = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfBills[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfBillIDs removes the EdgesOfBills edge to Bill by ids.
func (m *PaytypeMutation) RemoveEdgesOfBillIDs(ids ...int) {
	if m.removed_EdgesOfBills == nil {
		m.removed_EdgesOfBills = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfBills[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfBills returns the removed ids of EdgesOfBills.
func (m *PaytypeMutation) RemovedEdgesOfBillsIDs() (ids []int) {
	for id := range m.removed_EdgesOfBills {
		ids = append(ids, id)
	}
	return
}

// EdgesOfBillsIDs returns the EdgesOfBills ids in the mutation.
func (m *PaytypeMutation) EdgesOfBillsIDs() (ids []int) {
	for id := range m._EdgesOfBills {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfBills reset all changes of the "EdgesOfBills" edge.
func (m *PaytypeMutation) ResetEdgesOfBills() {
	m._EdgesOfBills = nil
	m.removed_EdgesOfBills = nil
}

// Op returns the operation name.
func (m *PaytypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Paytype).
func (m *PaytypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PaytypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.paytype != nil {
		fields = append(fields, paytype.FieldPaytype)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PaytypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paytype.FieldPaytype:
		return m.Paytype()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PaytypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paytype.FieldPaytype:
		return m.OldPaytype(ctx)
	}
	return nil, fmt.Errorf("unknown Paytype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaytypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paytype.FieldPaytype:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaytype(v)
		return nil
	}
	return fmt.Errorf("unknown Paytype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PaytypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PaytypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaytypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Paytype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PaytypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PaytypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaytypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Paytype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PaytypeMutation) ResetField(name string) error {
	switch name {
	case paytype.FieldPaytype:
		m.ResetPaytype()
		return nil
	}
	return fmt.Errorf("unknown Paytype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PaytypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._EdgesOfBills != nil {
		edges = append(edges, paytype.EdgeEdgesOfBills)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PaytypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paytype.EdgeEdgesOfBills:
		ids := make([]ent.Value, 0, len(m._EdgesOfBills))
		for id := range m._EdgesOfBills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PaytypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_EdgesOfBills != nil {
		edges = append(edges, paytype.EdgeEdgesOfBills)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PaytypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case paytype.EdgeEdgesOfBills:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfBills))
		for id := range m.removed_EdgesOfBills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PaytypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PaytypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PaytypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Paytype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PaytypeMutation) ResetEdge(name string) error {
	switch name {
	case paytype.EdgeEdgesOfBills:
		m.ResetEdgesOfBills()
		return nil
	}
	return fmt.Errorf("unknown Paytype edge %s", name)
}

// PrenameMutation represents an operation that mutate the Prenames
// nodes in the graph.
type PrenameMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	prefix                            *string
	clearedFields                     map[string]struct{}
	_EdgesOfPrename2doctorinfo        map[int]struct{}
	removed_EdgesOfPrename2doctorinfo map[int]struct{}
	_EdgesOfPatientrecord             map[int]struct{}
	removed_EdgesOfPatientrecord      map[int]struct{}
	done                              bool
	oldValue                          func(context.Context) (*Prename, error)
}

var _ ent.Mutation = (*PrenameMutation)(nil)

// prenameOption allows to manage the mutation configuration using functional options.
type prenameOption func(*PrenameMutation)

// newPrenameMutation creates new mutation for $n.Name.
func newPrenameMutation(c config, op Op, opts ...prenameOption) *PrenameMutation {
	m := &PrenameMutation{
		config:        c,
		op:            op,
		typ:           TypePrename,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrenameID sets the id field of the mutation.
func withPrenameID(id int) prenameOption {
	return func(m *PrenameMutation) {
		var (
			err   error
			once  sync.Once
			value *Prename
		)
		m.oldValue = func(ctx context.Context) (*Prename, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prename.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrename sets the old Prename of the mutation.
func withPrename(node *Prename) prenameOption {
	return func(m *PrenameMutation) {
		m.oldValue = func(context.Context) (*Prename, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrenameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrenameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PrenameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPrefix sets the prefix field.
func (m *PrenameMutation) SetPrefix(s string) {
	m.prefix = &s
}

// Prefix returns the prefix value in the mutation.
func (m *PrenameMutation) Prefix() (r string, exists bool) {
	v := m.prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefix returns the old prefix value of the Prename.
// If the Prename object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PrenameMutation) OldPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrefix is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefix: %w", err)
	}
	return oldValue.Prefix, nil
}

// ResetPrefix reset all changes of the "prefix" field.
func (m *PrenameMutation) ResetPrefix() {
	m.prefix = nil
}

// AddEdgesOfPrename2doctorinfoIDs adds the EdgesOfPrename2doctorinfo edge to Doctorinfo by ids.
func (m *PrenameMutation) AddEdgesOfPrename2doctorinfoIDs(ids ...int) {
	if m._EdgesOfPrename2doctorinfo == nil {
		m._EdgesOfPrename2doctorinfo = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfPrename2doctorinfo[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfPrename2doctorinfoIDs removes the EdgesOfPrename2doctorinfo edge to Doctorinfo by ids.
func (m *PrenameMutation) RemoveEdgesOfPrename2doctorinfoIDs(ids ...int) {
	if m.removed_EdgesOfPrename2doctorinfo == nil {
		m.removed_EdgesOfPrename2doctorinfo = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfPrename2doctorinfo[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfPrename2doctorinfo returns the removed ids of EdgesOfPrename2doctorinfo.
func (m *PrenameMutation) RemovedEdgesOfPrename2doctorinfoIDs() (ids []int) {
	for id := range m.removed_EdgesOfPrename2doctorinfo {
		ids = append(ids, id)
	}
	return
}

// EdgesOfPrename2doctorinfoIDs returns the EdgesOfPrename2doctorinfo ids in the mutation.
func (m *PrenameMutation) EdgesOfPrename2doctorinfoIDs() (ids []int) {
	for id := range m._EdgesOfPrename2doctorinfo {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfPrename2doctorinfo reset all changes of the "EdgesOfPrename2doctorinfo" edge.
func (m *PrenameMutation) ResetEdgesOfPrename2doctorinfo() {
	m._EdgesOfPrename2doctorinfo = nil
	m.removed_EdgesOfPrename2doctorinfo = nil
}

// AddEdgesOfPatientrecordIDs adds the EdgesOfPatientrecord edge to Patientrecord by ids.
func (m *PrenameMutation) AddEdgesOfPatientrecordIDs(ids ...int) {
	if m._EdgesOfPatientrecord == nil {
		m._EdgesOfPatientrecord = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfPatientrecord[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfPatientrecordIDs removes the EdgesOfPatientrecord edge to Patientrecord by ids.
func (m *PrenameMutation) RemoveEdgesOfPatientrecordIDs(ids ...int) {
	if m.removed_EdgesOfPatientrecord == nil {
		m.removed_EdgesOfPatientrecord = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfPatientrecord[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfPatientrecord returns the removed ids of EdgesOfPatientrecord.
func (m *PrenameMutation) RemovedEdgesOfPatientrecordIDs() (ids []int) {
	for id := range m.removed_EdgesOfPatientrecord {
		ids = append(ids, id)
	}
	return
}

// EdgesOfPatientrecordIDs returns the EdgesOfPatientrecord ids in the mutation.
func (m *PrenameMutation) EdgesOfPatientrecordIDs() (ids []int) {
	for id := range m._EdgesOfPatientrecord {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfPatientrecord reset all changes of the "EdgesOfPatientrecord" edge.
func (m *PrenameMutation) ResetEdgesOfPatientrecord() {
	m._EdgesOfPatientrecord = nil
	m.removed_EdgesOfPatientrecord = nil
}

// Op returns the operation name.
func (m *PrenameMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Prename).
func (m *PrenameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PrenameMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.prefix != nil {
		fields = append(fields, prename.FieldPrefix)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PrenameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prename.FieldPrefix:
		return m.Prefix()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PrenameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prename.FieldPrefix:
		return m.OldPrefix(ctx)
	}
	return nil, fmt.Errorf("unknown Prename field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PrenameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prename.FieldPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefix(v)
		return nil
	}
	return fmt.Errorf("unknown Prename field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PrenameMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PrenameMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PrenameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Prename numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PrenameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PrenameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrenameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Prename nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PrenameMutation) ResetField(name string) error {
	switch name {
	case prename.FieldPrefix:
		m.ResetPrefix()
		return nil
	}
	return fmt.Errorf("unknown Prename field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PrenameMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._EdgesOfPrename2doctorinfo != nil {
		edges = append(edges, prename.EdgeEdgesOfPrename2doctorinfo)
	}
	if m._EdgesOfPatientrecord != nil {
		edges = append(edges, prename.EdgeEdgesOfPatientrecord)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PrenameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prename.EdgeEdgesOfPrename2doctorinfo:
		ids := make([]ent.Value, 0, len(m._EdgesOfPrename2doctorinfo))
		for id := range m._EdgesOfPrename2doctorinfo {
			ids = append(ids, id)
		}
		return ids
	case prename.EdgeEdgesOfPatientrecord:
		ids := make([]ent.Value, 0, len(m._EdgesOfPatientrecord))
		for id := range m._EdgesOfPatientrecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PrenameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_EdgesOfPrename2doctorinfo != nil {
		edges = append(edges, prename.EdgeEdgesOfPrename2doctorinfo)
	}
	if m.removed_EdgesOfPatientrecord != nil {
		edges = append(edges, prename.EdgeEdgesOfPatientrecord)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PrenameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prename.EdgeEdgesOfPrename2doctorinfo:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfPrename2doctorinfo))
		for id := range m.removed_EdgesOfPrename2doctorinfo {
			ids = append(ids, id)
		}
		return ids
	case prename.EdgeEdgesOfPatientrecord:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfPatientrecord))
		for id := range m.removed_EdgesOfPatientrecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PrenameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PrenameMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PrenameMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Prename unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PrenameMutation) ResetEdge(name string) error {
	switch name {
	case prename.EdgeEdgesOfPrename2doctorinfo:
		m.ResetEdgesOfPrename2doctorinfo()
		return nil
	case prename.EdgeEdgesOfPatientrecord:
		m.ResetEdgesOfPatientrecord()
		return nil
	}
	return fmt.Errorf("unknown Prename edge %s", name)
}

// RegistrarMutation represents an operation that mutate the Registrars
// nodes in the graph.
type RegistrarMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_Name               *string
	clearedFields       map[string]struct{}
	_EdgesOfUser        *int
	cleared_EdgesOfUser bool
	done                bool
	oldValue            func(context.Context) (*Registrar, error)
}

var _ ent.Mutation = (*RegistrarMutation)(nil)

// registrarOption allows to manage the mutation configuration using functional options.
type registrarOption func(*RegistrarMutation)

// newRegistrarMutation creates new mutation for $n.Name.
func newRegistrarMutation(c config, op Op, opts ...registrarOption) *RegistrarMutation {
	m := &RegistrarMutation{
		config:        c,
		op:            op,
		typ:           TypeRegistrar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegistrarID sets the id field of the mutation.
func withRegistrarID(id int) registrarOption {
	return func(m *RegistrarMutation) {
		var (
			err   error
			once  sync.Once
			value *Registrar
		)
		m.oldValue = func(ctx context.Context) (*Registrar, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Registrar.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegistrar sets the old Registrar of the mutation.
func withRegistrar(node *Registrar) registrarOption {
	return func(m *RegistrarMutation) {
		m.oldValue = func(context.Context) (*Registrar, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegistrarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegistrarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RegistrarMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the Name field.
func (m *RegistrarMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the Name value in the mutation.
func (m *RegistrarMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old Name value of the Registrar.
// If the Registrar object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RegistrarMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "Name" field.
func (m *RegistrarMutation) ResetName() {
	m._Name = nil
}

// SetEdgesOfUserID sets the EdgesOfUser edge to User by id.
func (m *RegistrarMutation) SetEdgesOfUserID(id int) {
	m._EdgesOfUser = &id
}

// ClearEdgesOfUser clears the EdgesOfUser edge to User.
func (m *RegistrarMutation) ClearEdgesOfUser() {
	m.cleared_EdgesOfUser = true
}

// EdgesOfUserCleared returns if the edge EdgesOfUser was cleared.
func (m *RegistrarMutation) EdgesOfUserCleared() bool {
	return m.cleared_EdgesOfUser
}

// EdgesOfUserID returns the EdgesOfUser id in the mutation.
func (m *RegistrarMutation) EdgesOfUserID() (id int, exists bool) {
	if m._EdgesOfUser != nil {
		return *m._EdgesOfUser, true
	}
	return
}

// EdgesOfUserIDs returns the EdgesOfUser ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfUserID instead. It exists only for internal usage by the builders.
func (m *RegistrarMutation) EdgesOfUserIDs() (ids []int) {
	if id := m._EdgesOfUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfUser reset all changes of the "EdgesOfUser" edge.
func (m *RegistrarMutation) ResetEdgesOfUser() {
	m._EdgesOfUser = nil
	m.cleared_EdgesOfUser = false
}

// Op returns the operation name.
func (m *RegistrarMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Registrar).
func (m *RegistrarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RegistrarMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Name != nil {
		fields = append(fields, registrar.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RegistrarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case registrar.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RegistrarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case registrar.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Registrar field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RegistrarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case registrar.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Registrar field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RegistrarMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RegistrarMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RegistrarMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Registrar numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RegistrarMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RegistrarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegistrarMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Registrar nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RegistrarMutation) ResetField(name string) error {
	switch name {
	case registrar.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Registrar field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RegistrarMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._EdgesOfUser != nil {
		edges = append(edges, registrar.EdgeEdgesOfUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RegistrarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case registrar.EdgeEdgesOfUser:
		if id := m._EdgesOfUser; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RegistrarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RegistrarMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RegistrarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_EdgesOfUser {
		edges = append(edges, registrar.EdgeEdgesOfUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RegistrarMutation) EdgeCleared(name string) bool {
	switch name {
	case registrar.EdgeEdgesOfUser:
		return m.cleared_EdgesOfUser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RegistrarMutation) ClearEdge(name string) error {
	switch name {
	case registrar.EdgeEdgesOfUser:
		m.ClearEdgesOfUser()
		return nil
	}
	return fmt.Errorf("unknown Registrar unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RegistrarMutation) ResetEdge(name string) error {
	switch name {
	case registrar.EdgeEdgesOfUser:
		m.ResetEdgesOfUser()
		return nil
	}
	return fmt.Errorf("unknown Registrar edge %s", name)
}

// SymptomseverityMutation represents an operation that mutate the Symptomseverities
// nodes in the graph.
type SymptomseverityMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	symptomseverity              *string
	clearedFields                map[string]struct{}
	_EdgesOfHistorytaking        map[int]struct{}
	removed_EdgesOfHistorytaking map[int]struct{}
	done                         bool
	oldValue                     func(context.Context) (*Symptomseverity, error)
}

var _ ent.Mutation = (*SymptomseverityMutation)(nil)

// symptomseverityOption allows to manage the mutation configuration using functional options.
type symptomseverityOption func(*SymptomseverityMutation)

// newSymptomseverityMutation creates new mutation for $n.Name.
func newSymptomseverityMutation(c config, op Op, opts ...symptomseverityOption) *SymptomseverityMutation {
	m := &SymptomseverityMutation{
		config:        c,
		op:            op,
		typ:           TypeSymptomseverity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSymptomseverityID sets the id field of the mutation.
func withSymptomseverityID(id int) symptomseverityOption {
	return func(m *SymptomseverityMutation) {
		var (
			err   error
			once  sync.Once
			value *Symptomseverity
		)
		m.oldValue = func(ctx context.Context) (*Symptomseverity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Symptomseverity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSymptomseverity sets the old Symptomseverity of the mutation.
func withSymptomseverity(node *Symptomseverity) symptomseverityOption {
	return func(m *SymptomseverityMutation) {
		m.oldValue = func(context.Context) (*Symptomseverity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SymptomseverityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SymptomseverityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SymptomseverityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSymptomseverity sets the symptomseverity field.
func (m *SymptomseverityMutation) SetSymptomseverity(s string) {
	m.symptomseverity = &s
}

// Symptomseverity returns the symptomseverity value in the mutation.
func (m *SymptomseverityMutation) Symptomseverity() (r string, exists bool) {
	v := m.symptomseverity
	if v == nil {
		return
	}
	return *v, true
}

// OldSymptomseverity returns the old symptomseverity value of the Symptomseverity.
// If the Symptomseverity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SymptomseverityMutation) OldSymptomseverity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSymptomseverity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSymptomseverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymptomseverity: %w", err)
	}
	return oldValue.Symptomseverity, nil
}

// ResetSymptomseverity reset all changes of the "symptomseverity" field.
func (m *SymptomseverityMutation) ResetSymptomseverity() {
	m.symptomseverity = nil
}

// AddEdgesOfHistorytakingIDs adds the EdgesOfHistorytaking edge to Historytaking by ids.
func (m *SymptomseverityMutation) AddEdgesOfHistorytakingIDs(ids ...int) {
	if m._EdgesOfHistorytaking == nil {
		m._EdgesOfHistorytaking = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfHistorytaking[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfHistorytakingIDs removes the EdgesOfHistorytaking edge to Historytaking by ids.
func (m *SymptomseverityMutation) RemoveEdgesOfHistorytakingIDs(ids ...int) {
	if m.removed_EdgesOfHistorytaking == nil {
		m.removed_EdgesOfHistorytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfHistorytaking[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfHistorytaking returns the removed ids of EdgesOfHistorytaking.
func (m *SymptomseverityMutation) RemovedEdgesOfHistorytakingIDs() (ids []int) {
	for id := range m.removed_EdgesOfHistorytaking {
		ids = append(ids, id)
	}
	return
}

// EdgesOfHistorytakingIDs returns the EdgesOfHistorytaking ids in the mutation.
func (m *SymptomseverityMutation) EdgesOfHistorytakingIDs() (ids []int) {
	for id := range m._EdgesOfHistorytaking {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfHistorytaking reset all changes of the "EdgesOfHistorytaking" edge.
func (m *SymptomseverityMutation) ResetEdgesOfHistorytaking() {
	m._EdgesOfHistorytaking = nil
	m.removed_EdgesOfHistorytaking = nil
}

// Op returns the operation name.
func (m *SymptomseverityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Symptomseverity).
func (m *SymptomseverityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SymptomseverityMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.symptomseverity != nil {
		fields = append(fields, symptomseverity.FieldSymptomseverity)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SymptomseverityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case symptomseverity.FieldSymptomseverity:
		return m.Symptomseverity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SymptomseverityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case symptomseverity.FieldSymptomseverity:
		return m.OldSymptomseverity(ctx)
	}
	return nil, fmt.Errorf("unknown Symptomseverity field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SymptomseverityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case symptomseverity.FieldSymptomseverity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymptomseverity(v)
		return nil
	}
	return fmt.Errorf("unknown Symptomseverity field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SymptomseverityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SymptomseverityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SymptomseverityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Symptomseverity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SymptomseverityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SymptomseverityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SymptomseverityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Symptomseverity nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SymptomseverityMutation) ResetField(name string) error {
	switch name {
	case symptomseverity.FieldSymptomseverity:
		m.ResetSymptomseverity()
		return nil
	}
	return fmt.Errorf("unknown Symptomseverity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SymptomseverityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._EdgesOfHistorytaking != nil {
		edges = append(edges, symptomseverity.EdgeEdgesOfHistorytaking)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SymptomseverityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case symptomseverity.EdgeEdgesOfHistorytaking:
		ids := make([]ent.Value, 0, len(m._EdgesOfHistorytaking))
		for id := range m._EdgesOfHistorytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SymptomseverityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_EdgesOfHistorytaking != nil {
		edges = append(edges, symptomseverity.EdgeEdgesOfHistorytaking)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SymptomseverityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case symptomseverity.EdgeEdgesOfHistorytaking:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfHistorytaking))
		for id := range m.removed_EdgesOfHistorytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SymptomseverityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SymptomseverityMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SymptomseverityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Symptomseverity unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SymptomseverityMutation) ResetEdge(name string) error {
	switch name {
	case symptomseverity.EdgeEdgesOfHistorytaking:
		m.ResetEdgesOfHistorytaking()
		return nil
	}
	return fmt.Errorf("unknown Symptomseverity edge %s", name)
}

// TreatmentMutation represents an operation that mutate the Treatments
// nodes in the graph.
type TreatmentMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	_Symptom                     *string
	_Treat                       *string
	_Medicine                    *string
	_Datetreat                   *time.Time
	clearedFields                map[string]struct{}
	_EdgesOfTypetreatment        *int
	cleared_EdgesOfTypetreatment bool
	_EdgesOfPatientrecord        *int
	cleared_EdgesOfPatientrecord bool
	_EdgesOfDoctor               *int
	cleared_EdgesOfDoctor        bool
	_EdgesOfUnpaybills           *int
	cleared_EdgesOfUnpaybills    bool
	done                         bool
	oldValue                     func(context.Context) (*Treatment, error)
}

var _ ent.Mutation = (*TreatmentMutation)(nil)

// treatmentOption allows to manage the mutation configuration using functional options.
type treatmentOption func(*TreatmentMutation)

// newTreatmentMutation creates new mutation for $n.Name.
func newTreatmentMutation(c config, op Op, opts ...treatmentOption) *TreatmentMutation {
	m := &TreatmentMutation{
		config:        c,
		op:            op,
		typ:           TypeTreatment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreatmentID sets the id field of the mutation.
func withTreatmentID(id int) treatmentOption {
	return func(m *TreatmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Treatment
		)
		m.oldValue = func(ctx context.Context) (*Treatment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Treatment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreatment sets the old Treatment of the mutation.
func withTreatment(node *Treatment) treatmentOption {
	return func(m *TreatmentMutation) {
		m.oldValue = func(context.Context) (*Treatment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreatmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreatmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TreatmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSymptom sets the Symptom field.
func (m *TreatmentMutation) SetSymptom(s string) {
	m._Symptom = &s
}

// Symptom returns the Symptom value in the mutation.
func (m *TreatmentMutation) Symptom() (r string, exists bool) {
	v := m._Symptom
	if v == nil {
		return
	}
	return *v, true
}

// OldSymptom returns the old Symptom value of the Treatment.
// If the Treatment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TreatmentMutation) OldSymptom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSymptom is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSymptom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymptom: %w", err)
	}
	return oldValue.Symptom, nil
}

// ResetSymptom reset all changes of the "Symptom" field.
func (m *TreatmentMutation) ResetSymptom() {
	m._Symptom = nil
}

// SetTreat sets the Treat field.
func (m *TreatmentMutation) SetTreat(s string) {
	m._Treat = &s
}

// Treat returns the Treat value in the mutation.
func (m *TreatmentMutation) Treat() (r string, exists bool) {
	v := m._Treat
	if v == nil {
		return
	}
	return *v, true
}

// OldTreat returns the old Treat value of the Treatment.
// If the Treatment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TreatmentMutation) OldTreat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTreat is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTreat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTreat: %w", err)
	}
	return oldValue.Treat, nil
}

// ResetTreat reset all changes of the "Treat" field.
func (m *TreatmentMutation) ResetTreat() {
	m._Treat = nil
}

// SetMedicine sets the Medicine field.
func (m *TreatmentMutation) SetMedicine(s string) {
	m._Medicine = &s
}

// Medicine returns the Medicine value in the mutation.
func (m *TreatmentMutation) Medicine() (r string, exists bool) {
	v := m._Medicine
	if v == nil {
		return
	}
	return *v, true
}

// OldMedicine returns the old Medicine value of the Treatment.
// If the Treatment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TreatmentMutation) OldMedicine(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMedicine is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMedicine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedicine: %w", err)
	}
	return oldValue.Medicine, nil
}

// ResetMedicine reset all changes of the "Medicine" field.
func (m *TreatmentMutation) ResetMedicine() {
	m._Medicine = nil
}

// SetDatetreat sets the Datetreat field.
func (m *TreatmentMutation) SetDatetreat(t time.Time) {
	m._Datetreat = &t
}

// Datetreat returns the Datetreat value in the mutation.
func (m *TreatmentMutation) Datetreat() (r time.Time, exists bool) {
	v := m._Datetreat
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetreat returns the old Datetreat value of the Treatment.
// If the Treatment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TreatmentMutation) OldDatetreat(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDatetreat is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDatetreat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetreat: %w", err)
	}
	return oldValue.Datetreat, nil
}

// ResetDatetreat reset all changes of the "Datetreat" field.
func (m *TreatmentMutation) ResetDatetreat() {
	m._Datetreat = nil
}

// SetEdgesOfTypetreatmentID sets the EdgesOfTypetreatment edge to Typetreatment by id.
func (m *TreatmentMutation) SetEdgesOfTypetreatmentID(id int) {
	m._EdgesOfTypetreatment = &id
}

// ClearEdgesOfTypetreatment clears the EdgesOfTypetreatment edge to Typetreatment.
func (m *TreatmentMutation) ClearEdgesOfTypetreatment() {
	m.cleared_EdgesOfTypetreatment = true
}

// EdgesOfTypetreatmentCleared returns if the edge EdgesOfTypetreatment was cleared.
func (m *TreatmentMutation) EdgesOfTypetreatmentCleared() bool {
	return m.cleared_EdgesOfTypetreatment
}

// EdgesOfTypetreatmentID returns the EdgesOfTypetreatment id in the mutation.
func (m *TreatmentMutation) EdgesOfTypetreatmentID() (id int, exists bool) {
	if m._EdgesOfTypetreatment != nil {
		return *m._EdgesOfTypetreatment, true
	}
	return
}

// EdgesOfTypetreatmentIDs returns the EdgesOfTypetreatment ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfTypetreatmentID instead. It exists only for internal usage by the builders.
func (m *TreatmentMutation) EdgesOfTypetreatmentIDs() (ids []int) {
	if id := m._EdgesOfTypetreatment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfTypetreatment reset all changes of the "EdgesOfTypetreatment" edge.
func (m *TreatmentMutation) ResetEdgesOfTypetreatment() {
	m._EdgesOfTypetreatment = nil
	m.cleared_EdgesOfTypetreatment = false
}

// SetEdgesOfPatientrecordID sets the EdgesOfPatientrecord edge to Patientrecord by id.
func (m *TreatmentMutation) SetEdgesOfPatientrecordID(id int) {
	m._EdgesOfPatientrecord = &id
}

// ClearEdgesOfPatientrecord clears the EdgesOfPatientrecord edge to Patientrecord.
func (m *TreatmentMutation) ClearEdgesOfPatientrecord() {
	m.cleared_EdgesOfPatientrecord = true
}

// EdgesOfPatientrecordCleared returns if the edge EdgesOfPatientrecord was cleared.
func (m *TreatmentMutation) EdgesOfPatientrecordCleared() bool {
	return m.cleared_EdgesOfPatientrecord
}

// EdgesOfPatientrecordID returns the EdgesOfPatientrecord id in the mutation.
func (m *TreatmentMutation) EdgesOfPatientrecordID() (id int, exists bool) {
	if m._EdgesOfPatientrecord != nil {
		return *m._EdgesOfPatientrecord, true
	}
	return
}

// EdgesOfPatientrecordIDs returns the EdgesOfPatientrecord ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfPatientrecordID instead. It exists only for internal usage by the builders.
func (m *TreatmentMutation) EdgesOfPatientrecordIDs() (ids []int) {
	if id := m._EdgesOfPatientrecord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfPatientrecord reset all changes of the "EdgesOfPatientrecord" edge.
func (m *TreatmentMutation) ResetEdgesOfPatientrecord() {
	m._EdgesOfPatientrecord = nil
	m.cleared_EdgesOfPatientrecord = false
}

// SetEdgesOfDoctorID sets the EdgesOfDoctor edge to Doctor by id.
func (m *TreatmentMutation) SetEdgesOfDoctorID(id int) {
	m._EdgesOfDoctor = &id
}

// ClearEdgesOfDoctor clears the EdgesOfDoctor edge to Doctor.
func (m *TreatmentMutation) ClearEdgesOfDoctor() {
	m.cleared_EdgesOfDoctor = true
}

// EdgesOfDoctorCleared returns if the edge EdgesOfDoctor was cleared.
func (m *TreatmentMutation) EdgesOfDoctorCleared() bool {
	return m.cleared_EdgesOfDoctor
}

// EdgesOfDoctorID returns the EdgesOfDoctor id in the mutation.
func (m *TreatmentMutation) EdgesOfDoctorID() (id int, exists bool) {
	if m._EdgesOfDoctor != nil {
		return *m._EdgesOfDoctor, true
	}
	return
}

// EdgesOfDoctorIDs returns the EdgesOfDoctor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfDoctorID instead. It exists only for internal usage by the builders.
func (m *TreatmentMutation) EdgesOfDoctorIDs() (ids []int) {
	if id := m._EdgesOfDoctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfDoctor reset all changes of the "EdgesOfDoctor" edge.
func (m *TreatmentMutation) ResetEdgesOfDoctor() {
	m._EdgesOfDoctor = nil
	m.cleared_EdgesOfDoctor = false
}

// SetEdgesOfUnpaybillsID sets the EdgesOfUnpaybills edge to Unpaybill by id.
func (m *TreatmentMutation) SetEdgesOfUnpaybillsID(id int) {
	m._EdgesOfUnpaybills = &id
}

// ClearEdgesOfUnpaybills clears the EdgesOfUnpaybills edge to Unpaybill.
func (m *TreatmentMutation) ClearEdgesOfUnpaybills() {
	m.cleared_EdgesOfUnpaybills = true
}

// EdgesOfUnpaybillsCleared returns if the edge EdgesOfUnpaybills was cleared.
func (m *TreatmentMutation) EdgesOfUnpaybillsCleared() bool {
	return m.cleared_EdgesOfUnpaybills
}

// EdgesOfUnpaybillsID returns the EdgesOfUnpaybills id in the mutation.
func (m *TreatmentMutation) EdgesOfUnpaybillsID() (id int, exists bool) {
	if m._EdgesOfUnpaybills != nil {
		return *m._EdgesOfUnpaybills, true
	}
	return
}

// EdgesOfUnpaybillsIDs returns the EdgesOfUnpaybills ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfUnpaybillsID instead. It exists only for internal usage by the builders.
func (m *TreatmentMutation) EdgesOfUnpaybillsIDs() (ids []int) {
	if id := m._EdgesOfUnpaybills; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfUnpaybills reset all changes of the "EdgesOfUnpaybills" edge.
func (m *TreatmentMutation) ResetEdgesOfUnpaybills() {
	m._EdgesOfUnpaybills = nil
	m.cleared_EdgesOfUnpaybills = false
}

// Op returns the operation name.
func (m *TreatmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Treatment).
func (m *TreatmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TreatmentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Symptom != nil {
		fields = append(fields, treatment.FieldSymptom)
	}
	if m._Treat != nil {
		fields = append(fields, treatment.FieldTreat)
	}
	if m._Medicine != nil {
		fields = append(fields, treatment.FieldMedicine)
	}
	if m._Datetreat != nil {
		fields = append(fields, treatment.FieldDatetreat)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TreatmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treatment.FieldSymptom:
		return m.Symptom()
	case treatment.FieldTreat:
		return m.Treat()
	case treatment.FieldMedicine:
		return m.Medicine()
	case treatment.FieldDatetreat:
		return m.Datetreat()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TreatmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treatment.FieldSymptom:
		return m.OldSymptom(ctx)
	case treatment.FieldTreat:
		return m.OldTreat(ctx)
	case treatment.FieldMedicine:
		return m.OldMedicine(ctx)
	case treatment.FieldDatetreat:
		return m.OldDatetreat(ctx)
	}
	return nil, fmt.Errorf("unknown Treatment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TreatmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treatment.FieldSymptom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymptom(v)
		return nil
	case treatment.FieldTreat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTreat(v)
		return nil
	case treatment.FieldMedicine:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedicine(v)
		return nil
	case treatment.FieldDatetreat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetreat(v)
		return nil
	}
	return fmt.Errorf("unknown Treatment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TreatmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TreatmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TreatmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Treatment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TreatmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TreatmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreatmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Treatment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TreatmentMutation) ResetField(name string) error {
	switch name {
	case treatment.FieldSymptom:
		m.ResetSymptom()
		return nil
	case treatment.FieldTreat:
		m.ResetTreat()
		return nil
	case treatment.FieldMedicine:
		m.ResetMedicine()
		return nil
	case treatment.FieldDatetreat:
		m.ResetDatetreat()
		return nil
	}
	return fmt.Errorf("unknown Treatment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TreatmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._EdgesOfTypetreatment != nil {
		edges = append(edges, treatment.EdgeEdgesOfTypetreatment)
	}
	if m._EdgesOfPatientrecord != nil {
		edges = append(edges, treatment.EdgeEdgesOfPatientrecord)
	}
	if m._EdgesOfDoctor != nil {
		edges = append(edges, treatment.EdgeEdgesOfDoctor)
	}
	if m._EdgesOfUnpaybills != nil {
		edges = append(edges, treatment.EdgeEdgesOfUnpaybills)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TreatmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case treatment.EdgeEdgesOfTypetreatment:
		if id := m._EdgesOfTypetreatment; id != nil {
			return []ent.Value{*id}
		}
	case treatment.EdgeEdgesOfPatientrecord:
		if id := m._EdgesOfPatientrecord; id != nil {
			return []ent.Value{*id}
		}
	case treatment.EdgeEdgesOfDoctor:
		if id := m._EdgesOfDoctor; id != nil {
			return []ent.Value{*id}
		}
	case treatment.EdgeEdgesOfUnpaybills:
		if id := m._EdgesOfUnpaybills; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TreatmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TreatmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TreatmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_EdgesOfTypetreatment {
		edges = append(edges, treatment.EdgeEdgesOfTypetreatment)
	}
	if m.cleared_EdgesOfPatientrecord {
		edges = append(edges, treatment.EdgeEdgesOfPatientrecord)
	}
	if m.cleared_EdgesOfDoctor {
		edges = append(edges, treatment.EdgeEdgesOfDoctor)
	}
	if m.cleared_EdgesOfUnpaybills {
		edges = append(edges, treatment.EdgeEdgesOfUnpaybills)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TreatmentMutation) EdgeCleared(name string) bool {
	switch name {
	case treatment.EdgeEdgesOfTypetreatment:
		return m.cleared_EdgesOfTypetreatment
	case treatment.EdgeEdgesOfPatientrecord:
		return m.cleared_EdgesOfPatientrecord
	case treatment.EdgeEdgesOfDoctor:
		return m.cleared_EdgesOfDoctor
	case treatment.EdgeEdgesOfUnpaybills:
		return m.cleared_EdgesOfUnpaybills
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TreatmentMutation) ClearEdge(name string) error {
	switch name {
	case treatment.EdgeEdgesOfTypetreatment:
		m.ClearEdgesOfTypetreatment()
		return nil
	case treatment.EdgeEdgesOfPatientrecord:
		m.ClearEdgesOfPatientrecord()
		return nil
	case treatment.EdgeEdgesOfDoctor:
		m.ClearEdgesOfDoctor()
		return nil
	case treatment.EdgeEdgesOfUnpaybills:
		m.ClearEdgesOfUnpaybills()
		return nil
	}
	return fmt.Errorf("unknown Treatment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TreatmentMutation) ResetEdge(name string) error {
	switch name {
	case treatment.EdgeEdgesOfTypetreatment:
		m.ResetEdgesOfTypetreatment()
		return nil
	case treatment.EdgeEdgesOfPatientrecord:
		m.ResetEdgesOfPatientrecord()
		return nil
	case treatment.EdgeEdgesOfDoctor:
		m.ResetEdgesOfDoctor()
		return nil
	case treatment.EdgeEdgesOfUnpaybills:
		m.ResetEdgesOfUnpaybills()
		return nil
	}
	return fmt.Errorf("unknown Treatment edge %s", name)
}

// TypetreatmentMutation represents an operation that mutate the Typetreatments
// nodes in the graph.
type TypetreatmentMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	_Typetreatment           *string
	clearedFields            map[string]struct{}
	_EdgesOfTreatment        map[int]struct{}
	removed_EdgesOfTreatment map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Typetreatment, error)
}

var _ ent.Mutation = (*TypetreatmentMutation)(nil)

// typetreatmentOption allows to manage the mutation configuration using functional options.
type typetreatmentOption func(*TypetreatmentMutation)

// newTypetreatmentMutation creates new mutation for $n.Name.
func newTypetreatmentMutation(c config, op Op, opts ...typetreatmentOption) *TypetreatmentMutation {
	m := &TypetreatmentMutation{
		config:        c,
		op:            op,
		typ:           TypeTypetreatment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTypetreatmentID sets the id field of the mutation.
func withTypetreatmentID(id int) typetreatmentOption {
	return func(m *TypetreatmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Typetreatment
		)
		m.oldValue = func(ctx context.Context) (*Typetreatment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Typetreatment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTypetreatment sets the old Typetreatment of the mutation.
func withTypetreatment(node *Typetreatment) typetreatmentOption {
	return func(m *TypetreatmentMutation) {
		m.oldValue = func(context.Context) (*Typetreatment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TypetreatmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TypetreatmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TypetreatmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTypetreatment sets the Typetreatment field.
func (m *TypetreatmentMutation) SetTypetreatment(s string) {
	m._Typetreatment = &s
}

// Typetreatment returns the Typetreatment value in the mutation.
func (m *TypetreatmentMutation) Typetreatment() (r string, exists bool) {
	v := m._Typetreatment
	if v == nil {
		return
	}
	return *v, true
}

// OldTypetreatment returns the old Typetreatment value of the Typetreatment.
// If the Typetreatment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TypetreatmentMutation) OldTypetreatment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypetreatment is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypetreatment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypetreatment: %w", err)
	}
	return oldValue.Typetreatment, nil
}

// ResetTypetreatment reset all changes of the "Typetreatment" field.
func (m *TypetreatmentMutation) ResetTypetreatment() {
	m._Typetreatment = nil
}

// AddEdgesOfTreatmentIDs adds the EdgesOfTreatment edge to Treatment by ids.
func (m *TypetreatmentMutation) AddEdgesOfTreatmentIDs(ids ...int) {
	if m._EdgesOfTreatment == nil {
		m._EdgesOfTreatment = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfTreatment[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfTreatmentIDs removes the EdgesOfTreatment edge to Treatment by ids.
func (m *TypetreatmentMutation) RemoveEdgesOfTreatmentIDs(ids ...int) {
	if m.removed_EdgesOfTreatment == nil {
		m.removed_EdgesOfTreatment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfTreatment[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfTreatment returns the removed ids of EdgesOfTreatment.
func (m *TypetreatmentMutation) RemovedEdgesOfTreatmentIDs() (ids []int) {
	for id := range m.removed_EdgesOfTreatment {
		ids = append(ids, id)
	}
	return
}

// EdgesOfTreatmentIDs returns the EdgesOfTreatment ids in the mutation.
func (m *TypetreatmentMutation) EdgesOfTreatmentIDs() (ids []int) {
	for id := range m._EdgesOfTreatment {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfTreatment reset all changes of the "EdgesOfTreatment" edge.
func (m *TypetreatmentMutation) ResetEdgesOfTreatment() {
	m._EdgesOfTreatment = nil
	m.removed_EdgesOfTreatment = nil
}

// Op returns the operation name.
func (m *TypetreatmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Typetreatment).
func (m *TypetreatmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TypetreatmentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Typetreatment != nil {
		fields = append(fields, typetreatment.FieldTypetreatment)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TypetreatmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case typetreatment.FieldTypetreatment:
		return m.Typetreatment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TypetreatmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case typetreatment.FieldTypetreatment:
		return m.OldTypetreatment(ctx)
	}
	return nil, fmt.Errorf("unknown Typetreatment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TypetreatmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case typetreatment.FieldTypetreatment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypetreatment(v)
		return nil
	}
	return fmt.Errorf("unknown Typetreatment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TypetreatmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TypetreatmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TypetreatmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Typetreatment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TypetreatmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TypetreatmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TypetreatmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Typetreatment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TypetreatmentMutation) ResetField(name string) error {
	switch name {
	case typetreatment.FieldTypetreatment:
		m.ResetTypetreatment()
		return nil
	}
	return fmt.Errorf("unknown Typetreatment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TypetreatmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._EdgesOfTreatment != nil {
		edges = append(edges, typetreatment.EdgeEdgesOfTreatment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TypetreatmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case typetreatment.EdgeEdgesOfTreatment:
		ids := make([]ent.Value, 0, len(m._EdgesOfTreatment))
		for id := range m._EdgesOfTreatment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TypetreatmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_EdgesOfTreatment != nil {
		edges = append(edges, typetreatment.EdgeEdgesOfTreatment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TypetreatmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case typetreatment.EdgeEdgesOfTreatment:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfTreatment))
		for id := range m.removed_EdgesOfTreatment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TypetreatmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TypetreatmentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TypetreatmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Typetreatment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TypetreatmentMutation) ResetEdge(name string) error {
	switch name {
	case typetreatment.EdgeEdgesOfTreatment:
		m.ResetEdgesOfTreatment()
		return nil
	}
	return fmt.Errorf("unknown Typetreatment edge %s", name)
}

// UnpaybillMutation represents an operation that mutate the Unpaybills
// nodes in the graph.
type UnpaybillMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	_Status                  *string
	clearedFields            map[string]struct{}
	_EdgesOfTreatment        *int
	cleared_EdgesOfTreatment bool
	_EdgesOfBills            *int
	cleared_EdgesOfBills     bool
	done                     bool
	oldValue                 func(context.Context) (*Unpaybill, error)
}

var _ ent.Mutation = (*UnpaybillMutation)(nil)

// unpaybillOption allows to manage the mutation configuration using functional options.
type unpaybillOption func(*UnpaybillMutation)

// newUnpaybillMutation creates new mutation for $n.Name.
func newUnpaybillMutation(c config, op Op, opts ...unpaybillOption) *UnpaybillMutation {
	m := &UnpaybillMutation{
		config:        c,
		op:            op,
		typ:           TypeUnpaybill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUnpaybillID sets the id field of the mutation.
func withUnpaybillID(id int) unpaybillOption {
	return func(m *UnpaybillMutation) {
		var (
			err   error
			once  sync.Once
			value *Unpaybill
		)
		m.oldValue = func(ctx context.Context) (*Unpaybill, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Unpaybill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUnpaybill sets the old Unpaybill of the mutation.
func withUnpaybill(node *Unpaybill) unpaybillOption {
	return func(m *UnpaybillMutation) {
		m.oldValue = func(context.Context) (*Unpaybill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UnpaybillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UnpaybillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UnpaybillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatus sets the Status field.
func (m *UnpaybillMutation) SetStatus(s string) {
	m._Status = &s
}

// Status returns the Status value in the mutation.
func (m *UnpaybillMutation) Status() (r string, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old Status value of the Unpaybill.
// If the Unpaybill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UnpaybillMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "Status" field.
func (m *UnpaybillMutation) ResetStatus() {
	m._Status = nil
}

// SetEdgesOfTreatmentID sets the EdgesOfTreatment edge to Treatment by id.
func (m *UnpaybillMutation) SetEdgesOfTreatmentID(id int) {
	m._EdgesOfTreatment = &id
}

// ClearEdgesOfTreatment clears the EdgesOfTreatment edge to Treatment.
func (m *UnpaybillMutation) ClearEdgesOfTreatment() {
	m.cleared_EdgesOfTreatment = true
}

// EdgesOfTreatmentCleared returns if the edge EdgesOfTreatment was cleared.
func (m *UnpaybillMutation) EdgesOfTreatmentCleared() bool {
	return m.cleared_EdgesOfTreatment
}

// EdgesOfTreatmentID returns the EdgesOfTreatment id in the mutation.
func (m *UnpaybillMutation) EdgesOfTreatmentID() (id int, exists bool) {
	if m._EdgesOfTreatment != nil {
		return *m._EdgesOfTreatment, true
	}
	return
}

// EdgesOfTreatmentIDs returns the EdgesOfTreatment ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfTreatmentID instead. It exists only for internal usage by the builders.
func (m *UnpaybillMutation) EdgesOfTreatmentIDs() (ids []int) {
	if id := m._EdgesOfTreatment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfTreatment reset all changes of the "EdgesOfTreatment" edge.
func (m *UnpaybillMutation) ResetEdgesOfTreatment() {
	m._EdgesOfTreatment = nil
	m.cleared_EdgesOfTreatment = false
}

// SetEdgesOfBillsID sets the EdgesOfBills edge to Bill by id.
func (m *UnpaybillMutation) SetEdgesOfBillsID(id int) {
	m._EdgesOfBills = &id
}

// ClearEdgesOfBills clears the EdgesOfBills edge to Bill.
func (m *UnpaybillMutation) ClearEdgesOfBills() {
	m.cleared_EdgesOfBills = true
}

// EdgesOfBillsCleared returns if the edge EdgesOfBills was cleared.
func (m *UnpaybillMutation) EdgesOfBillsCleared() bool {
	return m.cleared_EdgesOfBills
}

// EdgesOfBillsID returns the EdgesOfBills id in the mutation.
func (m *UnpaybillMutation) EdgesOfBillsID() (id int, exists bool) {
	if m._EdgesOfBills != nil {
		return *m._EdgesOfBills, true
	}
	return
}

// EdgesOfBillsIDs returns the EdgesOfBills ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfBillsID instead. It exists only for internal usage by the builders.
func (m *UnpaybillMutation) EdgesOfBillsIDs() (ids []int) {
	if id := m._EdgesOfBills; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfBills reset all changes of the "EdgesOfBills" edge.
func (m *UnpaybillMutation) ResetEdgesOfBills() {
	m._EdgesOfBills = nil
	m.cleared_EdgesOfBills = false
}

// Op returns the operation name.
func (m *UnpaybillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Unpaybill).
func (m *UnpaybillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UnpaybillMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Status != nil {
		fields = append(fields, unpaybill.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UnpaybillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case unpaybill.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UnpaybillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case unpaybill.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Unpaybill field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UnpaybillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case unpaybill.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Unpaybill field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UnpaybillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UnpaybillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UnpaybillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Unpaybill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UnpaybillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UnpaybillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UnpaybillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Unpaybill nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UnpaybillMutation) ResetField(name string) error {
	switch name {
	case unpaybill.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Unpaybill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UnpaybillMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._EdgesOfTreatment != nil {
		edges = append(edges, unpaybill.EdgeEdgesOfTreatment)
	}
	if m._EdgesOfBills != nil {
		edges = append(edges, unpaybill.EdgeEdgesOfBills)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UnpaybillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case unpaybill.EdgeEdgesOfTreatment:
		if id := m._EdgesOfTreatment; id != nil {
			return []ent.Value{*id}
		}
	case unpaybill.EdgeEdgesOfBills:
		if id := m._EdgesOfBills; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UnpaybillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UnpaybillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UnpaybillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_EdgesOfTreatment {
		edges = append(edges, unpaybill.EdgeEdgesOfTreatment)
	}
	if m.cleared_EdgesOfBills {
		edges = append(edges, unpaybill.EdgeEdgesOfBills)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UnpaybillMutation) EdgeCleared(name string) bool {
	switch name {
	case unpaybill.EdgeEdgesOfTreatment:
		return m.cleared_EdgesOfTreatment
	case unpaybill.EdgeEdgesOfBills:
		return m.cleared_EdgesOfBills
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UnpaybillMutation) ClearEdge(name string) error {
	switch name {
	case unpaybill.EdgeEdgesOfTreatment:
		m.ClearEdgesOfTreatment()
		return nil
	case unpaybill.EdgeEdgesOfBills:
		m.ClearEdgesOfBills()
		return nil
	}
	return fmt.Errorf("unknown Unpaybill unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UnpaybillMutation) ResetEdge(name string) error {
	switch name {
	case unpaybill.EdgeEdgesOfTreatment:
		m.ResetEdgesOfTreatment()
		return nil
	case unpaybill.EdgeEdgesOfBills:
		m.ResetEdgesOfBills()
		return nil
	}
	return fmt.Errorf("unknown Unpaybill edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	email                             *string
	password                          *string
	images                            *string
	clearedFields                     map[string]struct{}
	_EdgesOfFinancier                 *int
	cleared_EdgesOfFinancier          bool
	_EdgesOfNurse                     *int
	cleared_EdgesOfNurse              bool
	_EdgesOfUserPatientrights         *int
	cleared_EdgesOfUserPatientrights  bool
	_EdgesOfMedicalrecordstaff        *int
	cleared_EdgesOfMedicalrecordstaff bool
	_EdgesOfUser2registrar            *int
	cleared_EdgesOfUser2registrar     bool
	_EdgesOfDoctor                    *int
	cleared_EdgesOfDoctor             bool
	_EdgesOfUserstatus                *int
	cleared_EdgesOfUserstatus         bool
	done                              bool
	oldValue                          func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetImages sets the images field.
func (m *UserMutation) SetImages(s string) {
	m.images = &s
}

// Images returns the images value in the mutation.
func (m *UserMutation) Images() (r string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old images value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldImages(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImages is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// ResetImages reset all changes of the "images" field.
func (m *UserMutation) ResetImages() {
	m.images = nil
}

// SetEdgesOfFinancierID sets the EdgesOfFinancier edge to Financier by id.
func (m *UserMutation) SetEdgesOfFinancierID(id int) {
	m._EdgesOfFinancier = &id
}

// ClearEdgesOfFinancier clears the EdgesOfFinancier edge to Financier.
func (m *UserMutation) ClearEdgesOfFinancier() {
	m.cleared_EdgesOfFinancier = true
}

// EdgesOfFinancierCleared returns if the edge EdgesOfFinancier was cleared.
func (m *UserMutation) EdgesOfFinancierCleared() bool {
	return m.cleared_EdgesOfFinancier
}

// EdgesOfFinancierID returns the EdgesOfFinancier id in the mutation.
func (m *UserMutation) EdgesOfFinancierID() (id int, exists bool) {
	if m._EdgesOfFinancier != nil {
		return *m._EdgesOfFinancier, true
	}
	return
}

// EdgesOfFinancierIDs returns the EdgesOfFinancier ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfFinancierID instead. It exists only for internal usage by the builders.
func (m *UserMutation) EdgesOfFinancierIDs() (ids []int) {
	if id := m._EdgesOfFinancier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfFinancier reset all changes of the "EdgesOfFinancier" edge.
func (m *UserMutation) ResetEdgesOfFinancier() {
	m._EdgesOfFinancier = nil
	m.cleared_EdgesOfFinancier = false
}

// SetEdgesOfNurseID sets the EdgesOfNurse edge to Nurse by id.
func (m *UserMutation) SetEdgesOfNurseID(id int) {
	m._EdgesOfNurse = &id
}

// ClearEdgesOfNurse clears the EdgesOfNurse edge to Nurse.
func (m *UserMutation) ClearEdgesOfNurse() {
	m.cleared_EdgesOfNurse = true
}

// EdgesOfNurseCleared returns if the edge EdgesOfNurse was cleared.
func (m *UserMutation) EdgesOfNurseCleared() bool {
	return m.cleared_EdgesOfNurse
}

// EdgesOfNurseID returns the EdgesOfNurse id in the mutation.
func (m *UserMutation) EdgesOfNurseID() (id int, exists bool) {
	if m._EdgesOfNurse != nil {
		return *m._EdgesOfNurse, true
	}
	return
}

// EdgesOfNurseIDs returns the EdgesOfNurse ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfNurseID instead. It exists only for internal usage by the builders.
func (m *UserMutation) EdgesOfNurseIDs() (ids []int) {
	if id := m._EdgesOfNurse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfNurse reset all changes of the "EdgesOfNurse" edge.
func (m *UserMutation) ResetEdgesOfNurse() {
	m._EdgesOfNurse = nil
	m.cleared_EdgesOfNurse = false
}

// SetEdgesOfUserPatientrightsID sets the EdgesOfUserPatientrights edge to Patientrights by id.
func (m *UserMutation) SetEdgesOfUserPatientrightsID(id int) {
	m._EdgesOfUserPatientrights = &id
}

// ClearEdgesOfUserPatientrights clears the EdgesOfUserPatientrights edge to Patientrights.
func (m *UserMutation) ClearEdgesOfUserPatientrights() {
	m.cleared_EdgesOfUserPatientrights = true
}

// EdgesOfUserPatientrightsCleared returns if the edge EdgesOfUserPatientrights was cleared.
func (m *UserMutation) EdgesOfUserPatientrightsCleared() bool {
	return m.cleared_EdgesOfUserPatientrights
}

// EdgesOfUserPatientrightsID returns the EdgesOfUserPatientrights id in the mutation.
func (m *UserMutation) EdgesOfUserPatientrightsID() (id int, exists bool) {
	if m._EdgesOfUserPatientrights != nil {
		return *m._EdgesOfUserPatientrights, true
	}
	return
}

// EdgesOfUserPatientrightsIDs returns the EdgesOfUserPatientrights ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfUserPatientrightsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) EdgesOfUserPatientrightsIDs() (ids []int) {
	if id := m._EdgesOfUserPatientrights; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfUserPatientrights reset all changes of the "EdgesOfUserPatientrights" edge.
func (m *UserMutation) ResetEdgesOfUserPatientrights() {
	m._EdgesOfUserPatientrights = nil
	m.cleared_EdgesOfUserPatientrights = false
}

// SetEdgesOfMedicalrecordstaffID sets the EdgesOfMedicalrecordstaff edge to Medicalrecordstaff by id.
func (m *UserMutation) SetEdgesOfMedicalrecordstaffID(id int) {
	m._EdgesOfMedicalrecordstaff = &id
}

// ClearEdgesOfMedicalrecordstaff clears the EdgesOfMedicalrecordstaff edge to Medicalrecordstaff.
func (m *UserMutation) ClearEdgesOfMedicalrecordstaff() {
	m.cleared_EdgesOfMedicalrecordstaff = true
}

// EdgesOfMedicalrecordstaffCleared returns if the edge EdgesOfMedicalrecordstaff was cleared.
func (m *UserMutation) EdgesOfMedicalrecordstaffCleared() bool {
	return m.cleared_EdgesOfMedicalrecordstaff
}

// EdgesOfMedicalrecordstaffID returns the EdgesOfMedicalrecordstaff id in the mutation.
func (m *UserMutation) EdgesOfMedicalrecordstaffID() (id int, exists bool) {
	if m._EdgesOfMedicalrecordstaff != nil {
		return *m._EdgesOfMedicalrecordstaff, true
	}
	return
}

// EdgesOfMedicalrecordstaffIDs returns the EdgesOfMedicalrecordstaff ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfMedicalrecordstaffID instead. It exists only for internal usage by the builders.
func (m *UserMutation) EdgesOfMedicalrecordstaffIDs() (ids []int) {
	if id := m._EdgesOfMedicalrecordstaff; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfMedicalrecordstaff reset all changes of the "EdgesOfMedicalrecordstaff" edge.
func (m *UserMutation) ResetEdgesOfMedicalrecordstaff() {
	m._EdgesOfMedicalrecordstaff = nil
	m.cleared_EdgesOfMedicalrecordstaff = false
}

// SetEdgesOfUser2registrarID sets the EdgesOfUser2registrar edge to Registrar by id.
func (m *UserMutation) SetEdgesOfUser2registrarID(id int) {
	m._EdgesOfUser2registrar = &id
}

// ClearEdgesOfUser2registrar clears the EdgesOfUser2registrar edge to Registrar.
func (m *UserMutation) ClearEdgesOfUser2registrar() {
	m.cleared_EdgesOfUser2registrar = true
}

// EdgesOfUser2registrarCleared returns if the edge EdgesOfUser2registrar was cleared.
func (m *UserMutation) EdgesOfUser2registrarCleared() bool {
	return m.cleared_EdgesOfUser2registrar
}

// EdgesOfUser2registrarID returns the EdgesOfUser2registrar id in the mutation.
func (m *UserMutation) EdgesOfUser2registrarID() (id int, exists bool) {
	if m._EdgesOfUser2registrar != nil {
		return *m._EdgesOfUser2registrar, true
	}
	return
}

// EdgesOfUser2registrarIDs returns the EdgesOfUser2registrar ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfUser2registrarID instead. It exists only for internal usage by the builders.
func (m *UserMutation) EdgesOfUser2registrarIDs() (ids []int) {
	if id := m._EdgesOfUser2registrar; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfUser2registrar reset all changes of the "EdgesOfUser2registrar" edge.
func (m *UserMutation) ResetEdgesOfUser2registrar() {
	m._EdgesOfUser2registrar = nil
	m.cleared_EdgesOfUser2registrar = false
}

// SetEdgesOfDoctorID sets the EdgesOfDoctor edge to Doctor by id.
func (m *UserMutation) SetEdgesOfDoctorID(id int) {
	m._EdgesOfDoctor = &id
}

// ClearEdgesOfDoctor clears the EdgesOfDoctor edge to Doctor.
func (m *UserMutation) ClearEdgesOfDoctor() {
	m.cleared_EdgesOfDoctor = true
}

// EdgesOfDoctorCleared returns if the edge EdgesOfDoctor was cleared.
func (m *UserMutation) EdgesOfDoctorCleared() bool {
	return m.cleared_EdgesOfDoctor
}

// EdgesOfDoctorID returns the EdgesOfDoctor id in the mutation.
func (m *UserMutation) EdgesOfDoctorID() (id int, exists bool) {
	if m._EdgesOfDoctor != nil {
		return *m._EdgesOfDoctor, true
	}
	return
}

// EdgesOfDoctorIDs returns the EdgesOfDoctor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfDoctorID instead. It exists only for internal usage by the builders.
func (m *UserMutation) EdgesOfDoctorIDs() (ids []int) {
	if id := m._EdgesOfDoctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfDoctor reset all changes of the "EdgesOfDoctor" edge.
func (m *UserMutation) ResetEdgesOfDoctor() {
	m._EdgesOfDoctor = nil
	m.cleared_EdgesOfDoctor = false
}

// SetEdgesOfUserstatusID sets the EdgesOfUserstatus edge to Userstatus by id.
func (m *UserMutation) SetEdgesOfUserstatusID(id int) {
	m._EdgesOfUserstatus = &id
}

// ClearEdgesOfUserstatus clears the EdgesOfUserstatus edge to Userstatus.
func (m *UserMutation) ClearEdgesOfUserstatus() {
	m.cleared_EdgesOfUserstatus = true
}

// EdgesOfUserstatusCleared returns if the edge EdgesOfUserstatus was cleared.
func (m *UserMutation) EdgesOfUserstatusCleared() bool {
	return m.cleared_EdgesOfUserstatus
}

// EdgesOfUserstatusID returns the EdgesOfUserstatus id in the mutation.
func (m *UserMutation) EdgesOfUserstatusID() (id int, exists bool) {
	if m._EdgesOfUserstatus != nil {
		return *m._EdgesOfUserstatus, true
	}
	return
}

// EdgesOfUserstatusIDs returns the EdgesOfUserstatus ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EdgesOfUserstatusID instead. It exists only for internal usage by the builders.
func (m *UserMutation) EdgesOfUserstatusIDs() (ids []int) {
	if id := m._EdgesOfUserstatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEdgesOfUserstatus reset all changes of the "EdgesOfUserstatus" edge.
func (m *UserMutation) ResetEdgesOfUserstatus() {
	m._EdgesOfUserstatus = nil
	m.cleared_EdgesOfUserstatus = false
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.images != nil {
		fields = append(fields, user.FieldImages)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldImages:
		return m.Images()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldImages:
		return m.OldImages(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldImages:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldImages:
		m.ResetImages()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m._EdgesOfFinancier != nil {
		edges = append(edges, user.EdgeEdgesOfFinancier)
	}
	if m._EdgesOfNurse != nil {
		edges = append(edges, user.EdgeEdgesOfNurse)
	}
	if m._EdgesOfUserPatientrights != nil {
		edges = append(edges, user.EdgeEdgesOfUserPatientrights)
	}
	if m._EdgesOfMedicalrecordstaff != nil {
		edges = append(edges, user.EdgeEdgesOfMedicalrecordstaff)
	}
	if m._EdgesOfUser2registrar != nil {
		edges = append(edges, user.EdgeEdgesOfUser2registrar)
	}
	if m._EdgesOfDoctor != nil {
		edges = append(edges, user.EdgeEdgesOfDoctor)
	}
	if m._EdgesOfUserstatus != nil {
		edges = append(edges, user.EdgeEdgesOfUserstatus)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeEdgesOfFinancier:
		if id := m._EdgesOfFinancier; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeEdgesOfNurse:
		if id := m._EdgesOfNurse; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeEdgesOfUserPatientrights:
		if id := m._EdgesOfUserPatientrights; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeEdgesOfMedicalrecordstaff:
		if id := m._EdgesOfMedicalrecordstaff; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeEdgesOfUser2registrar:
		if id := m._EdgesOfUser2registrar; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeEdgesOfDoctor:
		if id := m._EdgesOfDoctor; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeEdgesOfUserstatus:
		if id := m._EdgesOfUserstatus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cleared_EdgesOfFinancier {
		edges = append(edges, user.EdgeEdgesOfFinancier)
	}
	if m.cleared_EdgesOfNurse {
		edges = append(edges, user.EdgeEdgesOfNurse)
	}
	if m.cleared_EdgesOfUserPatientrights {
		edges = append(edges, user.EdgeEdgesOfUserPatientrights)
	}
	if m.cleared_EdgesOfMedicalrecordstaff {
		edges = append(edges, user.EdgeEdgesOfMedicalrecordstaff)
	}
	if m.cleared_EdgesOfUser2registrar {
		edges = append(edges, user.EdgeEdgesOfUser2registrar)
	}
	if m.cleared_EdgesOfDoctor {
		edges = append(edges, user.EdgeEdgesOfDoctor)
	}
	if m.cleared_EdgesOfUserstatus {
		edges = append(edges, user.EdgeEdgesOfUserstatus)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeEdgesOfFinancier:
		return m.cleared_EdgesOfFinancier
	case user.EdgeEdgesOfNurse:
		return m.cleared_EdgesOfNurse
	case user.EdgeEdgesOfUserPatientrights:
		return m.cleared_EdgesOfUserPatientrights
	case user.EdgeEdgesOfMedicalrecordstaff:
		return m.cleared_EdgesOfMedicalrecordstaff
	case user.EdgeEdgesOfUser2registrar:
		return m.cleared_EdgesOfUser2registrar
	case user.EdgeEdgesOfDoctor:
		return m.cleared_EdgesOfDoctor
	case user.EdgeEdgesOfUserstatus:
		return m.cleared_EdgesOfUserstatus
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeEdgesOfFinancier:
		m.ClearEdgesOfFinancier()
		return nil
	case user.EdgeEdgesOfNurse:
		m.ClearEdgesOfNurse()
		return nil
	case user.EdgeEdgesOfUserPatientrights:
		m.ClearEdgesOfUserPatientrights()
		return nil
	case user.EdgeEdgesOfMedicalrecordstaff:
		m.ClearEdgesOfMedicalrecordstaff()
		return nil
	case user.EdgeEdgesOfUser2registrar:
		m.ClearEdgesOfUser2registrar()
		return nil
	case user.EdgeEdgesOfDoctor:
		m.ClearEdgesOfDoctor()
		return nil
	case user.EdgeEdgesOfUserstatus:
		m.ClearEdgesOfUserstatus()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeEdgesOfFinancier:
		m.ResetEdgesOfFinancier()
		return nil
	case user.EdgeEdgesOfNurse:
		m.ResetEdgesOfNurse()
		return nil
	case user.EdgeEdgesOfUserPatientrights:
		m.ResetEdgesOfUserPatientrights()
		return nil
	case user.EdgeEdgesOfMedicalrecordstaff:
		m.ResetEdgesOfMedicalrecordstaff()
		return nil
	case user.EdgeEdgesOfUser2registrar:
		m.ResetEdgesOfUser2registrar()
		return nil
	case user.EdgeEdgesOfDoctor:
		m.ResetEdgesOfDoctor()
		return nil
	case user.EdgeEdgesOfUserstatus:
		m.ResetEdgesOfUserstatus()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserstatusMutation represents an operation that mutate the Userstatuses
// nodes in the graph.
type UserstatusMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_Userstatus         *string
	clearedFields       map[string]struct{}
	_EdgesOfUser        map[int]struct{}
	removed_EdgesOfUser map[int]struct{}
	done                bool
	oldValue            func(context.Context) (*Userstatus, error)
}

var _ ent.Mutation = (*UserstatusMutation)(nil)

// userstatusOption allows to manage the mutation configuration using functional options.
type userstatusOption func(*UserstatusMutation)

// newUserstatusMutation creates new mutation for $n.Name.
func newUserstatusMutation(c config, op Op, opts ...userstatusOption) *UserstatusMutation {
	m := &UserstatusMutation{
		config:        c,
		op:            op,
		typ:           TypeUserstatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserstatusID sets the id field of the mutation.
func withUserstatusID(id int) userstatusOption {
	return func(m *UserstatusMutation) {
		var (
			err   error
			once  sync.Once
			value *Userstatus
		)
		m.oldValue = func(ctx context.Context) (*Userstatus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Userstatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserstatus sets the old Userstatus of the mutation.
func withUserstatus(node *Userstatus) userstatusOption {
	return func(m *UserstatusMutation) {
		m.oldValue = func(context.Context) (*Userstatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserstatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserstatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserstatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserstatus sets the Userstatus field.
func (m *UserstatusMutation) SetUserstatus(s string) {
	m._Userstatus = &s
}

// Userstatus returns the Userstatus value in the mutation.
func (m *UserstatusMutation) Userstatus() (r string, exists bool) {
	v := m._Userstatus
	if v == nil {
		return
	}
	return *v, true
}

// OldUserstatus returns the old Userstatus value of the Userstatus.
// If the Userstatus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserstatusMutation) OldUserstatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserstatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserstatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserstatus: %w", err)
	}
	return oldValue.Userstatus, nil
}

// ResetUserstatus reset all changes of the "Userstatus" field.
func (m *UserstatusMutation) ResetUserstatus() {
	m._Userstatus = nil
}

// AddEdgesOfUserIDs adds the EdgesOfUser edge to User by ids.
func (m *UserstatusMutation) AddEdgesOfUserIDs(ids ...int) {
	if m._EdgesOfUser == nil {
		m._EdgesOfUser = make(map[int]struct{})
	}
	for i := range ids {
		m._EdgesOfUser[ids[i]] = struct{}{}
	}
}

// RemoveEdgesOfUserIDs removes the EdgesOfUser edge to User by ids.
func (m *UserstatusMutation) RemoveEdgesOfUserIDs(ids ...int) {
	if m.removed_EdgesOfUser == nil {
		m.removed_EdgesOfUser = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EdgesOfUser[ids[i]] = struct{}{}
	}
}

// RemovedEdgesOfUser returns the removed ids of EdgesOfUser.
func (m *UserstatusMutation) RemovedEdgesOfUserIDs() (ids []int) {
	for id := range m.removed_EdgesOfUser {
		ids = append(ids, id)
	}
	return
}

// EdgesOfUserIDs returns the EdgesOfUser ids in the mutation.
func (m *UserstatusMutation) EdgesOfUserIDs() (ids []int) {
	for id := range m._EdgesOfUser {
		ids = append(ids, id)
	}
	return
}

// ResetEdgesOfUser reset all changes of the "EdgesOfUser" edge.
func (m *UserstatusMutation) ResetEdgesOfUser() {
	m._EdgesOfUser = nil
	m.removed_EdgesOfUser = nil
}

// Op returns the operation name.
func (m *UserstatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Userstatus).
func (m *UserstatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserstatusMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Userstatus != nil {
		fields = append(fields, userstatus.FieldUserstatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserstatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userstatus.FieldUserstatus:
		return m.Userstatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserstatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userstatus.FieldUserstatus:
		return m.OldUserstatus(ctx)
	}
	return nil, fmt.Errorf("unknown Userstatus field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserstatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userstatus.FieldUserstatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserstatus(v)
		return nil
	}
	return fmt.Errorf("unknown Userstatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserstatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserstatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserstatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Userstatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserstatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserstatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserstatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Userstatus nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserstatusMutation) ResetField(name string) error {
	switch name {
	case userstatus.FieldUserstatus:
		m.ResetUserstatus()
		return nil
	}
	return fmt.Errorf("unknown Userstatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserstatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._EdgesOfUser != nil {
		edges = append(edges, userstatus.EdgeEdgesOfUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserstatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userstatus.EdgeEdgesOfUser:
		ids := make([]ent.Value, 0, len(m._EdgesOfUser))
		for id := range m._EdgesOfUser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserstatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_EdgesOfUser != nil {
		edges = append(edges, userstatus.EdgeEdgesOfUser)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserstatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userstatus.EdgeEdgesOfUser:
		ids := make([]ent.Value, 0, len(m.removed_EdgesOfUser))
		for id := range m.removed_EdgesOfUser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserstatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserstatusMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserstatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Userstatus unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserstatusMutation) ResetEdge(name string) error {
	switch name {
	case userstatus.EdgeEdgesOfUser:
		m.ResetEdgesOfUser()
		return nil
	}
	return fmt.Errorf("unknown Userstatus edge %s", name)
}
